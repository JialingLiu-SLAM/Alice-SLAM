//
//  PoseGraphGlobal.cpp
//  VINS_MapFusion
//
//  Created by 张剑华 on 2020/6/16.
//  Copyright © 2020 zx. All rights reserved.
//

#include "PoseGraphGlobal.hpp"

vector<cv::Point2f> measurements_old_2d;
vector<Eigen::Vector3d> pointsCloud_old_3d;
vector<cv::Point2f> measurements_cur_2d;
vector< vector<cv::Point2f> > measurements_cur_all;
vector< vector<Eigen::Vector3d> > pointsCloud_old_all;
vector<int> curKF_id_all;

vector<Matrix3d> r_cn_c1_all;//poseGraphGlobal初始化时 设长度为10
vector<Vector3d> t_cn_c1_all;
vector<int> kf_index_all;

PoseGraphGlobal::PoseGraphGlobal(const char *_voc_file, int _image_w, int _image_h)
:demo_global(_voc_file,_image_w, _image_h), IMAGE_W(_image_w), IMAGE_H(_image_h){

    TH_LOW=50;
    MergingEnd=0;
    
    earliest_globalFuse_index.clear();
    latest_globalFuse_index.resize(10);
    cur_globalFuse_index.resize(10);
    q_cur_globalFuse_index.resize(10);
    r_w2_w1_allClient.resize(10);
    t_w2_w1_allClient.resize(10);
    
    r_w2_w1_allClient_cur.resize(10);
    t_w2_w1_allClient_cur.resize(10);
    
    has_pre_loop_index.resize(10);
    pre_loop_index.resize(10);
    
    feature_id_cur.resize(10);
    measurements_norm_main.resize(10);
    
    feature_id_main.resize(10);
    measurements_norm_cur.resize(10);
    
    earliest_global_loop_index.resize(10);
    latest_global_loop_index.resize(10);
    
    latest_globalLoop_index.resize(10);
    earliest_globalLoop_index.resize(10);
    uf= UnionFind(0,9);//总共10个
    
    r_ca_w2_cur.resize(10);
    t_ca_w2_cur.resize(10);
    
//    mv_demo_global.resize(10);
    mv_pushDatabase_num.resize(10);
    
    isOpposite.resize(10);
    
    pushDatabase_num=0;
    for(int i=0;i<10;i++){
        has_pre_loop_index[i]=false;
        earliest_global_loop_index[i]=-1;
        latest_global_loop_index[i]=std::make_pair(-1, -1);
        mv_pushDatabase_num[i]=0;
        
        latest_globalLoop_index[i]=-1;
        earliest_globalLoop_index[i]=-1;
    }
    max_frame_num_global=500;
//    f_manager_server_main();
    
    Ground_idx=0;
    
    r_cn_c1_all.resize(10);
    t_cn_c1_all.resize(10);
    
    printf("PoseGraphGlobal loop closure init finish\n");
}








//clientId_main并不是主地图的ID，是要被检索的地图的ID
bool PoseGraphGlobal::startLoopClosure_2(std::vector<cv::KeyPoint> &keys, std::vector<BRIEF::bitset> &descriptors,
                                   std::vector<cv::Point2f> &cur_pts,
                                   std::vector<cv::Point2f> &old_pts,
                                   int &old_index,int &min_startDetect_id,int cur_kf_global_index,int clientId_main, demoDetector_server<BriefVocabulary, BriefLoopDetector_server, FBrief::TDescriptor> &demo_test, int clientId)
{
  try
  {
    bool loop_succ = false;
//      cout<<"startLoopClosure_2"<<endl;
    loop_succ = demo_test.run("BRIEF", keys, descriptors, cur_pts, old_pts, old_index,min_startDetect_id,cur_kf_global_index, clientId);
//    loop_succ = mv_demo_global[clientId_main].run("BRIEF", keys, descriptors, cur_pts, old_pts, old_index,min_startDetect_id,cur_kf_global_index);
    return loop_succ;
  }
  catch(const std::string &ex)
  {
    cout << "Error loop: " << ex << endl;
    return false;
  }
}

//clientId_main并不是主地图的ID，是要被检索的地图的ID
//和startLoopClosure_2一样，只不过会利用返回的匹配点
bool PoseGraphGlobal::startLoopClosure_3(int keyPoint_num_main,std::vector<cv::KeyPoint> &keys, std::vector<BRIEF::bitset> &descriptors,
                                   std::vector<cv::Point2f> &cur_pts,
                                   std::vector<cv::Point2f> &old_pts,
                                   int &old_index,int &min_startDetect_id,int cur_kf_global_index,int clientId_main, demoDetector_server<BriefVocabulary, BriefLoopDetector_server, FBrief::TDescriptor> &demo_test, int clientId,std::vector<cv::Point2f> &cur_pts_3d, std::vector<cv::Point2f> &old_pts_2d)
{
  try
  {
    bool loop_succ = false;
//      cout<<"startLoopClosure_2"<<endl;
    loop_succ = demo_test.run2("BRIEF", keys, descriptors, cur_pts, old_pts, old_index,min_startDetect_id,cur_kf_global_index, clientId,keyPoint_num_main,cur_pts_3d ,old_pts_2d );
//    loop_succ = mv_demo_global[clientId_main].run("BRIEF", keys, descriptors, cur_pts, old_pts, old_index,min_startDetect_id,cur_kf_global_index);
    return loop_succ;
  }
  catch(const std::string &ex)
  {
    cout << "Error loop: " << ex << endl;
    return false;
  }
}

Eigen::Vector3f rotationMatrixToEulerAngles(Matrix3f &R)
{
    float sy = sqrt(R(0,0) * R(0,0) +  R(1,0) * R(1,0) );
    bool singular = sy < 1e-6; // If
    float x, y, z;
    if (!singular)
    {
        x = atan2(R(2,1) , R(2,2));
        y = atan2(-R(2,0), sy);
        z = atan2(R(1,0), R(0,0));
    }
    else
    {
        x = atan2(-R(1,2), R(1,1));
        y = atan2(-R(2,0), sy);
        z = 0;
    }
    #if 1
    x = x*180.0f/3.141592653589793f;
    y = y*180.0f/3.141592653589793f;
    z = z*180.0f/3.141592653589793f;
    #endif
    return Eigen::Vector3f(x, y, z);
}
 
bool oneEnd=true;




//这个是多机器人同时跑的版本 和主地图去匹配 传过来的也是主地图
void PoseGraphGlobal::loopClosureRun_global_11_2(int clientId_other){
//    cout<<"执行了吗 loopClosureRun_global_11_2"<<endl;
//    poseGraphGlobal_mutex.lock();
    readWriteLock.readLock();
        
    map<int,PoseGraph*>::iterator iter=PoseGraphGloabl_map.begin();
    int clientId_main=iter->first;
    assert(clientId_main==mainClientID);//验证一下是不是主地图
    PoseGraph* poseGraph_main=iter->second;
    list<KeyFrame*> keyFrameList_main=poseGraph_main->keyFrameList;
   
    //实验用 记录是不是最后的结束部分了
    bool isEnd=true;
        
        // 再加个判断 当前帧是否已经做过回环了 加了
        
        //其余所有人 都和第一个地图去比较

        assert(clientId_other!=mainClientID);
    
        map<int,PoseGraph*>::iterator iter_map = PoseGraphGloabl_map.find(clientId_other);
       
        if(iter_map==PoseGraphGloabl_map.end())
        {
//            poseGraphGlobal_mutex.unlock();
//            assert(false);
            readWriteLock.readUnLock();
            return ;
        }
        PoseGraph* poseGraph_other=iter_map->second;
//    poseGraphGlobal_mutex.unlock();
    readWriteLock.readUnLock();
        list<KeyFrame*> keyFrameList_other=poseGraph_other->keyFrameList;
        
        //实验用 判断程序结束没
        if(poseGraph_other->isEnd==false){
            isEnd=false;
        }
        
        if(keyFrameList_other.size()>0){
            KeyFrame* iter_kf_other=poseGraph_other->getLastKeyframe();
            if(iter_kf_other->check_global_loop[clientId_main]==false && iter_kf_other->is_des_end){
                iter_kf_other->check_global_loop[clientId_main]=true;
                isEnd=false;
        
                bool loop_succ=false;
                int old_index=-1;//这个后续要记录住的 我暂时还没记录 记录了
                
                vector<cv::Point2f> cur_pts;
                vector<cv::Point2f> old_pts;
                int min_startDetect_id=0;
//                loop_succ = startLoopClosure(iter_kf_other->keypoints, iter_kf_other->descriptors, cur_pts, old_pts, old_index,min_startDetect_id,iter_kf_other->global_index);//返回的应该是0号地图的哪一个帧
                 
                poseGraph_main->isAddKF2Database_mutex.lock();
                loop_succ = startLoopClosure_2(iter_kf_other->keypoints, iter_kf_other->descriptors, cur_pts, old_pts, old_index,min_startDetect_id,iter_kf_other->global_index, mainClientID, poseGraph_main->demo_global_in_poseGraph, clientId_other);//返回的应该是0号地图的哪一个帧
                poseGraph_main->isAddKF2Database_mutex.unlock();
                
                
                
                if(loop_succ)
                 {
                     list<KeyFrame*>::iterator main_kf_iter=poseGraph_main->getKeyframe_iter(old_index);
              if(main_kf_iter==poseGraph_main->keyFrameList.end()){
                  assert(false);
              }
              KeyFrame* old_kf=(*main_kf_iter);
              if (old_kf == NULL)
              {
                  printf("loopClosureRun_global NO such %dth frame in keyframe_database\n", old_index);
                  assert(false);
              }
              printf("loopClosureRun_global loop succ with %drd image\n", old_index);
              assert(old_index!=-1);
              
              Vector3d T_w_i_old;
              Matrix3d R_w_i_old;
             
              std::vector<cv::Point2f> measurements_old;//像素坐标
              std::vector<cv::Point2f> measurements_old_norm;//图像坐标
              std::vector<int> features_id;
              
              //新帧的3D点 老帧的2D点
              old_kf->getPose(T_w_i_old, R_w_i_old);
              iter_kf_other->findConnectionWithOldFrame_server_old(old_kf,measurements_old, measurements_old_norm);//找到匹配的特征点
              //这里本来用的measurements_cur和keypoints_old匹配上的
              

              //这里可以后面给一个初始值
              Matrix3f R_relative;
              Vector3f T_relative;
              
              //新帧的位姿
              Matrix3d r_curKF;
              Vector3d t_curKF;
              iter_kf_other->getPose( t_curKF,r_curKF);
              Matrix3f r_curKF_f=r_curKF.cast<float>();
              Vector3f t_curKF_f=t_curKF.cast<float>();

              //老帧的位姿
              Matrix3f r_oldKF_f_real=R_w_i_old.cast<float>();
              Vector3f t_oldKF_f_real=T_w_i_old.cast<float>();
              
              bool isAdd_otherClientId=false;
              if(poseGraph_main->fusion_relative_isUpdate[clientId_other]!=-2)
                  isAdd_otherClientId=true;
              

              
              
              vector<cv::Point3f> pts_3_vector;//这个应该乘以偏移量 这个可能需要记下来 在做全局优化的时候 乘了偏移量了 世界坐标
//                             bool is_fusion=(*iter_kf_other)->solveRelativePoseByPnP(measurements_old_norm ,R_relative, T_relative,pts_3_vector,isAdd_otherClientId);//这个算出来的是 新帧 -> 旧帧 位姿变化
              bool is_fusion=iter_kf_other->solveRelativePoseByPnP_2(measurements_old_norm ,R_relative, T_relative,pts_3_vector,false);
              
              if(is_fusion){
                  
                  Eigen::Vector3f t_w2_ia_test;
                  Eigen::Matrix3f r_w2_ia_test;
                  //思考这里 R——relative是不是代表 第2个世界坐标系到c1相机坐标系
                  old_kf->cam2Imu(T_relative, R_relative, t_w2_ia_test, r_w2_ia_test);
                  //a的imu坐标系 到 第2个世界坐标系
                  R_relative=r_w2_ia_test;
                  T_relative=t_w2_ia_test;
                  
                  
                  //保存信息 这里保存，暂时没用处，后续应该会删除 有用有用
                  old_kf->clientId_server.push_back(clientId_other);
                  old_kf->global_index_server.push_back(iter_kf_other->global_index);
                  
                  //此时 R_relative代表第2个世界坐标系到A点的相机坐标系
                  //B到A imu坐标系的转换
                  Matrix3f R_ia_ib=R_relative.transpose()*r_curKF_f;
                  Vector3f t_ia_ib=R_relative.transpose()*(t_curKF_f-T_relative);
                  
                  Matrix3f R_w1_ib=r_oldKF_f_real*R_ia_ib;
                  Vector3f t_w1_ib=r_oldKF_f_real*t_ia_ib+t_oldKF_f_real;
                  float relative_yaw_validate=Utility::normalizeAngle(Utility::R2ypr_float(r_oldKF_f_real).x()-Utility::R2ypr_float(R_w1_ib).x());
                  float relative_pitch_validate=Utility::normalizeAngle(Utility::R2ypr_float(r_oldKF_f_real).y()-Utility::R2ypr_float(R_w1_ib).y());
                  float relative_roll_validate=Utility::normalizeAngle(Utility::R2ypr_float(r_oldKF_f_real).z()-Utility::R2ypr_float(R_w1_ib).z());
                  //2020 8 没有问题
                  float relative_yaw_validate_t=Utility::normalizeAngle(Utility::R2ypr_float(R_ia_ib).x());
                  float relative_pitch_validate_t=Utility::normalizeAngle(Utility::R2ypr_float(R_ia_ib).y());
                  float relative_roll_validate_t=Utility::normalizeAngle(Utility::R2ypr_float(R_ia_ib).z());

                  
                  //这里改一改 改成世界坐标系下 角度相减
                  
                  
                  cout<<"relative_yaw_validate "<<relative_yaw_validate<<" "<<relative_yaw_validate_t<<endl;
                  cout<<"relative_pitch_validate "<<relative_pitch_validate<<" "<<relative_pitch_validate_t<<endl;
                  cout<<"relative_roll_validate "<<relative_roll_validate<<" "<<relative_roll_validate_t<<endl;
                  
                
                  if(!isAdd_otherClientId){
                      if(!(abs(relative_yaw_validate_t) <= 30.0 && t_ia_ib.norm() <= 20.0)){
                          cout<<"平移 或yaw变化过大"<<endl;
                          return;
//                          continue;
                      }
                          
                  }
                  
                  feature_id_cur[clientId_other]=iter_kf_other->features_id;
                  measurements_norm_main[clientId_other]=measurements_old_norm;
                  
                  //&&abs(relative_pitch_validate_t)<=30.0 &&abs(relative_roll_validate_t)<=30.0
//                  if(abs(relative_yaw_validate_t)<= 30.0){
                  
                  //验证是否是正确的回环 即yaw变化不超过30，relative不超过10
                  
//                  if (t_ia_ib.norm() <= 20.0){

//
                      Matrix3f R_main2other;
                      Vector3f T_main2other;
                                       
                      //这里求的是 主地图世界坐标系到2号地图世界坐标系的转换关系
                      R_main2other=R_relative*(r_oldKF_f_real.transpose());
                      T_main2other=T_relative-R_main2other*t_oldKF_f_real;
                       
                          
                      //这里待改
                      //这个是1号帧在2号地图的位姿
                      Matrix3f R_relative_1_in_2_w_i=R_relative;
                      Vector3f t_relative_1_in_2_w_i=T_relative;
                      //这里得到的是根据重投影误差的值 越小越好
                      //新帧的3D 世界坐标， 老帧的2D 图像坐标
//                      double score= getScore_relativePose_min_2(R_relative_1_in_2_w_i,t_relative_1_in_2_w_i,measurements_old_norm,pts_3_vector,old_kf);
//                      //得到新帧的2D 老帧的3D
//                      std::vector<cv::Point2f> measurements_cur;
//                      std::vector<cv::Point2f> measurements_cur_norm;
//                      old_kf->findConnectionWithOldFrame_server(iter_kf_other, cur_pts, old_pts, measurements_cur, measurements_cur_norm);
//                  feature_id_main[clientId_other]=old_kf->features_id;
//                  measurements_norm_cur[clientId_other]=measurements_cur_norm;
//                  //得到老帧的3D点
//                      vector<cv::Point3f> pts_3_vector_old;
//                      for(int i=0,len=old_kf->point_clouds.size();i<len;i++){
//                          Vector3d corre_pts_3=old_kf->point_clouds[i];
//                          pts_3_vector_old.push_back(cv::Point3f((float)corre_pts_3.x(),(float)corre_pts_3.y(),(float)corre_pts_3.z()));
//                      }
                      
                      
                      
                       //测试 后续可删除
                                                          
//                       cout<<"新帧在主地图的位姿"<<iter_kf_other->global_index<<endl;
                       
                       Matrix3f  r_curKF_f_bInMain=R_main2other.transpose()*r_curKF_f;
                       Vector3f t_curKF_f_bInMain=R_main2other.transpose()*(t_curKF_f-T_main2other);
                       
                    


//                                     float relative_yaw_validate=Utility::normalizeAngle(Utility::R2ypr_float(r_curKF_f_cout).x() - Utility::R2ypr_float(r_oldKF_f_real).x());
//                       cout<<"test relative_yaw_validate == t_relative.x"<<Utility::R2ypr_float(r_curKF_f_bInMain.transpose()).x() - Utility::R2ypr_float(r_oldKF_f_real.transpose()).x()<<" "<<Utility::R2ypr_float(r_curKF_f_bInMain.transpose()).x()<<" "<<Utility::R2ypr_float(r_oldKF_f_real.transpose()).x()<<endl;
                      
                         Matrix3f R_relative_best=R_main2other;
                         Vector3f T_relative_best=T_main2other;
                      
                      //这里表示 该地图第一次与主地图发生融合
                      if(!isAdd_otherClientId){
                         
                          
                          
                          poseGraph_other->refine_path_mutex.lock();
                         
                          //把融合地图的位姿转到主地图 保存到refine_path_draw
                          poseGraph_main->relative_r_mainToOther[clientId_other]=R_main2other;//记录相对位姿
                          poseGraph_main->relative_t_mainToOther[clientId_other]=T_main2other;
//                          poseGraph_main->relative_score_min[clientId_other]= score;//记录下标 和最低得分
                          poseGraph_other->relative_r_mainToOther[clientId_main]=R_main2other;
                          poseGraph_other->relative_t_mainToOther[clientId_main]=T_main2other;
                          poseGraph_other->refine_path_mutex.unlock();
                          
                          poseGraph_main->fusion_poseGraph_mutex.lock();
                          poseGraph_main->fusion_otherGraph[clientId_other]=poseGraph_other;//记录副地图
                          poseGraph_main->fusion_poseGraph_mutex.unlock();
                          
                          poseGraph_other->fusion_poseGraph_mutex.lock();
                          poseGraph_other->fusion_otherGraph[clientId_main]=poseGraph_main;//记录副地图
                          poseGraph_other->fusion_poseGraph_mutex.unlock();
                          
                      }

                      //加锁
                       poseGraph_other->isFirstFusion_globalMutex.lock();
                      //2号帧在1号地图的位姿 前面算过了
                      f_manager_server_main.feature.clear();
//                      int clientId_cur=iter_kf_other->c->id;
                      
                      if(!isAdd_otherClientId){
                          r_w2_w1_allClient[clientId_other]=R_relative_best.cast<double>();
                          t_w2_w1_allClient[clientId_other]=T_relative_best.cast<double>();
                      }
//
                      r_w2_w1_allClient_cur[clientId_other]=R_relative_best.cast<double>();
                      t_w2_w1_allClient_cur[clientId_other]=T_relative_best.cast<double>();
                      
                      
                      
                      cur_globalFuse_index[clientId_other]=std::make_pair(old_index, iter_kf_other->global_index);
                      
                      if(isFirstFusion[clientId_other]==0)
                          isFirstFusion[clientId_other]=4;
                      else if(isFirstFusion[clientId_other]==3)
                          isFirstFusion[clientId_other]=6;
                      else
                          isFirstFusion[clientId_other]=5;
                      old_kf->relative_r_server.push_back(R_relative_best);
                      old_kf->relative_t_server.push_back(T_relative_best);
                      poseGraph_other->isFirstFusion_globalMutex.unlock();
                      cout<<"地图融合成功"<<endl;
                      usleep(1000);

              }
                else{
                    cout<<"地图融合失败"<<endl;
                }
            }
                     
            }
        }
//    }
    
   
 
    usleep(50);

    //实验用 判断程序结束没
   if(poseGraph_main->isEnd==false){
       isEnd=false;
   }
    
    if(isEnd&&oneEnd){
        oneEnd=false;
        //记录位姿
        
        //此处是连接断开处，休眠3s，等回环检测和全局优化处理完
            usleep(3000);
            std::ofstream outFile;
            string path= "/Users/zhangjianhua/Desktop/VINS_MapFusion/VINS_MapFusion/data/pose_end.txt";
            
//        poseGraphGlobal_mutex.lock();
        readWriteLock.readLock();
        for(auto iter_start_record=PoseGraphGloabl_map.begin(),iter_end_record=PoseGraphGloabl_map.end();iter_start_record!=iter_end_record;iter_start_record++){
            PoseGraph* poseGraph_all=iter_start_record->second;
            //refine_path_draw_mutex
            unique_lock<mutex> lock_5(poseGraph_all->refine_path_draw_mutex);
            vector<Vector3f> refine_path_test=poseGraph_all->refine_path_draw;
            lock_5.unlock();
            
            unique_lock<mutex> lock_6(poseGraph_all->mMutexkeyFrameList);
            vector<double> path_time_test=poseGraph_all->path_time;//实验用
            vector<Matrix3f> refine_r_test=poseGraph_all->refine_path_r_draw;//实验用
            lock_6.unlock();
            
            Quaternion<float> Q;
            int len=refine_r_test.size();
            for(int i=0;i<len;i++){
                Q=refine_r_test[i];
                outFile.open(path, ios::binary | ios::app | ios::in | ios::out);
                outFile<<fixed <<setprecision(0)<<path_time_test[i]<<" ";
                outFile<<fixed <<setprecision(11)<<refine_path_test[i].x()<<" "<<refine_path_test[i].y()<<" "<<refine_path_test[i].z()<<" "<<Q.x()<<" "<<Q.y()<<" "<<Q.z()<<" "<<Q.w()<<"\n";
                outFile.close();
            }
        }
//        poseGraphGlobal_mutex.unlock();
        readWriteLock.readUnLock();
     
            printf("record pose end loopClosure11_2");
    }

}

//这个是多机器人同时跑的版本 主地图和其他人做匹配 传过来的也是其他人的地图
void PoseGraphGlobal::loopClosureRun_global_11_2_2(int clientId_main){
//    poseGraphGlobal_mutex.lock();
    readWriteLock.readLock();
    map<int,PoseGraph*>::iterator iter=PoseGraphGloabl_map.begin();
//    int clientId_main=iter->first;
    assert(clientId_main==mainClientID);//验证一下是不是主地图
    PoseGraph* poseGraph_main=iter->second;
    list<KeyFrame*> keyFrameList_main=poseGraph_main->keyFrameList;
   
    //实验用 记录是不是最后的结束部分了
    bool isEnd=true;
        
        // 再加个判断 当前帧是否已经做过回环了 加了
        //其余所有人 都和第一个地图去比较
    
    for(auto iter_end=PoseGraphGloabl_map.end();--iter_end , iter!=iter_end;){
        int clientId_other=iter_end->first;//这是自己的
        assert(clientId_other!=mainClientID);
        PoseGraph* poseGraph_other=iter_end->second;
        list<KeyFrame*> keyFrameList_other=poseGraph_other->keyFrameList;
        
        //实验用 判断程序结束没
        if(poseGraph_other->isEnd==false){
            isEnd=false;
        }
        
        if(keyFrameList_main.size()>0){
            KeyFrame* iter_kf_main=poseGraph_main->getLastKeyframe();
            if(iter_kf_main->check_global_loop[clientId_other]==false && iter_kf_main->is_des_end){
                iter_kf_main->check_global_loop[clientId_other]=true;
                isEnd=false;
        
                bool loop_succ=false;
                int old_index=-1;//这个后续要记录住的 我暂时还没记录 记录了
                
                vector<cv::Point2f> cur_pts;
                vector<cv::Point2f> old_pts;
                int min_startDetect_id=0;

                poseGraph_other->isAddKF2Database_mutex.lock();
                loop_succ = startLoopClosure_2(iter_kf_main->keypoints, iter_kf_main->descriptors,  old_pts, cur_pts, old_index,min_startDetect_id,iter_kf_main->global_index, clientId_other, poseGraph_other->demo_global_in_poseGraph, clientId_main);//返回的应该是其它地图的哪一个帧
                poseGraph_other->isAddKF2Database_mutex.unlock();
                
                
                if(loop_succ)
                 {
                     list<KeyFrame*>::iterator cur_kf_iter=poseGraph_other->getKeyframe_iter(old_index);
                      if(cur_kf_iter==poseGraph_other->keyFrameList.end()){
                          assert(false);
                      }
                      KeyFrame* cur_kf=(*cur_kf_iter);
                      if (cur_kf == NULL)
                      {
                          printf("cur loopClosureRun_global NO such %dth frame in keyframe_database\n", old_index);
                          assert(false);
                      }
                      printf("loopClosureRun_global loop succ with %drd image\n", old_index);
                      assert(old_index!=-1);
              
                      Vector3d T_w_i_cur;
                      Matrix3d R_w_i_cur;
                      cur_kf->getPose(T_w_i_cur, R_w_i_cur);
                      //老帧的位姿
                      Matrix3f r_curKF_f_real=R_w_i_cur.cast<float>();
                      Vector3f t_curKF_f_real=T_w_i_cur.cast<float>();
                     
                     
                      std::vector<cv::Point2f> measurements_cur;//像素坐标
                      std::vector<cv::Point2f> measurements_cur_norm;//图像坐标
                      std::vector<int> features_id;
                      //老帧的3D点  新帧的2D点
                      iter_kf_main->findConnectionWithOldFrame_server_old(cur_kf,  measurements_cur, measurements_cur_norm);//找到匹配的特征点
                      //这里本来用的measurements_cur和keypoints_old匹配上的
                      
                      //新帧的位姿
                      Matrix3d r_mainKF;
                      Vector3d t_mainKF;
                      iter_kf_main->getPose( t_mainKF,r_mainKF);
                      Matrix3f r_mainKF_f=r_mainKF.cast<float>();
                      Vector3f t_mainKF_f=t_mainKF.cast<float>();

                      
                      bool isAdd_otherClientId=false;
                      if(poseGraph_main->fusion_relative_isUpdate[clientId_other]!=-2)
                          isAdd_otherClientId=true;
                      
                      //这里可以后面给一个初始值 求出来的是第一个世界坐标系到c2相机坐标系
                      Matrix3f R_relative;
                      Vector3f T_relative;
                      vector<cv::Point3f> pts_3_vector;//这个应该乘以偏移量 这个可能需要记下来 在做全局优化的时候 乘了偏移量了 世界坐标
                      bool is_fusion=iter_kf_main->solveRelativePoseByPnP_2(measurements_cur_norm ,R_relative, T_relative,pts_3_vector,false);
              
                      if(is_fusion){
                          
                          Eigen::Vector3f t_w1_ib_test;
                          Eigen::Matrix3f r_w1_ib_test;
                          //思考这里 R——relative是不是代表 第1个世界坐标系到c2相机坐标系
                          cur_kf->cam2Imu(T_relative, R_relative, t_w1_ib_test, r_w1_ib_test);
                          //b的imu坐标系 到 第1个世界坐标系
                          R_relative=r_w1_ib_test;
                          T_relative=t_w1_ib_test;
                          
                          
                          //保存信息 这里保存，暂时没用处，后续应该会删除 有用有用
                          cur_kf->clientId_server.push_back(clientId_main);
                          cur_kf->global_index_server.push_back(iter_kf_main->global_index);
                          
                          //此时 R_relative代表第2个世界坐标系到A点的相机坐标系
                          //B到A imu坐标系的转换
                          Matrix3f R_ia_ib=r_mainKF_f.transpose()*R_relative;
                          Vector3f t_ia_ib=r_mainKF_f.transpose()*(T_relative- t_mainKF_f);
                          
//                          Matrix3f R_w2_ia=r_curKF_f_real*R_ia_ib;
//                          Vector3f t_w2_ia=r_curKF_f_real*t_ia_ib+t_curKF_f_real;
//                          float relative_yaw_validate=Utility::normalizeAngle(Utility::R2ypr_float(r_oldKF_f_real).x()-Utility::R2ypr_float(R_w1_ib).x());
//                          float relative_pitch_validate=Utility::normalizeAngle(Utility::R2ypr_float(r_oldKF_f_real).y()-Utility::R2ypr_float(R_w1_ib).y());
//                          float relative_roll_validate=Utility::normalizeAngle(Utility::R2ypr_float(r_oldKF_f_real).z()-Utility::R2ypr_float(R_w1_ib).z());
                          //2020 8 没有问题
                          float relative_yaw_validate_t=Utility::normalizeAngle(Utility::R2ypr_float(R_ia_ib).x());
                          float relative_pitch_validate_t=Utility::normalizeAngle(Utility::R2ypr_float(R_ia_ib).y());
                          float relative_roll_validate_t=Utility::normalizeAngle(Utility::R2ypr_float(R_ia_ib).z());

                          
                          //这里改一改 改成世界坐标系下 角度相减
                   
                        
                          if(!isAdd_otherClientId){
                              if(!(abs(relative_yaw_validate_t) <= 30.0 && t_ia_ib.norm() <= 20.0)){
                                  cout<<"平移 或yaw变化过大"<<endl;
                                  continue;
                              }
                                  
                          }
                          
                       
                              Matrix3f R_main2other;
                              Vector3f T_main2other;
                                               
                              //这里求的是 主地图世界坐标系到2号地图世界坐标系的转换关系
                              R_main2other=r_curKF_f_real*(R_relative.transpose());
                              T_main2other=t_curKF_f_real -R_main2other*T_relative;
                               
                                  
                              //这里待改
                              //这个是2号帧在1号地图的位姿
                              Matrix3f R_relative_2_in_1_w_i=R_relative;
                              Vector3f t_relative_2_in_1_w_i=T_relative;
                              //这里得到的是根据重投影误差的值 越小越好
                              //新帧的3D 世界坐标， 老帧的2D 图像坐标
       
                               //测试 后续可删除
                                                                  
//                               cout<<"新帧在主地图的位姿"<<iter_kf_main->global_index<<endl;
                               
                          //ib 到w1
                               Matrix3f  r_curKF_f_bInMain=R_main2other.transpose()*r_curKF_f_real;
                               Vector3f t_curKF_f_bInMain=R_main2other.transpose()*(t_curKF_f_real-T_main2other);
                               
                            


        //                                     float relative_yaw_validate=Utility::normalizeAngle(Utility::R2ypr_float(r_curKF_f_cout).x() - Utility::R2ypr_float(r_oldKF_f_real).x());
//                               cout<<"test relative_yaw_validate == t_relative.x"<<Utility::R2ypr_float(r_curKF_f_bInMain.transpose()).x() - Utility::R2ypr_float(r_curKF_f_real.transpose()).x()<<" "<<Utility::R2ypr_float(r_curKF_f_bInMain.transpose()).x()<<" "<<Utility::R2ypr_float(r_curKF_f_real.transpose()).x()<<endl;
                              
                                 Matrix3f R_relative_best=R_main2other;
                                 Vector3f T_relative_best=T_main2other;
                              
                              //这里表示 该地图第一次与主地图发生融合
                              if(!isAdd_otherClientId){
                                 
                                  
                                  
                                  poseGraph_other->refine_path_mutex.lock();
                                 
                                  //把融合地图的位姿转到主地图 保存到refine_path_draw
                                  poseGraph_main->relative_r_mainToOther[clientId_other]=R_main2other;//记录相对位姿
                                  poseGraph_main->relative_t_mainToOther[clientId_other]=T_main2other;
                                  poseGraph_other->relative_r_mainToOther[clientId_main]=R_main2other;
                                  poseGraph_other->relative_t_mainToOther[clientId_main]=T_main2other;
                                  poseGraph_other->refine_path_mutex.unlock();
                                  
                                  poseGraph_main->fusion_poseGraph_mutex.lock();
                                  poseGraph_main->fusion_otherGraph[clientId_other]=poseGraph_other;//记录副地图
                                  poseGraph_main->fusion_poseGraph_mutex.unlock();
                                  
                                  poseGraph_other->fusion_poseGraph_mutex.lock();
                                  poseGraph_other->fusion_otherGraph[clientId_main]=poseGraph_main;//记录副地图
                                  poseGraph_other->fusion_poseGraph_mutex.unlock();
                                  
                              }

                              //加锁
                               poseGraph_other->isFirstFusion_globalMutex.lock();
                              //2号帧在1号地图的位姿 前面算过了
//                              f_manager_server_main.feature.clear();
        //                      int clientId_cur=iter_kf_other->c->id;
                              
                              if(!isAdd_otherClientId){
                                  r_w2_w1_allClient[clientId_other]=R_relative_best.cast<double>();
                                  t_w2_w1_allClient[clientId_other]=T_relative_best.cast<double>();
                              }
        //
                              r_w2_w1_allClient_cur[clientId_other]=R_relative_best.cast<double>();
                              t_w2_w1_allClient_cur[clientId_other]=T_relative_best.cast<double>();
                              
                              
                              
                              cur_globalFuse_index[clientId_other]=std::make_pair(iter_kf_main->global_index, old_index);
                              
                              if(isFirstFusion[clientId_other]==0)
                                  isFirstFusion[clientId_other]=4;
                              else if(isFirstFusion[clientId_other]==3)
                                  isFirstFusion[clientId_other]=6;
                              else
                                  isFirstFusion[clientId_other]=5;
                              cur_kf->relative_r_server.push_back(R_relative_best);
                              cur_kf->relative_t_server.push_back(T_relative_best);
                              poseGraph_other->isFirstFusion_globalMutex.unlock();
                              cout<<"地图融合成功"<<endl;
                              usleep(1000);

                      }
                        else{
                            cout<<"地图融合失败"<<endl;
                        }
                    }
                     
            }
        }
    }
//    poseGraphGlobal_mutex.unlock();
    readWriteLock.readUnLock();
//   cout<<"PoseGraphGlobal 2592"<<endl;
 
//    usleep(50);

    //实验用 判断程序结束没
   if(poseGraph_main->isEnd==false){
       isEnd=false;
   }
    
    if(isEnd&&oneEnd){
        oneEnd=false;
        //记录位姿
        
        //此处是连接断开处，休眠3s，等回环检测和全局优化处理完
            usleep(3000);
            std::ofstream outFile;
            string path= "/Users/zhangjianhua/Desktop/VINS_MapFusion/VINS_MapFusion/data/pose_end.txt";
//        poseGraphGlobal_mutex.lock();
        readWriteLock.readLock();
        for(auto iter_start_record=PoseGraphGloabl_map.begin(),iter_end_record=PoseGraphGloabl_map.end();iter_start_record!=iter_end_record;iter_start_record++){
            PoseGraph* poseGraph_all=iter_start_record->second;
            //refine_path_draw_mutex
            unique_lock<mutex> lock_5(poseGraph_all->refine_path_draw_mutex);
            vector<Vector3f> refine_path_test=poseGraph_all->refine_path_draw;
            lock_5.unlock();
            
            unique_lock<mutex> lock_6(poseGraph_all->mMutexkeyFrameList);
            vector<double> path_time_test=poseGraph_all->path_time;//实验用
            vector<Matrix3f> refine_r_test=poseGraph_all->refine_path_r_draw;//实验用
            lock_6.unlock();
            
            Quaternion<float> Q;
            int len=refine_r_test.size();
            for(int i=0;i<len;i++){
                Q=refine_r_test[i];
                outFile.open(path, ios::binary | ios::app | ios::in | ios::out);
                outFile<<fixed <<setprecision(0)<<path_time_test[i]<<" ";
                outFile<<fixed <<setprecision(11)<<refine_path_test[i].x()<<" "<<refine_path_test[i].y()<<" "<<refine_path_test[i].z()<<" "<<Q.x()<<" "<<Q.y()<<" "<<Q.z()<<" "<<Q.w()<<"\n";
                outFile.close();
            }
        }
//        poseGraphGlobal_mutex.unlock();
        readWriteLock.readUnLock();
            printf("record pose end loopClosure11_2_2");
    }

}




//这个是多机器人同时跑的版本 和主地图去匹配 传过来的是主地图 这里应该是主地图去调用
void PoseGraphGlobal::loopClosureRun_global_11_3(int clientId_main){
    
    assert(clientId_main==mainClientID);
//    poseGraphGlobal_mutex.lock();
    readWriteLock.readLock();
    map<int,PoseGraph*>::iterator iter_map = PoseGraphGloabl_map.find(clientId_main);
    if(iter_map==PoseGraphGloabl_map.end())
    {
        assert(false);//找不到地图是不应该的
        return ;
    }
    PoseGraph* poseGraph_main=iter_map->second;
//    poseGraphGlobal_mutex.unlock();
    readWriteLock.readUnLock();
    list<KeyFrame*> keyFrameList_main=poseGraph_main->keyFrameList;
   
    //实验用 记录是不是最后的结束部分了
    bool isEnd=true;
     
     //拿其它所有地图和主地图去做比较
//    poseGraphGlobal_mutex.lock();
    readWriteLock.readLock();
    for(auto iter_end=PoseGraphGloabl_map.end();--iter_end , iter_map!=iter_end;){
//    for(auto iter_map_end=PoseGraphGloabl_map.rend(), iter_map_ing=PoseGraphGloabl_map.rbegin(); iter_map_ing!=iter_map_end; iter_map_ing++){
        PoseGraph* poseGraph_other=iter_end->second;
        int clientId_other=iter_end->first;
        list<KeyFrame*> keyFrameList_other=poseGraph_other->keyFrameList;
        
//        cout<<"测试 遍历子地图对不对："<<clientId_other<<endl;
        if(clientId_other!=clientId_main){
            //实验用 判断程序结束没
            if(poseGraph_other->isEnd==false){
                isEnd=false;
            }
                
            if(keyFrameList_other.size()>0){
                KeyFrame* iter_kf_other=poseGraph_other->getLastKeyframe();
                if(iter_kf_other->check_global_loop[clientId_main]==false && iter_kf_other->is_des_end){
                    iter_kf_other->check_global_loop[clientId_main]=true;
                    isEnd=false;
            
                    bool loop_succ=false;
                    int old_index=-1;//这个后续要记录住的 我暂时还没记录 记录了
                    vector<cv::Point2f> cur_pts;
                    vector<cv::Point2f> old_pts;
                    int min_startDetect_id=0;
                    
                    poseGraph_main->isAddKF2Database_mutex.lock();
                    loop_succ = startLoopClosure_2(iter_kf_other->keypoints, iter_kf_other->descriptors, cur_pts, old_pts, old_index,min_startDetect_id,iter_kf_other->global_index, mainClientID, poseGraph_main->demo_global_in_poseGraph, clientId_other);//返回的应该是0号地图的哪一个帧
                    poseGraph_main->isAddKF2Database_mutex.unlock();
                    
                    
                    if(loop_succ)
                     {
                         list<KeyFrame*>::iterator main_kf_iter=poseGraph_main->getKeyframe_iter(old_index);
                          if(main_kf_iter==poseGraph_main->keyFrameList.end()){
                              assert(false);
                          }
                          KeyFrame* old_kf=(*main_kf_iter);
                          if (old_kf == NULL)
                          {
                              printf("loopClosureRun_global NO such %dth frame in keyframe_database\n", old_index);
                              assert(false);
                          }
                          printf("loopClosureRun_global loop succ with %drd image\n", old_index);
                          assert(old_index!=-1);
                          
                          Vector3d T_w_i_old;
                          Matrix3d R_w_i_old;
                         
                          std::vector<cv::Point2f> measurements_old;//像素坐标
                          std::vector<cv::Point2f> measurements_old_norm;//图像坐标
                          std::vector<int> features_id;
                          
                          //新帧的3D点 老帧的2D点
                          old_kf->getPose(T_w_i_old, R_w_i_old);
                          iter_kf_other->findConnectionWithOldFrame_server_old(old_kf, measurements_old, measurements_old_norm);//找到匹配的特征点
                          //这里本来用的measurements_cur和keypoints_old匹配上的
                          

                          //这里可以后面给一个初始值
                          Matrix3f R_relative;
                          Vector3f T_relative;
                          
                          //新帧的位姿
                          Matrix3d r_curKF;
                          Vector3d t_curKF;
                          iter_kf_other->getPose( t_curKF,r_curKF);
                          Matrix3f r_curKF_f=r_curKF.cast<float>();
                          Vector3f t_curKF_f=t_curKF.cast<float>();

                          //老帧的位姿
                          Matrix3f r_oldKF_f_real=R_w_i_old.cast<float>();
                          Vector3f t_oldKF_f_real=T_w_i_old.cast<float>();
                          
                          bool isAdd_otherClientId=false;
                          if(poseGraph_main->fusion_relative_isUpdate[clientId_other]!=-2)
                              isAdd_otherClientId=true;
                          

                          
                          
                          vector<cv::Point3f> pts_3_vector;//这个应该乘以偏移量 这个可能需要记下来 在做全局优化的时候 乘了偏移量了 世界坐标
            //                             bool is_fusion=(*iter_kf_other)->solveRelativePoseByPnP(measurements_old_norm ,R_relative, T_relative,pts_3_vector,isAdd_otherClientId);//这个算出来的是 新帧 -> 旧帧 位姿变化
                          bool is_fusion=iter_kf_other->solveRelativePoseByPnP_2(measurements_old_norm ,R_relative, T_relative,pts_3_vector,false);
                          
                          if(is_fusion){
                              
                              Eigen::Vector3f t_w2_ia_test;
                              Eigen::Matrix3f r_w2_ia_test;
                              //思考这里 R——relative是不是代表 第2个世界坐标系到c1相机坐标系
                              old_kf->cam2Imu(T_relative, R_relative, t_w2_ia_test, r_w2_ia_test);
                              //a的imu坐标系 到 第2个世界坐标系
                              R_relative=r_w2_ia_test;
                              T_relative=t_w2_ia_test;
                              
                              
                              //保存信息 这里保存，暂时没用处，后续应该会删除 有用有用
                              old_kf->clientId_server.push_back(clientId_other);
                              old_kf->global_index_server.push_back(iter_kf_other->global_index);
                              
                              //此时 R_relative代表第2个世界坐标系到A点的相机坐标系
                              //B到A imu坐标系的转换
                              Matrix3f R_ia_ib=R_relative.transpose()*r_curKF_f;
                              Vector3f t_ia_ib=R_relative.transpose()*(t_curKF_f-T_relative);
                              
                              Matrix3f R_w1_ib=r_oldKF_f_real*R_ia_ib;
                              Vector3f t_w1_ib=r_oldKF_f_real*t_ia_ib+t_oldKF_f_real;
                              float relative_yaw_validate=Utility::normalizeAngle(Utility::R2ypr_float(r_oldKF_f_real).x()-Utility::R2ypr_float(R_w1_ib).x());
                              float relative_pitch_validate=Utility::normalizeAngle(Utility::R2ypr_float(r_oldKF_f_real).y()-Utility::R2ypr_float(R_w1_ib).y());
                              float relative_roll_validate=Utility::normalizeAngle(Utility::R2ypr_float(r_oldKF_f_real).z()-Utility::R2ypr_float(R_w1_ib).z());
                              //2020 8 没有问题
                              float relative_yaw_validate_t=Utility::normalizeAngle(Utility::R2ypr_float(R_ia_ib).x());
                              float relative_pitch_validate_t=Utility::normalizeAngle(Utility::R2ypr_float(R_ia_ib).y());
                              float relative_roll_validate_t=Utility::normalizeAngle(Utility::R2ypr_float(R_ia_ib).z());

                              
                              //这里改一改 改成世界坐标系下 角度相减
                              
                              
                              cout<<"relative_yaw_validate "<<relative_yaw_validate<<" "<<relative_yaw_validate_t<<endl;
                              cout<<"relative_pitch_validate "<<relative_pitch_validate<<" "<<relative_pitch_validate_t<<endl;
                              cout<<"relative_roll_validate "<<relative_roll_validate<<" "<<relative_roll_validate_t<<endl;
                              
                            
                              if(!isAdd_otherClientId){
                                  if(!(abs(relative_yaw_validate_t) <= 30.0 && t_ia_ib.norm() <= 20.0)){
                                      cout<<"平移 或yaw变化过大"<<endl;
//                                      return;
                                      continue;
                                  }
                                      
                              }
                              
                              feature_id_cur[clientId_other]=iter_kf_other->features_id;
                              measurements_norm_main[clientId_other]=measurements_old_norm;
                              
                              //&&abs(relative_pitch_validate_t)<=30.0 &&abs(relative_roll_validate_t)<=30.0
            //                  if(abs(relative_yaw_validate_t)<= 30.0){
                              
                              //验证是否是正确的回环 即yaw变化不超过30，relative不超过10
                              
            //                  if (t_ia_ib.norm() <= 20.0){

            //
                                  Matrix3f R_main2other;
                                  Vector3f T_main2other;
                                                   
                                  //这里求的是 主地图世界坐标系到2号地图世界坐标系的转换关系
                                  R_main2other=R_relative*(r_oldKF_f_real.transpose());
                                  T_main2other=T_relative-R_main2other*t_oldKF_f_real;
                                   
                                      
                                  //这里待改
                                  //这个是1号帧在2号地图的位姿
                                  Matrix3f R_relative_1_in_2_w_i=R_relative;
                                  Vector3f t_relative_1_in_2_w_i=T_relative;
                                  //这里得到的是根据重投影误差的值 越小越好
                                  //新帧的3D 世界坐标， 老帧的2D 图像坐标
            //                      double score= getScore_relativePose_min_2(R_relative_1_in_2_w_i,t_relative_1_in_2_w_i,measurements_old_norm,pts_3_vector,old_kf);
            //                      //得到新帧的2D 老帧的3D
            //                      std::vector<cv::Point2f> measurements_cur;
            //                      std::vector<cv::Point2f> measurements_cur_norm;
            //                      old_kf->findConnectionWithOldFrame_server(iter_kf_other, cur_pts, old_pts, measurements_cur, measurements_cur_norm);
            //                  feature_id_main[clientId_other]=old_kf->features_id;
            //                  measurements_norm_cur[clientId_other]=measurements_cur_norm;
            //                  //得到老帧的3D点
            //                      vector<cv::Point3f> pts_3_vector_old;
            //                      for(int i=0,len=old_kf->point_clouds.size();i<len;i++){
            //                          Vector3d corre_pts_3=old_kf->point_clouds[i];
            //                          pts_3_vector_old.push_back(cv::Point3f((float)corre_pts_3.x(),(float)corre_pts_3.y(),(float)corre_pts_3.z()));
            //                      }
                                  
                                  
                                  
                                   //测试 后续可删除
                                                                      
//                                   cout<<"新帧在主地图的位姿"<<iter_kf_other->global_index<<endl;
                                   
                                   Matrix3f  r_curKF_f_bInMain=R_main2other.transpose()*r_curKF_f;
                                   Vector3f t_curKF_f_bInMain=R_main2other.transpose()*(t_curKF_f-T_main2other);
                                   
                                


            //                                     float relative_yaw_validate=Utility::normalizeAngle(Utility::R2ypr_float(r_curKF_f_cout).x() - Utility::R2ypr_float(r_oldKF_f_real).x());
//                                   cout<<"test relative_yaw_validate == t_relative.x"<<Utility::R2ypr_float(r_curKF_f_bInMain.transpose()).x() - Utility::R2ypr_float(r_oldKF_f_real.transpose()).x()<<" "<<Utility::R2ypr_float(r_curKF_f_bInMain.transpose()).x()<<" "<<Utility::R2ypr_float(r_oldKF_f_real.transpose()).x()<<endl;
                                  
                                     Matrix3f R_relative_best=R_main2other;
                                     Vector3f T_relative_best=T_main2other;
                                  
                                  //这里表示 该地图第一次与主地图发生融合
                                  if(!isAdd_otherClientId){
                                     
                                      
                                      
                                      poseGraph_other->refine_path_mutex.lock();
                                     
                                      //把融合地图的位姿转到主地图 保存到refine_path_draw
                                      poseGraph_main->relative_r_mainToOther[clientId_other]=R_main2other;//记录相对位姿
                                      poseGraph_main->relative_t_mainToOther[clientId_other]=T_main2other;
            //                          poseGraph_main->relative_score_min[clientId_other]= score;//记录下标 和最低得分
                                      poseGraph_other->relative_r_mainToOther[clientId_main]=R_main2other;
                                      poseGraph_other->relative_t_mainToOther[clientId_main]=T_main2other;
                                      poseGraph_other->refine_path_mutex.unlock();
                                      
                                      poseGraph_main->fusion_poseGraph_mutex.lock();
                                      poseGraph_main->fusion_otherGraph[clientId_other]=poseGraph_other;//记录副地图
                                      poseGraph_main->fusion_poseGraph_mutex.unlock();
                                      
                                      poseGraph_other->fusion_poseGraph_mutex.lock();
                                      poseGraph_other->fusion_otherGraph[clientId_main]=poseGraph_main;//记录副地图
                                      poseGraph_other->fusion_poseGraph_mutex.unlock();
                                      
                                  }

                                  //加锁
                                   poseGraph_other->isFirstFusion_globalMutex.lock();
                                  //2号帧在1号地图的位姿 前面算过了
                                  f_manager_server_main.feature.clear();
            //                      int clientId_cur=iter_kf_other->c->id;
                                  
                                  if(!isAdd_otherClientId){
                                      r_w2_w1_allClient[clientId_other]=R_relative_best.cast<double>();
                                      t_w2_w1_allClient[clientId_other]=T_relative_best.cast<double>();
                                  }
            //
                                  r_w2_w1_allClient_cur[clientId_other]=R_relative_best.cast<double>();
                                  t_w2_w1_allClient_cur[clientId_other]=T_relative_best.cast<double>();
                                  
                                  
                                  
                                  cur_globalFuse_index[clientId_other]=std::make_pair(old_index, iter_kf_other->global_index);
                                  
                                  if(isFirstFusion[clientId_other]==0)
                                      isFirstFusion[clientId_other]=4;
                                  else if(isFirstFusion[clientId_other]==3)
                                      isFirstFusion[clientId_other]=6;
                                  else
                                      isFirstFusion[clientId_other]=5;
                                  old_kf->relative_r_server.push_back(R_relative_best);
                                  old_kf->relative_t_server.push_back(T_relative_best);
                                  poseGraph_other->isFirstFusion_globalMutex.unlock();
                                  cout<<"地图融合成功"<<endl;
                                  usleep(1000);

                          }
                          else{
                              cout<<"地图融合失败"<<endl;
                          }
                     }
                                 
                }
            }
        }
    
    }
//    poseGraphGlobal_mutex.unlock();
    readWriteLock.readUnLock();
   
 
    usleep(50);

    //实验用 判断程序结束没
   if(poseGraph_main->isEnd==false){
       isEnd=false;
   }
    
    if(isEnd&&oneEnd){
        oneEnd=false;
        //记录位姿
        
        //此处是连接断开处，休眠3s，等回环检测和全局优化处理完
            usleep(3000);
            std::ofstream outFile;
            string path= "/Users/zhangjianhua/Desktop/VINS_MapFusion/VINS_MapFusion/data/pose_end.txt";
//        poseGraphGlobal_mutex.lock();
        readWriteLock.readLock();
        for(auto iter_start_record=PoseGraphGloabl_map.begin(),iter_end_record=PoseGraphGloabl_map.end();iter_start_record!=iter_end_record;iter_start_record++){
            PoseGraph* poseGraph_all=iter_start_record->second;
            //refine_path_draw_mutex
            unique_lock<mutex> lock_5(poseGraph_all->refine_path_draw_mutex);
            vector<Vector3f> refine_path_test=poseGraph_all->refine_path_draw;
            lock_5.unlock();
            
            unique_lock<mutex> lock_6(poseGraph_all->mMutexkeyFrameList);
            vector<double> path_time_test=poseGraph_all->path_time;//实验用
            vector<Matrix3f> refine_r_test=poseGraph_all->refine_path_r_draw;//实验用
            lock_6.unlock();
            
            Quaternion<float> Q;
            int len=refine_r_test.size();
            for(int i=0;i<len;i++){
                Q=refine_r_test[i];
                outFile.open(path, ios::binary | ios::app | ios::in | ios::out);
                outFile<<fixed <<setprecision(0)<<path_time_test[i]<<" ";
                outFile<<fixed <<setprecision(11)<<refine_path_test[i].x()<<" "<<refine_path_test[i].y()<<" "<<refine_path_test[i].z()<<" "<<Q.x()<<" "<<Q.y()<<" "<<Q.z()<<" "<<Q.w()<<"\n";
                outFile.close();
            }
        }
//        poseGraphGlobal_mutex.unlock();
        readWriteLock.readUnLock();
            printf("record pose end loopClosure11_3");
    }

}

//这个是多机器人同时跑的版本 主地图和其他人做匹配 传过来的是其它地图 这里应该是其它地图去调用
void PoseGraphGlobal::loopClosureRun_global_11_3_2(int clientId_other){
//    poseGraphGlobal_mutex.lock();
    readWriteLock.readLock();
    map<int,PoseGraph*>::iterator iter=PoseGraphGloabl_map.begin();
    int clientId_main=iter->first;
    assert(clientId_main==mainClientID);//验证一下是不是主地图
    PoseGraph* poseGraph_main=iter->second;
    list<KeyFrame*> keyFrameList_main=poseGraph_main->keyFrameList;
   
    //实验用 记录是不是最后的结束部分了
    bool isEnd=true;
        
        // 再加个判断 当前帧是否已经做过回环了 加了
        //其余所有人 都和第一个地图去比较
    
    map<int,PoseGraph*>::iterator iter_map = PoseGraphGloabl_map.find(clientId_other);
    if(iter_map==PoseGraphGloabl_map.end())
    {
//        poseGraphGlobal_mutex.unlock();
        readWriteLock.readUnLock();
        assert(false);//找不到地图是不应该的
        return ;
    }
    PoseGraph* poseGraph_other=iter_map->second;
//    poseGraphGlobal_mutex.unlock();
    readWriteLock.readUnLock();
    list<KeyFrame*> keyFrameList_other=poseGraph_other->keyFrameList;
    
        
        //实验用 判断程序结束没
        if(poseGraph_other->isEnd==false){
            isEnd=false;
        }
        
        if(keyFrameList_main.size()>0){
            KeyFrame* iter_kf_main=poseGraph_main->getLastKeyframe();
            if(iter_kf_main->check_global_loop[clientId_other]==false && iter_kf_main->is_des_end){
                iter_kf_main->check_global_loop[clientId_other]=true;
                isEnd=false;
        
                bool loop_succ=false;
                int old_index=-1;//这个后续要记录住的 我暂时还没记录 记录了
                
                vector<cv::Point2f> cur_pts;
                vector<cv::Point2f> old_pts;
                int min_startDetect_id=0;

                poseGraph_other->isAddKF2Database_mutex.lock();
                loop_succ = startLoopClosure_2(iter_kf_main->keypoints, iter_kf_main->descriptors,  old_pts, cur_pts, old_index,min_startDetect_id,iter_kf_main->global_index, clientId_other, poseGraph_other->demo_global_in_poseGraph, clientId_main);//返回的应该是其它地图的哪一个帧
                poseGraph_other->isAddKF2Database_mutex.unlock();
                
                
                if(loop_succ)
                 {
                     list<KeyFrame*>::iterator cur_kf_iter=poseGraph_other->getKeyframe_iter(old_index);
                      if(cur_kf_iter==poseGraph_other->keyFrameList.end()){
                          assert(false);
                      }
                      KeyFrame* cur_kf=(*cur_kf_iter);
                      if (cur_kf == NULL)
                      {
                          printf("cur loopClosureRun_global NO such %dth frame in keyframe_database\n", old_index);
                          assert(false);
                      }
                      printf("loopClosureRun_global loop succ with %drd image\n", old_index);
                      assert(old_index!=-1);
              
                      Vector3d T_w_i_cur;
                      Matrix3d R_w_i_cur;
                      cur_kf->getPose(T_w_i_cur, R_w_i_cur);
                      //老帧的位姿
                      Matrix3f r_curKF_f_real=R_w_i_cur.cast<float>();
                      Vector3f t_curKF_f_real=T_w_i_cur.cast<float>();
                     
                     
                      std::vector<cv::Point2f> measurements_cur;//像素坐标
                      std::vector<cv::Point2f> measurements_cur_norm;//图像坐标
                      std::vector<int> features_id;
                      //老帧的3D点  新帧的2D点
                      iter_kf_main->findConnectionWithOldFrame_server_old(cur_kf, measurements_cur, measurements_cur_norm);//找到匹配的特征点
                      //这里本来用的measurements_cur和keypoints_old匹配上的
                      
                      //新帧的位姿
                      Matrix3d r_mainKF;
                      Vector3d t_mainKF;
                      iter_kf_main->getPose( t_mainKF,r_mainKF);
                      Matrix3f r_mainKF_f=r_mainKF.cast<float>();
                      Vector3f t_mainKF_f=t_mainKF.cast<float>();

                      
                      bool isAdd_otherClientId=false;
                      if(poseGraph_main->fusion_relative_isUpdate[clientId_other]!=-2)
                          isAdd_otherClientId=true;
                      
                      //这里可以后面给一个初始值 求出来的是第一个世界坐标系到c2相机坐标系
                      Matrix3f R_relative;
                      Vector3f T_relative;
                      vector<cv::Point3f> pts_3_vector;//这个应该乘以偏移量 这个可能需要记下来 在做全局优化的时候 乘了偏移量了 世界坐标
                      bool is_fusion=iter_kf_main->solveRelativePoseByPnP_2(measurements_cur_norm ,R_relative, T_relative,pts_3_vector,false);
              
                      if(is_fusion){
                          
                          Eigen::Vector3f t_w1_ib_test;
                          Eigen::Matrix3f r_w1_ib_test;
                          //思考这里 R——relative是不是代表 第1个世界坐标系到c2相机坐标系
                          cur_kf->cam2Imu(T_relative, R_relative, t_w1_ib_test, r_w1_ib_test);
                          //b的imu坐标系 到 第1个世界坐标系
                          R_relative=r_w1_ib_test;
                          T_relative=t_w1_ib_test;
                          
                          
                          //保存信息 这里保存，暂时没用处，后续应该会删除 有用有用
                          cur_kf->clientId_server.push_back(clientId_main);
                          cur_kf->global_index_server.push_back(iter_kf_main->global_index);
                          
                          //此时 R_relative代表第2个世界坐标系到A点的相机坐标系
                          //B到A imu坐标系的转换
                          Matrix3f R_ia_ib=r_mainKF_f.transpose()*R_relative;
                          Vector3f t_ia_ib=r_mainKF_f.transpose()*(T_relative- t_mainKF_f);
                          
//                          Matrix3f R_w2_ia=r_curKF_f_real*R_ia_ib;
//                          Vector3f t_w2_ia=r_curKF_f_real*t_ia_ib+t_curKF_f_real;
//                          float relative_yaw_validate=Utility::normalizeAngle(Utility::R2ypr_float(r_oldKF_f_real).x()-Utility::R2ypr_float(R_w1_ib).x());
//                          float relative_pitch_validate=Utility::normalizeAngle(Utility::R2ypr_float(r_oldKF_f_real).y()-Utility::R2ypr_float(R_w1_ib).y());
//                          float relative_roll_validate=Utility::normalizeAngle(Utility::R2ypr_float(r_oldKF_f_real).z()-Utility::R2ypr_float(R_w1_ib).z());
                          //2020 8 没有问题
                          float relative_yaw_validate_t=Utility::normalizeAngle(Utility::R2ypr_float(R_ia_ib).x());
                          float relative_pitch_validate_t=Utility::normalizeAngle(Utility::R2ypr_float(R_ia_ib).y());
                          float relative_roll_validate_t=Utility::normalizeAngle(Utility::R2ypr_float(R_ia_ib).z());

                          
                          //这里改一改 改成世界坐标系下 角度相减
                   
                        
                          if(!isAdd_otherClientId){
                              if(!(abs(relative_yaw_validate_t) <= 30.0 && t_ia_ib.norm() <= 20.0)){
                                  cout<<"平移 或yaw变化过大"<<endl;
                                  return;
                              }
                                  
                          }
                          
                       
                              Matrix3f R_main2other;
                              Vector3f T_main2other;
                                               
                              //这里求的是 主地图世界坐标系到2号地图世界坐标系的转换关系
                              R_main2other=r_curKF_f_real*(R_relative.transpose());
                              T_main2other=t_curKF_f_real -R_main2other*T_relative;
                               
                                  
                              //这里待改
                              //这个是2号帧在1号地图的位姿
                              Matrix3f R_relative_2_in_1_w_i=R_relative;
                              Vector3f t_relative_2_in_1_w_i=T_relative;
                              //这里得到的是根据重投影误差的值 越小越好
                              //新帧的3D 世界坐标， 老帧的2D 图像坐标
       
                               //测试 后续可删除
                                                                  
//                               cout<<"新帧在主地图的位姿"<<iter_kf_main->global_index<<endl;
                               
                          //ib 到w1
                               Matrix3f  r_curKF_f_bInMain=R_main2other.transpose()*r_curKF_f_real;
                               Vector3f t_curKF_f_bInMain=R_main2other.transpose()*(t_curKF_f_real-T_main2other);
                               
                            


        //                                     float relative_yaw_validate=Utility::normalizeAngle(Utility::R2ypr_float(r_curKF_f_cout).x() - Utility::R2ypr_float(r_oldKF_f_real).x());
//                               cout<<"test relative_yaw_validate == t_relative.x"<<Utility::R2ypr_float(r_curKF_f_bInMain.transpose()).x() - Utility::R2ypr_float(r_curKF_f_real.transpose()).x()<<" "<<Utility::R2ypr_float(r_curKF_f_bInMain.transpose()).x()<<" "<<Utility::R2ypr_float(r_curKF_f_real.transpose()).x()<<endl;
                              
                                 Matrix3f R_relative_best=R_main2other;
                                 Vector3f T_relative_best=T_main2other;
                              
                              //这里表示 该地图第一次与主地图发生融合
                              if(!isAdd_otherClientId){
                                 
                                  
                                  
                                  poseGraph_other->refine_path_mutex.lock();
                                 
                                  //把融合地图的位姿转到主地图 保存到refine_path_draw
                                  poseGraph_main->relative_r_mainToOther[clientId_other]=R_main2other;//记录相对位姿
                                  poseGraph_main->relative_t_mainToOther[clientId_other]=T_main2other;
                                  poseGraph_other->relative_r_mainToOther[clientId_main]=R_main2other;
                                  poseGraph_other->relative_t_mainToOther[clientId_main]=T_main2other;
                                  poseGraph_other->refine_path_mutex.unlock();
                                  
                                  poseGraph_main->fusion_poseGraph_mutex.lock();
                                  poseGraph_main->fusion_otherGraph[clientId_other]=poseGraph_other;//记录副地图
                                  poseGraph_main->fusion_poseGraph_mutex.unlock();
                                  
                                  poseGraph_other->fusion_poseGraph_mutex.lock();
                                  poseGraph_other->fusion_otherGraph[clientId_main]=poseGraph_main;//记录副地图
                                  poseGraph_other->fusion_poseGraph_mutex.unlock();
                                  
                              }

                              //加锁
                               poseGraph_other->isFirstFusion_globalMutex.lock();
                              //2号帧在1号地图的位姿 前面算过了
//                              f_manager_server_main.feature.clear();
        //                      int clientId_cur=iter_kf_other->c->id;
                              
                              if(!isAdd_otherClientId){
                                  r_w2_w1_allClient[clientId_other]=R_relative_best.cast<double>();
                                  t_w2_w1_allClient[clientId_other]=T_relative_best.cast<double>();
                              }
        //
                              r_w2_w1_allClient_cur[clientId_other]=R_relative_best.cast<double>();
                              t_w2_w1_allClient_cur[clientId_other]=T_relative_best.cast<double>();
                              
                              
                              
                              cur_globalFuse_index[clientId_other]=std::make_pair(iter_kf_main->global_index, old_index);
                              
                              if(isFirstFusion[clientId_other]==0)
                                  isFirstFusion[clientId_other]=4;
                              else if(isFirstFusion[clientId_other]==3)
                                  isFirstFusion[clientId_other]=6;
                              else
                                  isFirstFusion[clientId_other]=5;
                              cur_kf->relative_r_server.push_back(R_relative_best);
                              cur_kf->relative_t_server.push_back(T_relative_best);
                              poseGraph_other->isFirstFusion_globalMutex.unlock();
                              cout<<"地图融合成功"<<endl;
                              usleep(1000);

                      }
                        else{
                            cout<<"地图融合失败"<<endl;
                        }
                    }
                     
            }
        }
    
    
//   cout<<"PoseGraphGlobal 2592"<<endl;
 
//    usleep(50);

    //实验用 判断程序结束没
   if(poseGraph_main->isEnd==false){
       isEnd=false;
   }
    
    if(isEnd&&oneEnd){
        oneEnd=false;
        //记录位姿
        
        //此处是连接断开处，休眠3s，等回环检测和全局优化处理完
            usleep(3000);
            std::ofstream outFile;
            string path= "/Users/zhangjianhua/Desktop/VINS_MapFusion/VINS_MapFusion/data/pose_end.txt";
            
//        poseGraphGlobal_mutex.lock();
        readWriteLock.readLock();
        for(auto iter_start_record=PoseGraphGloabl_map.begin(),iter_end_record=PoseGraphGloabl_map.end();iter_start_record!=iter_end_record;iter_start_record++){
            PoseGraph* poseGraph_all=iter_start_record->second;
            //refine_path_draw_mutex
            unique_lock<mutex> lock_5(poseGraph_all->refine_path_draw_mutex);
            vector<Vector3f> refine_path_test=poseGraph_all->refine_path_draw;
            lock_5.unlock();
            
            unique_lock<mutex> lock_6(poseGraph_all->mMutexkeyFrameList);
            vector<double> path_time_test=poseGraph_all->path_time;//实验用
            vector<Matrix3f> refine_r_test=poseGraph_all->refine_path_r_draw;//实验用
            lock_6.unlock();
            
            Quaternion<float> Q;
            int len=refine_r_test.size();
            for(int i=0;i<len;i++){
                Q=refine_r_test[i];
                outFile.open(path, ios::binary | ios::app | ios::in | ios::out);
                outFile<<fixed <<setprecision(0)<<path_time_test[i]<<" ";
                outFile<<fixed <<setprecision(11)<<refine_path_test[i].x()<<" "<<refine_path_test[i].y()<<" "<<refine_path_test[i].z()<<" "<<Q.x()<<" "<<Q.y()<<" "<<Q.z()<<" "<<Q.w()<<"\n";
                outFile.close();
            }
        }
//        poseGraphGlobal_mutex.unlock();
        readWriteLock.readUnLock();
     
            printf("record pose end loopClosure11_3_2");
    }

}


//第2篇 改进实验测试
//这个是多机器人同时跑的版本 和主地图去匹配 传过来的是主地图 这里应该是主地图去调用
void PoseGraphGlobal::loopClosureRun_global_12_1(int clientId_main){
    
    assert(clientId_main==mainClientID);
//    poseGraphGlobal_mutex.lock();
    readWriteLock.readLock();
    map<int,PoseGraph*>::iterator iter_map = PoseGraphGloabl_map.find(clientId_main);
    if(iter_map==PoseGraphGloabl_map.end())
    {
//        poseGraphGlobal_mutex.unlock();
        readWriteLock.readUnLock();
        assert(false);//找不到地图是不应该的
        return ;
    }
    PoseGraph* poseGraph_main=iter_map->second;
//    poseGraphGlobal_mutex.unlock();
    readWriteLock.readUnLock();
    list<KeyFrame*> keyFrameList_main=poseGraph_main->keyFrameList;
   
    //实验用 记录是不是最后的结束部分了
    bool isEnd=true;
     
     //拿其它所有地图和主地图去做比较
//    poseGraphGlobal_mutex.lock();
    readWriteLock.readLock();
    for(auto iter_end=PoseGraphGloabl_map.end();--iter_end , iter_map!=iter_end;){
        PoseGraph* poseGraph_other=iter_end->second;
        int clientId_other=iter_end->first;
        list<KeyFrame*> keyFrameList_other=poseGraph_other->keyFrameList;
         
        if(clientId_other!=clientId_main){
            //实验用 判断程序结束没
            if(poseGraph_other->isEnd==false){
                isEnd=false;
            }
                
            if(keyFrameList_other.size()>0){
                KeyFrame* iter_kf_other=poseGraph_other->getLastKeyframe();
                if(iter_kf_other->check_global_loop[clientId_main]==false && iter_kf_other->is_des_end){
                    iter_kf_other->check_global_loop[clientId_main]=true;
                    isEnd=false;
            
                    bool loop_succ=false;
                    int old_index=-1;//这个后续要记录住的 我暂时还没记录 记录了
                    vector<cv::Point2f> cur_pts;
                    vector<cv::Point2f> old_pts;
                    int min_startDetect_id=0;
                    
                    poseGraph_main->isAddKF2Database_mutex.lock();
                    loop_succ = startLoopClosure_2(iter_kf_other->keypoints, iter_kf_other->descriptors, cur_pts, old_pts, old_index,min_startDetect_id,iter_kf_other->global_index, mainClientID, poseGraph_main->demo_global_in_poseGraph, clientId_other);//返回的应该是0号地图的哪一个帧
                    poseGraph_main->isAddKF2Database_mutex.unlock();
                    
                    
                    if(loop_succ)
                     {
                         list<KeyFrame*>::iterator main_kf_iter=poseGraph_main->getKeyframe_iter(old_index);
                          if(main_kf_iter==poseGraph_main->keyFrameList.end()){
                              assert(false);
                          }
                          KeyFrame* old_kf=(*main_kf_iter);
                          if (old_kf == NULL)
                          {
                              printf("loopClosureRun_global NO such %dth frame in keyframe_database\n", old_index);
                              assert(false);
                          }
                          printf("loopClosureRun_global loop succ with %drd image\n", old_index);
                          assert(old_index!=-1);
                          
                          
                         
                          std::vector<cv::Point2f> measurements_old;//像素坐标
                          std::vector<cv::Point2f> measurements_old_norm;//图像坐标
                          std::vector<int> features_id;
                          
                          //新帧的3D点 老帧的2D点(主地图)
                          iter_kf_other->findConnectionWithOldFrame_server_old(old_kf, measurements_old, measurements_old_norm);//找到匹配的特征点
                          //这里本来用的measurements_cur和keypoints_old匹配上的
                          

                          //这里可以后面给一个初始值
                          Matrix3f R_relative;
                          Vector3f T_relative;
                          
                          //新帧的位姿
                          Matrix3d r_curKF;
                          Vector3d t_curKF;
                          iter_kf_other->getPose( t_curKF,r_curKF);
                          Matrix3f r_curKF_f=r_curKF.cast<float>();
                          Vector3f t_curKF_f=t_curKF.cast<float>();

                          //老帧的位姿
                         Vector3d T_w_i_old;
                         Matrix3d R_w_i_old;
                         old_kf->getPose(T_w_i_old, R_w_i_old);
                          Matrix3f r_oldKF_f_real=R_w_i_old.cast<float>();
                          Vector3f t_oldKF_f_real=T_w_i_old.cast<float>();
                          
                          bool isAdd_otherClientId=false;
                          if(poseGraph_main->fusion_relative_isUpdate[clientId_other]!=-2)
                              isAdd_otherClientId=true;
                          

                          
                          
                          vector<cv::Point3f> pts_3_vector;//这个应该乘以偏移量 这个可能需要记下来 在做全局优化的时候 乘了偏移量了 世界坐标
            //                             bool is_fusion=(*iter_kf_other)->solveRelativePoseByPnP(measurements_old_norm ,R_relative, T_relative,pts_3_vector,isAdd_otherClientId);//这个算出来的是 新帧 -> 旧帧 位姿变化
                          bool is_fusion=iter_kf_other->solveRelativePoseByPnP_2(measurements_old_norm ,R_relative, T_relative,pts_3_vector,false);
                          
                          if(is_fusion){
                              
                              assert(measurements_old_norm.size()==measurements_old.size());
                              double fx=old_kf->c->FOCUS_LENGTH_X_server;
                              double fy=old_kf->c->FOCUS_LENGTH_Y_server;
                              
                              double cx=old_kf->c->PX_server;
                              double cy=old_kf->c->PY_server;
                              //测试 打印一下 未经过任何处理前 重投影误差
                              for(int aa=0, bb=pts_3_vector.size(); aa<bb ;aa++){
                                  cv::Point3f p3d=pts_3_vector[aa];
                                  cv::Point2f p2d=measurements_old[aa];
                                  
                                  Vector3f p3d_eigen;
                                  p3d_eigen<<p3d.x, p3d.y, p3d.z;
                                  
                                  Vector3f p3d_c1=R_relative*p3d_eigen+T_relative;
                                  float x_c1=fx*p3d_c1[0]/p3d_c1[2]+cx;
                                  float y_c1=fy*p3d_c1[1]/p3d_c1[2]+cy;
                                  
//                                  cout<<"匹配的两帧 单一一个点的像素坐标差："<<x_c1-p2d.x<<" "<<y_c1-p2d.y<<endl;
                              }
                              
                              
                              
                              
                              Eigen::Vector3f t_w2_ia_test;
                              Eigen::Matrix3f r_w2_ia_test;
                              //思考这里 R——relative是不是代表 第2个世界坐标系到c1相机坐标系
                              old_kf->cam2Imu(T_relative, R_relative, t_w2_ia_test, r_w2_ia_test);
                              //a的imu坐标系 到 第2个世界坐标系
                              R_relative=r_w2_ia_test;
                              T_relative=t_w2_ia_test;
                              
                              
                              //保存信息 这里保存，暂时没用处，后续应该会删除 有用有用
                              old_kf->clientId_server.push_back(clientId_other);
                              old_kf->global_index_server.push_back(iter_kf_other->global_index);
                              
                              //此时 R_relative代表第2个世界坐标系到A点的相机坐标系
                              //B到A imu坐标系的转换
                              Matrix3f R_ia_ib=R_relative.transpose()*r_curKF_f;
                              Vector3f t_ia_ib=R_relative.transpose()*(t_curKF_f-T_relative);
                              
                              Matrix3f R_w1_ib=r_oldKF_f_real*R_ia_ib;
                              Vector3f t_w1_ib=r_oldKF_f_real*t_ia_ib+t_oldKF_f_real;
                              float relative_yaw_validate=Utility::normalizeAngle(Utility::R2ypr_float(r_oldKF_f_real).x()-Utility::R2ypr_float(R_w1_ib).x());
                              float relative_pitch_validate=Utility::normalizeAngle(Utility::R2ypr_float(r_oldKF_f_real).y()-Utility::R2ypr_float(R_w1_ib).y());
                              float relative_roll_validate=Utility::normalizeAngle(Utility::R2ypr_float(r_oldKF_f_real).z()-Utility::R2ypr_float(R_w1_ib).z());
                              //2020 8 没有问题
                              float relative_yaw_validate_t=Utility::normalizeAngle(Utility::R2ypr_float(R_ia_ib).x());
                              float relative_pitch_validate_t=Utility::normalizeAngle(Utility::R2ypr_float(R_ia_ib).y());
                              float relative_roll_validate_t=Utility::normalizeAngle(Utility::R2ypr_float(R_ia_ib).z());

                              
                              //这里改一改 改成世界坐标系下 角度相减
                              
                              
                              cout<<"relative_yaw_validate "<<relative_yaw_validate<<" "<<relative_yaw_validate_t<<endl;
                              cout<<"relative_pitch_validate "<<relative_pitch_validate<<" "<<relative_pitch_validate_t<<endl;
                              cout<<"relative_roll_validate "<<relative_roll_validate<<" "<<relative_roll_validate_t<<endl;
                              
                            
                              if(!isAdd_otherClientId){
                                  if(!(abs(relative_yaw_validate_t) <= 30.0 && t_ia_ib.norm() <= 20.0)){
                                      cout<<"平移 或yaw变化过大"<<endl;
//                                      return;
                                      continue;
                                  }
                                      
                              }
                              
                              feature_id_cur[clientId_other]=iter_kf_other->features_id;
                              measurements_norm_main[clientId_other]=measurements_old_norm;
                              
                              //&&abs(relative_pitch_validate_t)<=30.0 &&abs(relative_roll_validate_t)<=30.0
            //                  if(abs(relative_yaw_validate_t)<= 30.0){
                              
                              //验证是否是正确的回环 即yaw变化不超过30，relative不超过10
                              
            //                  if (t_ia_ib.norm() <= 20.0){

            //
                                  Matrix3f R_main2other;
                                  Vector3f T_main2other;
                                                   
                                  //这里求的是 主地图世界坐标系到2号地图世界坐标系的转换关系
                                  R_main2other=R_relative*(r_oldKF_f_real.transpose());
                                  T_main2other=T_relative-R_main2other*t_oldKF_f_real;
                                   
                                      
                                  //这里待改
                                  //这个是1号帧在2号地图的位姿
                                  Matrix3f R_relative_1_in_2_w_i=R_relative;
                                  Vector3f t_relative_1_in_2_w_i=T_relative;
                                  //这里得到的是根据重投影误差的值 越小越好
                                  //新帧的3D 世界坐标， 老帧的2D 图像坐标
            //                      double score= getScore_relativePose_min_2(R_relative_1_in_2_w_i,t_relative_1_in_2_w_i,measurements_old_norm,pts_3_vector,old_kf);
            //                      //得到新帧的2D 老帧的3D
            //                      std::vector<cv::Point2f> measurements_cur;
            //                      std::vector<cv::Point2f> measurements_cur_norm;
            //                      old_kf->findConnectionWithOldFrame_server(iter_kf_other, cur_pts, old_pts, measurements_cur, measurements_cur_norm);
            //                  feature_id_main[clientId_other]=old_kf->features_id;
            //                  measurements_norm_cur[clientId_other]=measurements_cur_norm;
            //                  //得到老帧的3D点
            //                      vector<cv::Point3f> pts_3_vector_old;
            //                      for(int i=0,len=old_kf->point_clouds.size();i<len;i++){
            //                          Vector3d corre_pts_3=old_kf->point_clouds[i];
            //                          pts_3_vector_old.push_back(cv::Point3f((float)corre_pts_3.x(),(float)corre_pts_3.y(),(float)corre_pts_3.z()));
            //                      }
                                  
                                  
                                  
                                   //测试 后续可删除
                                                                      
//                                   cout<<"新帧在主地图的位姿"<<iter_kf_other->global_index<<endl;
                                   
                                   Matrix3f  r_curKF_f_bInMain=R_main2other.transpose()*r_curKF_f;
                                   Vector3f t_curKF_f_bInMain=R_main2other.transpose()*(t_curKF_f-T_main2other);
                                   
                                


            //                                     float relative_yaw_validate=Utility::normalizeAngle(Utility::R2ypr_float(r_curKF_f_cout).x() - Utility::R2ypr_float(r_oldKF_f_real).x());
//                                   cout<<"test relative_yaw_validate == t_relative.x"<<Utility::R2ypr_float(r_curKF_f_bInMain.transpose()).x() - Utility::R2ypr_float(r_oldKF_f_real.transpose()).x()<<" "<<Utility::R2ypr_float(r_curKF_f_bInMain.transpose()).x()<<" "<<Utility::R2ypr_float(r_oldKF_f_real.transpose()).x()<<endl;
                                  
                                     Matrix3f R_relative_best=R_main2other;
                                     Vector3f T_relative_best=T_main2other;
                                  
                                  //这里表示 该地图第一次与主地图发生融合
                                  if(!isAdd_otherClientId){
                                     
                                      
                                      
                                      poseGraph_other->refine_path_mutex.lock();
                                     
                                      //把融合地图的位姿转到主地图 保存到refine_path_draw
                                      poseGraph_main->relative_r_mainToOther[clientId_other]=R_main2other;//记录相对位姿
                                      poseGraph_main->relative_t_mainToOther[clientId_other]=T_main2other;
            //                          poseGraph_main->relative_score_min[clientId_other]= score;//记录下标 和最低得分
                                      poseGraph_other->relative_r_mainToOther[clientId_main]=R_main2other;
                                      poseGraph_other->relative_t_mainToOther[clientId_main]=T_main2other;
                                      poseGraph_other->refine_path_mutex.unlock();
                                      
                                      poseGraph_main->fusion_poseGraph_mutex.lock();
                                      poseGraph_main->fusion_otherGraph[clientId_other]=poseGraph_other;//记录副地图
                                      poseGraph_main->fusion_poseGraph_mutex.unlock();
                                      
                                      poseGraph_other->fusion_poseGraph_mutex.lock();
                                      poseGraph_other->fusion_otherGraph[clientId_main]=poseGraph_main;//记录副地图
                                      poseGraph_other->fusion_poseGraph_mutex.unlock();
                                      
                                  }

                                  //加锁
                                   poseGraph_other->isFirstFusion_globalMutex.lock();
                                  //2号帧在1号地图的位姿 前面算过了
                                  f_manager_server_main.feature.clear();
            //                      int clientId_cur=iter_kf_other->c->id;
                                  
                                  if(!isAdd_otherClientId){
                                      r_w2_w1_allClient[clientId_other]=R_relative_best.cast<double>();
                                      t_w2_w1_allClient[clientId_other]=T_relative_best.cast<double>();
                                  }
            //
                                  r_w2_w1_allClient_cur[clientId_other]=R_relative_best.cast<double>();
                                  t_w2_w1_allClient_cur[clientId_other]=T_relative_best.cast<double>();
                                  
                                  
                                  
                                  cur_globalFuse_index[clientId_other]=std::make_pair(old_index, iter_kf_other->global_index);
                                  
                                  if(isFirstFusion[clientId_other]==0)
                                      isFirstFusion[clientId_other]=4;
                                  else if(isFirstFusion[clientId_other]==3)
                                      isFirstFusion[clientId_other]=6;
                                  else
                                      isFirstFusion[clientId_other]=5;
                                  old_kf->relative_r_server.push_back(R_relative_best);
                                  old_kf->relative_t_server.push_back(T_relative_best);
                                  poseGraph_other->isFirstFusion_globalMutex.unlock();
                                  cout<<"地图融合成功"<<endl;
                                  usleep(1000);

                          }
                          else{
                              cout<<"地图融合失败"<<endl;
                          }
                     }
                                 
                }
            }
        }
    
    }
//    poseGraphGlobal_mutex.unlock();
    readWriteLock.readUnLock();
   
 
    usleep(50);

    //实验用 判断程序结束没
   if(poseGraph_main->isEnd==false){
       isEnd=false;
   }
    
    if(isEnd&&oneEnd){
        oneEnd=false;
        //记录位姿
        
        //此处是连接断开处，休眠3s，等回环检测和全局优化处理完
            usleep(3000);
            std::ofstream outFile;
            string path= "/Users/zhangjianhua/Desktop/VINS_MapFusion/VINS_MapFusion/data/pose_end.txt";
            
//        poseGraphGlobal_mutex.lock();
        readWriteLock.readLock();
        for(auto iter_start_record=PoseGraphGloabl_map.begin(),iter_end_record=PoseGraphGloabl_map.end();iter_start_record!=iter_end_record;iter_start_record++){
            PoseGraph* poseGraph_all=iter_start_record->second;
            //refine_path_draw_mutex
            unique_lock<mutex> lock_5(poseGraph_all->refine_path_draw_mutex);
            vector<Vector3f> refine_path_test=poseGraph_all->refine_path_draw;
            lock_5.unlock();
            
            unique_lock<mutex> lock_6(poseGraph_all->mMutexkeyFrameList);
            vector<double> path_time_test=poseGraph_all->path_time;//实验用
            vector<Matrix3f> refine_r_test=poseGraph_all->refine_path_r_draw;//实验用
            lock_6.unlock();
            
            Quaternion<float> Q;
            int len=refine_r_test.size();
            for(int i=0;i<len;i++){
                Q=refine_r_test[i];
                outFile.open(path, ios::binary | ios::app | ios::in | ios::out);
                outFile<<fixed <<setprecision(0)<<path_time_test[i]<<" ";
                outFile<<fixed <<setprecision(11)<<refine_path_test[i].x()<<" "<<refine_path_test[i].y()<<" "<<refine_path_test[i].z()<<" "<<Q.x()<<" "<<Q.y()<<" "<<Q.z()<<" "<<Q.w()<<"\n";
                outFile.close();
            }
        }
//        poseGraphGlobal_mutex.unlock();
        readWriteLock.readUnLock();
            printf("record pose end loopClosure12_1");
    }

}

//这个是多机器人同时跑的版本 主地图和其他人做匹配 传过来的是其它地图 这里应该是其它地图去调用
void PoseGraphGlobal::loopClosureRun_global_12_1_2(int clientId_other){
//    poseGraphGlobal_mutex.lock();
    readWriteLock.readLock();
    map<int,PoseGraph*>::iterator iter=PoseGraphGloabl_map.begin();
    int clientId_main=iter->first;
    assert(clientId_main==mainClientID);//验证一下是不是主地图
    PoseGraph* poseGraph_main=iter->second;
    list<KeyFrame*> keyFrameList_main=poseGraph_main->keyFrameList;
   
    //实验用 记录是不是最后的结束部分了
    bool isEnd=true;
        
        // 再加个判断 当前帧是否已经做过回环了 加了
        //其余所有人 都和第一个地图去比较
    
    map<int,PoseGraph*>::iterator iter_map = PoseGraphGloabl_map.find(clientId_other);
    if(iter_map==PoseGraphGloabl_map.end())
    {
//        poseGraphGlobal_mutex.unlock();
        readWriteLock.readUnLock();
        assert(false);//找不到地图是不应该的
        return ;
    }
    PoseGraph* poseGraph_other=iter_map->second;
//    poseGraphGlobal_mutex.unlock();
    readWriteLock.readUnLock();
    list<KeyFrame*> keyFrameList_other=poseGraph_other->keyFrameList;
    
        
        //实验用 判断程序结束没
        if(poseGraph_other->isEnd==false){
            isEnd=false;
        }
        
        if(keyFrameList_main.size()>0){
            KeyFrame* iter_kf_main=poseGraph_main->getLastKeyframe();
            if(iter_kf_main->check_global_loop[clientId_other]==false && iter_kf_main->is_des_end){
                iter_kf_main->check_global_loop[clientId_other]=true;
                isEnd=false;
        
                bool loop_succ=false;
                int old_index=-1;//这个后续要记录住的 我暂时还没记录 记录了
                
                vector<cv::Point2f> cur_pts;
                vector<cv::Point2f> old_pts;
                int min_startDetect_id=0;

                poseGraph_other->isAddKF2Database_mutex.lock();
                loop_succ = startLoopClosure_2(iter_kf_main->keypoints, iter_kf_main->descriptors,  old_pts, cur_pts, old_index,min_startDetect_id,iter_kf_main->global_index, clientId_other, poseGraph_other->demo_global_in_poseGraph, clientId_main);//返回的应该是其它地图的哪一个帧
                poseGraph_other->isAddKF2Database_mutex.unlock();
                
                
                if(loop_succ)
                 {
                     list<KeyFrame*>::iterator cur_kf_iter=poseGraph_other->getKeyframe_iter(old_index);
                      if(cur_kf_iter==poseGraph_other->keyFrameList.end()){
                          assert(false);
                      }
                      KeyFrame* cur_kf=(*cur_kf_iter);
                      if (cur_kf == NULL)
                      {
                          printf("cur loopClosureRun_global NO such %dth frame in keyframe_database\n", old_index);
                          assert(false);
                      }
                      printf("loopClosureRun_global loop succ with %drd image\n", old_index);
                      assert(old_index!=-1);
              
                      Vector3d T_w_i_cur;
                      Matrix3d R_w_i_cur;
                      cur_kf->getPose(T_w_i_cur, R_w_i_cur);
                      //老帧的位姿
                      Matrix3f r_curKF_f_real=R_w_i_cur.cast<float>();
                      Vector3f t_curKF_f_real=T_w_i_cur.cast<float>();
                     
                     
                      std::vector<cv::Point2f> measurements_cur;//像素坐标
                      std::vector<cv::Point2f> measurements_cur_norm;//图像坐标
                      std::vector<int> features_id;
                      //老帧的3D点  新帧的2D点
                      iter_kf_main->findConnectionWithOldFrame_server_old(cur_kf,  measurements_cur, measurements_cur_norm);//找到匹配的特征点
                      //这里本来用的measurements_cur和keypoints_old匹配上的
                      
                      //新帧的位姿
                      Matrix3d r_mainKF;
                      Vector3d t_mainKF;
                      iter_kf_main->getPose( t_mainKF,r_mainKF);
                      Matrix3f r_mainKF_f=r_mainKF.cast<float>();
                      Vector3f t_mainKF_f=t_mainKF.cast<float>();

                      
                      bool isAdd_otherClientId=false;
                      if(poseGraph_main->fusion_relative_isUpdate[clientId_other]!=-2)
                          isAdd_otherClientId=true;
                      
                      //这里可以后面给一个初始值 求出来的是第一个世界坐标系到c2相机坐标系
                      Matrix3f R_relative;
                      Vector3f T_relative;
                      vector<cv::Point3f> pts_3_vector;//这个应该乘以偏移量 这个可能需要记下来 在做全局优化的时候 乘了偏移量了 世界坐标
                      bool is_fusion=iter_kf_main->solveRelativePoseByPnP_2(measurements_cur_norm ,R_relative, T_relative,pts_3_vector,false);
              
                      if(is_fusion){
                          assert(measurements_cur_norm.size()==measurements_cur.size());
                          double fx=cur_kf->c->FOCUS_LENGTH_X_server;
                          double fy=cur_kf->c->FOCUS_LENGTH_Y_server;
                          
                          double cx=cur_kf->c->PX_server;
                          double cy=cur_kf->c->PY_server;
                          //测试 打印一下 未经过任何处理前 重投影误差
                          for(int aa=0, bb=pts_3_vector.size(); aa<bb ;aa++){
                              cv::Point3f p3d=pts_3_vector[aa];
                              cv::Point2f p2d=measurements_cur[aa];
                              
                              Vector3f p3d_eigen;
                              p3d_eigen<<p3d.x, p3d.y, p3d.z;
                              
                              Vector3f p3d_c1=R_relative*p3d_eigen+T_relative;
                              float x_c1=fx*p3d_c1[0]/p3d_c1[2]+cx;
                              float y_c1=fy*p3d_c1[1]/p3d_c1[2]+cy;
                              
//                              cout<<"匹配的两帧 单一一个点的像素坐标差："<<x_c1-p2d.x<<" "<<y_c1-p2d.y<<endl;
                              
                              
                          }
                          
                          
                          Eigen::Vector3f t_w1_ib_test;
                          Eigen::Matrix3f r_w1_ib_test;
                          //思考这里 R——relative是不是代表 第1个世界坐标系到c2相机坐标系
                          cur_kf->cam2Imu(T_relative, R_relative, t_w1_ib_test, r_w1_ib_test);
                          //b的imu坐标系 到 第1个世界坐标系
                          R_relative=r_w1_ib_test;
                          T_relative=t_w1_ib_test;
                          
                          
                          //保存信息 这里保存，暂时没用处，后续应该会删除 有用有用
                          cur_kf->clientId_server.push_back(clientId_main);
                          cur_kf->global_index_server.push_back(iter_kf_main->global_index);
                          
                          //此时 R_relative代表第2个世界坐标系到A点的相机坐标系
                          //B到A imu坐标系的转换
                          Matrix3f R_ia_ib=r_mainKF_f.transpose()*R_relative;
                          Vector3f t_ia_ib=r_mainKF_f.transpose()*(T_relative- t_mainKF_f);
                          
//                          Matrix3f R_w2_ia=r_curKF_f_real*R_ia_ib;
//                          Vector3f t_w2_ia=r_curKF_f_real*t_ia_ib+t_curKF_f_real;
//                          float relative_yaw_validate=Utility::normalizeAngle(Utility::R2ypr_float(r_oldKF_f_real).x()-Utility::R2ypr_float(R_w1_ib).x());
//                          float relative_pitch_validate=Utility::normalizeAngle(Utility::R2ypr_float(r_oldKF_f_real).y()-Utility::R2ypr_float(R_w1_ib).y());
//                          float relative_roll_validate=Utility::normalizeAngle(Utility::R2ypr_float(r_oldKF_f_real).z()-Utility::R2ypr_float(R_w1_ib).z());
                          //2020 8 没有问题
                          float relative_yaw_validate_t=Utility::normalizeAngle(Utility::R2ypr_float(R_ia_ib).x());
                          float relative_pitch_validate_t=Utility::normalizeAngle(Utility::R2ypr_float(R_ia_ib).y());
                          float relative_roll_validate_t=Utility::normalizeAngle(Utility::R2ypr_float(R_ia_ib).z());

                          
                          //这里改一改 改成世界坐标系下 角度相减
                   
                        
                          if(!isAdd_otherClientId){
                              if(!(abs(relative_yaw_validate_t) <= 30.0 && t_ia_ib.norm() <= 20.0)){
                                  cout<<"平移 或yaw变化过大"<<endl;
                                  return;
                              }
                                  
                          }
                          
                       
                              Matrix3f R_main2other;
                              Vector3f T_main2other;
                                               
                              //这里求的是 主地图世界坐标系到2号地图世界坐标系的转换关系
                              R_main2other=r_curKF_f_real*(R_relative.transpose());
                              T_main2other=t_curKF_f_real -R_main2other*T_relative;
                               
                                  
                              //这里待改
                              //这个是2号帧在1号地图的位姿
                              Matrix3f R_relative_2_in_1_w_i=R_relative;
                              Vector3f t_relative_2_in_1_w_i=T_relative;
                              //这里得到的是根据重投影误差的值 越小越好
                              //新帧的3D 世界坐标， 老帧的2D 图像坐标
       
                               //测试 后续可删除
                                                                  
//                               cout<<"新帧在主地图的位姿"<<iter_kf_main->global_index<<endl;
                               
                          //ib 到w1
                               Matrix3f  r_curKF_f_bInMain=R_main2other.transpose()*r_curKF_f_real;
                               Vector3f t_curKF_f_bInMain=R_main2other.transpose()*(t_curKF_f_real-T_main2other);
                               
                            


        //                                     float relative_yaw_validate=Utility::normalizeAngle(Utility::R2ypr_float(r_curKF_f_cout).x() - Utility::R2ypr_float(r_oldKF_f_real).x());
//                               cout<<"test relative_yaw_validate == t_relative.x"<<Utility::R2ypr_float(r_curKF_f_bInMain.transpose()).x() - Utility::R2ypr_float(r_curKF_f_real.transpose()).x()<<" "<<Utility::R2ypr_float(r_curKF_f_bInMain.transpose()).x()<<" "<<Utility::R2ypr_float(r_curKF_f_real.transpose()).x()<<endl;
                              
                                 Matrix3f R_relative_best=R_main2other;
                                 Vector3f T_relative_best=T_main2other;
                              
                              //这里表示 该地图第一次与主地图发生融合
                              if(!isAdd_otherClientId){
                                 
                                  
                                  
                                  poseGraph_other->refine_path_mutex.lock();
                                 
                                  //把融合地图的位姿转到主地图 保存到refine_path_draw
                                  poseGraph_main->relative_r_mainToOther[clientId_other]=R_main2other;//记录相对位姿
                                  poseGraph_main->relative_t_mainToOther[clientId_other]=T_main2other;
                                  poseGraph_other->relative_r_mainToOther[clientId_main]=R_main2other;
                                  poseGraph_other->relative_t_mainToOther[clientId_main]=T_main2other;
                                  poseGraph_other->refine_path_mutex.unlock();
                                  
                                  poseGraph_main->fusion_poseGraph_mutex.lock();
                                  poseGraph_main->fusion_otherGraph[clientId_other]=poseGraph_other;//记录副地图
                                  poseGraph_main->fusion_poseGraph_mutex.unlock();
                                  
                                  poseGraph_other->fusion_poseGraph_mutex.lock();
                                  poseGraph_other->fusion_otherGraph[clientId_main]=poseGraph_main;//记录副地图
                                  poseGraph_other->fusion_poseGraph_mutex.unlock();
                                  
                              }

                              //加锁
                               poseGraph_other->isFirstFusion_globalMutex.lock();
                              //2号帧在1号地图的位姿 前面算过了
//                              f_manager_server_main.feature.clear();
        //                      int clientId_cur=iter_kf_other->c->id;
                              
                              if(!isAdd_otherClientId){
                                  r_w2_w1_allClient[clientId_other]=R_relative_best.cast<double>();
                                  t_w2_w1_allClient[clientId_other]=T_relative_best.cast<double>();
                              }
        //
                              r_w2_w1_allClient_cur[clientId_other]=R_relative_best.cast<double>();
                              t_w2_w1_allClient_cur[clientId_other]=T_relative_best.cast<double>();
                              
                              
                              
                              cur_globalFuse_index[clientId_other]=std::make_pair(iter_kf_main->global_index, old_index);
                              
                              if(isFirstFusion[clientId_other]==0)
                                  isFirstFusion[clientId_other]=4;
                              else if(isFirstFusion[clientId_other]==3)
                                  isFirstFusion[clientId_other]=6;
                              else
                                  isFirstFusion[clientId_other]=5;
                              cur_kf->relative_r_server.push_back(R_relative_best);
                              cur_kf->relative_t_server.push_back(T_relative_best);
                              poseGraph_other->isFirstFusion_globalMutex.unlock();
                              cout<<"地图融合成功"<<endl;
                              usleep(1000);

                      }
                        else{
                            cout<<"地图融合失败"<<endl;
                        }
                    }
                     
            }
        }
    
    
//   cout<<"PoseGraphGlobal 2592"<<endl;
 
//    usleep(50);

    //实验用 判断程序结束没
   if(poseGraph_main->isEnd==false){
       isEnd=false;
   }
    
    if(isEnd&&oneEnd){
        oneEnd=false;
        //记录位姿
        
        //此处是连接断开处，休眠3s，等回环检测和全局优化处理完
            usleep(3000);
            std::ofstream outFile;
            string path= "/Users/zhangjianhua/Desktop/VINS_MapFusion/VINS_MapFusion/data/pose_end.txt";
//        poseGraphGlobal_mutex.lock();
        readWriteLock.readLock();
        for(auto iter_start_record=PoseGraphGloabl_map.begin(),iter_end_record=PoseGraphGloabl_map.end();iter_start_record!=iter_end_record;iter_start_record++){
            PoseGraph* poseGraph_all=iter_start_record->second;
            //refine_path_draw_mutex
            unique_lock<mutex> lock_5(poseGraph_all->refine_path_draw_mutex);
            vector<Vector3f> refine_path_test=poseGraph_all->refine_path_draw;
            lock_5.unlock();
            
            unique_lock<mutex> lock_6(poseGraph_all->mMutexkeyFrameList);
            vector<double> path_time_test=poseGraph_all->path_time;//实验用
            vector<Matrix3f> refine_r_test=poseGraph_all->refine_path_r_draw;//实验用
            lock_6.unlock();
            
            Quaternion<float> Q;
            int len=refine_r_test.size();
            for(int i=0;i<len;i++){
                Q=refine_r_test[i];
                outFile.open(path, ios::binary | ios::app | ios::in | ios::out);
                outFile<<fixed <<setprecision(0)<<path_time_test[i]<<" ";
                outFile<<fixed <<setprecision(11)<<refine_path_test[i].x()<<" "<<refine_path_test[i].y()<<" "<<refine_path_test[i].z()<<" "<<Q.x()<<" "<<Q.y()<<" "<<Q.z()<<" "<<Q.w()<<"\n";
                outFile.close();
            }
        }
//        poseGraphGlobal_mutex.unlock();
        readWriteLock.readUnLock();
            printf("record pose end loopClosure12_1_2");
    }

}


//这里更改存储的不再是两个地图之间的相对位姿 只存储r_c1_w2
//这个是多机器人同时跑的版本 和主地图去匹配 传过来的是主地图 这里应该是主地图去调用
void PoseGraphGlobal::loopClosureRun_global_13_1(int clientId_main){
    
    assert(clientId_main==mainClientID);
//    poseGraphGlobal_mutex.lock();
    readWriteLock.readLock();
    map<int,PoseGraph*>::iterator iter_map = PoseGraphGloabl_map.find(clientId_main);
    if(iter_map==PoseGraphGloabl_map.end())
    {
//        poseGraphGlobal_mutex.unlock();
        readWriteLock.readUnLock();
        assert(false);//找不到地图是不应该的
        return ;
    }
    PoseGraph* poseGraph_main=iter_map->second;
//    poseGraphGlobal_mutex.unlock();
    readWriteLock.readUnLock();
    list<KeyFrame*> keyFrameList_main=poseGraph_main->keyFrameList;
   
    //实验用 记录是不是最后的结束部分了
    bool isEnd=true;
     
     //拿其它所有地图和主地图去做比较
    for(auto iter_end=PoseGraphGloabl_map.end();--iter_end , iter_map!=iter_end;){
        PoseGraph* poseGraph_other=iter_end->second;
        int clientId_other=iter_end->first;
        list<KeyFrame*> keyFrameList_other=poseGraph_other->keyFrameList;
         
        if(clientId_other!=clientId_main){
            //实验用 判断程序结束没
            if(poseGraph_other->isEnd==false){
                isEnd=false;
            }
                
            if(keyFrameList_other.size()>0){
                KeyFrame* iter_kf_other=poseGraph_other->getLastKeyframe();
                if(iter_kf_other->check_global_loop[clientId_main]==false && iter_kf_other->is_des_end){
                    iter_kf_other->check_global_loop[clientId_main]=true;
                    isEnd=false;
            
                    bool loop_succ=false;
                    int old_index=-1;//这个后续要记录住的 我暂时还没记录 记录了
                    vector<cv::Point2f> cur_pts;
                    vector<cv::Point2f> old_pts;
                    int min_startDetect_id=0;
                    
                    poseGraph_main->isAddKF2Database_mutex.lock();
                    loop_succ = startLoopClosure_2(iter_kf_other->keypoints, iter_kf_other->descriptors, cur_pts, old_pts, old_index,min_startDetect_id,iter_kf_other->global_index, mainClientID, poseGraph_main->demo_global_in_poseGraph, clientId_other);//返回的应该是0号地图的哪一个帧
                    poseGraph_main->isAddKF2Database_mutex.unlock();
                    
                    
                    if(loop_succ)
                     {
                         list<KeyFrame*>::iterator main_kf_iter=poseGraph_main->getKeyframe_iter(old_index);
                          if(main_kf_iter==poseGraph_main->keyFrameList.end()){
                              assert(false);
                          }
                          KeyFrame* old_kf=(*main_kf_iter);
                          if (old_kf == NULL)
                          {
                              printf("loopClosureRun_global NO such %dth frame in keyframe_database\n", old_index);
                              assert(false);
                          }
                          printf("loopClosureRun_global loop succ with %drd image\n", old_index);
                          assert(old_index!=-1);
                          
                          
                         
                          std::vector<cv::Point2f> measurements_old;//像素坐标
                          std::vector<cv::Point2f> measurements_old_norm;//图像坐标
                          std::vector<int> features_id;
                          
                          //新帧的3D点 老帧的2D点(主地图)
                          iter_kf_other-> findConnectionWithOldFrame_server_old(old_kf,measurements_old, measurements_old_norm);//找到匹配的特征点
                          //这里本来用的measurements_cur和keypoints_old匹配上的
                          

                          //这里可以后面给一个初始值
                          Matrix3f R_relative;
                          Vector3f T_relative;
                          
                          //新帧的位姿
                          Matrix3d r_curKF;
                          Vector3d t_curKF;
                          iter_kf_other->getPose( t_curKF,r_curKF);
                          Matrix3f r_curKF_f=r_curKF.cast<float>();
                          Vector3f t_curKF_f=t_curKF.cast<float>();

                          //老帧的位姿
                         Vector3d T_w_i_old;
                         Matrix3d R_w_i_old;
                         old_kf->getPose(T_w_i_old, R_w_i_old);
                          Matrix3f r_oldKF_f_real=R_w_i_old.cast<float>();
                          Vector3f t_oldKF_f_real=T_w_i_old.cast<float>();
                          
                          bool isAdd_otherClientId=false;
                          if(poseGraph_main->fusion_relative_isUpdate[clientId_other]!=-2)
                              isAdd_otherClientId=true;
                          

                          
                          
                          vector<cv::Point3f> pts_3_vector;//这个应该乘以偏移量 这个可能需要记下来 在做全局优化的时候 乘了偏移量了 世界坐标
            //                             bool is_fusion=(*iter_kf_other)->solveRelativePoseByPnP(measurements_old_norm ,R_relative, T_relative,pts_3_vector,isAdd_otherClientId);//这个算出来的是 新帧 -> 旧帧 位姿变化
                          bool is_fusion=iter_kf_other->solveRelativePoseByPnP_2(measurements_old_norm ,R_relative, T_relative,pts_3_vector,false);
                          
                          if(is_fusion){

//                              assert(measurements_old_norm.size()==measurements_old.size());
//                              double fx=old_kf->c->FOCUS_LENGTH_X_server;
//                              double fy=old_kf->c->FOCUS_LENGTH_Y_server;
//
//                              double cx=old_kf->c->PX_server;
//                              double cy=old_kf->c->PY_server;
//                              //测试 打印一下 未经过任何处理前 重投影误差
//                              for(int aa=0, bb=pts_3_vector.size(); aa<bb ;aa++){
//                                  cv::Point3f p3d=pts_3_vector[aa];
//                                  cv::Point2f p2d=measurements_old[aa];
//
//                                  Vector3f p3d_eigen;
//                                  p3d_eigen<<p3d.x, p3d.y, p3d.z;
//
//                                  Vector3f p3d_c1=R_relative*p3d_eigen+T_relative;
//                                  float x_c1=fx*p3d_c1[0]/p3d_c1[2]+cx;
//                                  float y_c1=fy*p3d_c1[1]/p3d_c1[2]+cy;
//
////                                  cout<<"匹配的两帧 单一一个点的像素坐标差："<<x_c1-p2d.x<<" "<<y_c1-p2d.y<<endl;
//                              }
                              
                              
                              
                              
                              r_ca_w2_cur[clientId_other]=R_relative;
                              t_ca_w2_cur[clientId_other]=T_relative;
                              
                              
                              
                              Eigen::Vector3f t_w2_ia_test;
                              Eigen::Matrix3f r_w2_ia_test;
                              //思考这里 R——relative是不是代表 第2个世界坐标系到c1相机坐标系
                              old_kf->cam2Imu(T_relative, R_relative, t_w2_ia_test, r_w2_ia_test);
                              //a的imu坐标系 到 第2个世界坐标系
                              R_relative=r_w2_ia_test;
                              T_relative=t_w2_ia_test;
                              
                              
                              //保存信息 这里保存，暂时没用处，后续应该会删除 有用有用
                              old_kf->clientId_server.push_back(clientId_other);
                              old_kf->global_index_server.push_back(iter_kf_other->global_index);
                              
                              //此时 R_relative代表第2个世界坐标系到A点的相机坐标系
                              //B到A imu坐标系的转换
                              Matrix3f R_ia_ib=R_relative.transpose()*r_curKF_f;
                              Vector3f t_ia_ib=R_relative.transpose()*(t_curKF_f-T_relative);
                              
//                              Matrix3f R_w1_ib=r_oldKF_f_real*R_ia_ib;
//                              Vector3f t_w1_ib=r_oldKF_f_real*t_ia_ib+t_oldKF_f_real;
//                              float relative_yaw_validate=Utility::normalizeAngle(Utility::R2ypr_float(r_oldKF_f_real).x()-Utility::R2ypr_float(R_w1_ib).x());
//                              float relative_pitch_validate=Utility::normalizeAngle(Utility::R2ypr_float(r_oldKF_f_real).y()-Utility::R2ypr_float(R_w1_ib).y());
//                              float relative_roll_validate=Utility::normalizeAngle(Utility::R2ypr_float(r_oldKF_f_real).z()-Utility::R2ypr_float(R_w1_ib).z());
                              //2020 8 没有问题
                              float relative_yaw_validate_t=Utility::normalizeAngle(Utility::R2ypr_float(R_ia_ib).x());
                              float relative_pitch_validate_t=Utility::normalizeAngle(Utility::R2ypr_float(R_ia_ib).y());
                              float relative_roll_validate_t=Utility::normalizeAngle(Utility::R2ypr_float(R_ia_ib).z());

                              
                              //这里改一改 改成世界坐标系下 角度相减
                              
                              
//                              cout<<"relative_yaw_validate "<<relative_yaw_validate<<" "<<relative_yaw_validate_t<<endl;
//                              cout<<"relative_pitch_validate "<<relative_pitch_validate<<" "<<relative_pitch_validate_t<<endl;
//                              cout<<"relative_roll_validate "<<relative_roll_validate<<" "<<relative_roll_validate_t<<endl;
                              
                            
                              if(!isAdd_otherClientId){
                                  if(!(abs(relative_yaw_validate_t) <= 30.0 && t_ia_ib.norm() <= 20.0)){
                                      cout<<"平移 或yaw变化过大"<<endl;
//                                      return;
                                      continue;
                                  }
                                      
                              }
                              
                              feature_id_cur[clientId_other]=iter_kf_other->features_id;
                              measurements_norm_main[clientId_other]=measurements_old_norm;
                              
                              //&&abs(relative_pitch_validate_t)<=30.0 &&abs(relative_roll_validate_t)<=30.0
            //                  if(abs(relative_yaw_validate_t)<= 30.0){
                              
                              //验证是否是正确的回环 即yaw变化不超过30，relative不超过10
                              
            //                  if (t_ia_ib.norm() <= 20.0){

            //
                                  Matrix3f R_main2other;
                                  Vector3f T_main2other;
                                                   
                                  //这里求的是 主地图世界坐标系到2号地图世界坐标系的转换关系
                                  R_main2other=R_relative*(r_oldKF_f_real.transpose());
                                  T_main2other=T_relative-R_main2other*t_oldKF_f_real;
                                   
                                      
                                  //这里待改
                                  //这个是1号帧在2号地图的位姿
                                  Matrix3f R_relative_1_in_2_w_i=R_relative;
                                  Vector3f t_relative_1_in_2_w_i=T_relative;
                                 
                                   
                                   Matrix3f  r_curKF_f_bInMain=R_main2other.transpose()*r_curKF_f;
                                   Vector3f t_curKF_f_bInMain=R_main2other.transpose()*(t_curKF_f-T_main2other);
                                   
                                
                                  
                                     Matrix3f R_relative_best=R_main2other;
                                     Vector3f T_relative_best=T_main2other;
                                  
                                  //这里表示 该地图第一次与主地图发生融合
                                  if(!isAdd_otherClientId){
                                     
                                      
                                      
                                      poseGraph_other->refine_path_mutex.lock();
                                     
                                      //把融合地图的位姿转到主地图 保存到refine_path_draw
                                      poseGraph_main->relative_r_mainToOther[clientId_other]=R_main2other;//记录相对位姿
                                      poseGraph_main->relative_t_mainToOther[clientId_other]=T_main2other;
            //                          poseGraph_main->relative_score_min[clientId_other]= score;//记录下标 和最低得分
                                      poseGraph_other->relative_r_mainToOther[clientId_main]=R_main2other;
                                      poseGraph_other->relative_t_mainToOther[clientId_main]=T_main2other;
                                      poseGraph_other->refine_path_mutex.unlock();
                                      
                                      poseGraph_main->fusion_poseGraph_mutex.lock();
                                      poseGraph_main->fusion_otherGraph[clientId_other]=poseGraph_other;//记录副地图
                                      poseGraph_main->fusion_poseGraph_mutex.unlock();
                                      
                                      poseGraph_other->fusion_poseGraph_mutex.lock();
                                      poseGraph_other->fusion_otherGraph[clientId_main]=poseGraph_main;//记录副地图
                                      poseGraph_other->fusion_poseGraph_mutex.unlock();
                                      
                                  }

                                  //加锁
                                   poseGraph_other->isFirstFusion_globalMutex.lock();
                                  //2号帧在1号地图的位姿 前面算过了
                                  f_manager_server_main.feature.clear();
            //                      int clientId_cur=iter_kf_other->c->id;
                                  
                                  if(!isAdd_otherClientId){
                                      r_w2_w1_allClient[clientId_other]=R_relative_best.cast<double>();
                                      t_w2_w1_allClient[clientId_other]=T_relative_best.cast<double>();
                                  }
            //
                                  r_w2_w1_allClient_cur[clientId_other]=R_relative_best.cast<double>();
                                  t_w2_w1_allClient_cur[clientId_other]=T_relative_best.cast<double>();
                                  
                                  
                                  
                                  cur_globalFuse_index[clientId_other]=std::make_pair(old_index, iter_kf_other->global_index);
                                  
                                  if(isFirstFusion[clientId_other]==0)
                                      isFirstFusion[clientId_other]=4;
                                  else if(isFirstFusion[clientId_other]==3)
                                      isFirstFusion[clientId_other]=6;
                                  else
                                      isFirstFusion[clientId_other]=5;
                                  old_kf->relative_r_server.push_back(R_relative_best);
                                  old_kf->relative_t_server.push_back(T_relative_best);
                                  poseGraph_other->isFirstFusion_globalMutex.unlock();
                                  cout<<"地图融合成功"<<endl;
                                  usleep(1000);

                          }
                          else{
                              cout<<"地图融合失败"<<endl;
                          }
                     }
                                 
                }
            }
        }
    
    }
    
   
 
    usleep(50);

    //实验用 判断程序结束没
   if(poseGraph_main->isEnd==false){
       isEnd=false;
   }
    
    if(isEnd&&oneEnd){
        oneEnd=false;
        //记录位姿
        
        //此处是连接断开处，休眠3s，等回环检测和全局优化处理完
            usleep(3000);
            std::ofstream outFile;
            string path= "/Users/zhangjianhua/Desktop/VINS_MapFusion/VINS_MapFusion/data/pose_end.txt";
//        poseGraphGlobal_mutex.lock();
        readWriteLock.readLock();
        for(auto iter_start_record=PoseGraphGloabl_map.begin(),iter_end_record=PoseGraphGloabl_map.end();iter_start_record!=iter_end_record;iter_start_record++){
            PoseGraph* poseGraph_all=iter_start_record->second;
            //refine_path_draw_mutex
            unique_lock<mutex> lock_5(poseGraph_all->refine_path_draw_mutex);
            vector<Vector3f> refine_path_test=poseGraph_all->refine_path_draw;
            lock_5.unlock();
            
            unique_lock<mutex> lock_6(poseGraph_all->mMutexkeyFrameList);
            vector<double> path_time_test=poseGraph_all->path_time;//实验用
            vector<Matrix3f> refine_r_test=poseGraph_all->refine_path_r_draw;//实验用
            lock_6.unlock();
            
            Quaternion<float> Q;
            int len=refine_r_test.size();
            for(int i=0;i<len;i++){
                Q=refine_r_test[i];
                outFile.open(path, ios::binary | ios::app | ios::in | ios::out);
                outFile<<fixed <<setprecision(0)<<path_time_test[i]<<" ";
                outFile<<fixed <<setprecision(11)<<refine_path_test[i].x()<<" "<<refine_path_test[i].y()<<" "<<refine_path_test[i].z()<<" "<<Q.x()<<" "<<Q.y()<<" "<<Q.z()<<" "<<Q.w()<<"\n";
                outFile.close();
            }
        }
//        poseGraphGlobal_mutex.unlock();
        readWriteLock.readUnLock();
            printf("record pose end loopClosure13_1");
    }

}

//这个是多机器人同时跑的版本 主地图和其他人做匹配 传过来的是其它地图 这里应该是其它地图去调用
void PoseGraphGlobal::loopClosureRun_global_13_1_2(int clientId_other){
//    poseGraphGlobal_mutex.lock();
    readWriteLock.readLock();
    map<int,PoseGraph*>::iterator iter=PoseGraphGloabl_map.begin();
    int clientId_main=iter->first;
    assert(clientId_main==mainClientID);//验证一下是不是主地图
    PoseGraph* poseGraph_main=iter->second;
    list<KeyFrame*> keyFrameList_main=poseGraph_main->keyFrameList;
   
    //实验用 记录是不是最后的结束部分了
    bool isEnd=true;
        
        // 再加个判断 当前帧是否已经做过回环了 加了
        //其余所有人 都和第一个地图去比较
   
    map<int,PoseGraph*>::iterator iter_map = PoseGraphGloabl_map.find(clientId_other);
    if(iter_map==PoseGraphGloabl_map.end())
    {
//        poseGraphGlobal_mutex.unlock();
        readWriteLock.readUnLock();
        assert(false);//找不到地图是不应该的
        return ;
    }
    PoseGraph* poseGraph_other=iter_map->second;
//    poseGraphGlobal_mutex.unlock();
    readWriteLock.readUnLock();
    list<KeyFrame*> keyFrameList_other=poseGraph_other->keyFrameList;
    
        
        //实验用 判断程序结束没
        if(poseGraph_other->isEnd==false){
            isEnd=false;
        }
        
        if(keyFrameList_main.size()>0){
            KeyFrame* iter_kf_main=poseGraph_main->getLastKeyframe();
            if(iter_kf_main->check_global_loop[clientId_other]==false && iter_kf_main->is_des_end){
                iter_kf_main->check_global_loop[clientId_other]=true;
                isEnd=false;
        
                bool loop_succ=false;
                int old_index=-1;//这个后续要记录住的 我暂时还没记录 记录了
                
                vector<cv::Point2f> cur_pts;
                vector<cv::Point2f> old_pts;
                int min_startDetect_id=0;

                poseGraph_other->isAddKF2Database_mutex.lock();
                loop_succ = startLoopClosure_2(iter_kf_main->keypoints, iter_kf_main->descriptors,  old_pts, cur_pts, old_index,min_startDetect_id,iter_kf_main->global_index, clientId_other, poseGraph_other->demo_global_in_poseGraph, clientId_main);//返回的应该是其它地图的哪一个帧
                poseGraph_other->isAddKF2Database_mutex.unlock();
                
                
                if(loop_succ)
                 {
                     list<KeyFrame*>::iterator cur_kf_iter=poseGraph_other->getKeyframe_iter(old_index);
                      if(cur_kf_iter==poseGraph_other->keyFrameList.end()){
                          assert(false);
                      }
                      KeyFrame* cur_kf=(*cur_kf_iter);
                      if (cur_kf == NULL)
                      {
                          printf("cur loopClosureRun_global NO such %dth frame in keyframe_database\n", old_index);
                          assert(false);
                      }
                      printf("loopClosureRun_global loop succ with %drd image\n", old_index);
                      assert(old_index!=-1);
              
                      Vector3d T_w_i_cur;
                      Matrix3d R_w_i_cur;
                      cur_kf->getPose(T_w_i_cur, R_w_i_cur);
                      //新帧的位姿
                      Matrix3f r_curKF_f_real=R_w_i_cur.cast<float>();
                      Vector3f t_curKF_f_real=T_w_i_cur.cast<float>();
                     
                     
                      std::vector<cv::Point2f> measurements_old;//像素坐标
                      std::vector<cv::Point2f> measurements_old_norm;//图像坐标
                      std::vector<int> features_id;
                      
                     //改成新帧的3D点 老帧的2D点
                      cur_kf->findConnectionWithOldFrame_server_old(iter_kf_main, measurements_old, measurements_old_norm);//找到匹配的特征点
                      //这里本来用的measurements_cur和keypoints_old匹配上的
                     
                     
                     //因为要统一成 拿新帧的去处理 检索匹配点，所以必须新帧调用
                     
                      
                      //老帧的位姿
                      Matrix3d r_mainKF;
                      Vector3d t_mainKF;
                      iter_kf_main->getPose( t_mainKF,r_mainKF);
                      Matrix3f r_mainKF_f=r_mainKF.cast<float>();
                      Vector3f t_mainKF_f=t_mainKF.cast<float>();

                      
                      bool isAdd_otherClientId=false;
                      if(poseGraph_main->fusion_relative_isUpdate[clientId_other]!=-2)
                          isAdd_otherClientId=true;
                      
                      //这里可以后面给一个初始值 求出来的是第一个世界坐标系到c2相机坐标系
                      Matrix3f R_relative;
                      Vector3f T_relative;
                      vector<cv::Point3f> pts_3_vector;//这个应该乘以偏移量 这个可能需要记下来 在做全局优化的时候 乘了偏移量了 世界坐标
                      bool is_fusion=cur_kf->solveRelativePoseByPnP_2(measurements_old_norm ,R_relative, T_relative,pts_3_vector,false);
              
                      if(is_fusion){
//                          assert(measurements_old_norm.size()==measurements_old.size());
//                          double fx=iter_kf_main->c->FOCUS_LENGTH_X_server;
//                          double fy=iter_kf_main->c->FOCUS_LENGTH_Y_server;
//
//                          double cx=iter_kf_main->c->PX_server;
//                          double cy=iter_kf_main->c->PY_server;
//                          //测试 打印一下 未经过任何处理前 重投影误差
//                          for(int aa=0, bb=pts_3_vector.size(); aa<bb ;aa++){
//                              cv::Point3f p3d=pts_3_vector[aa];
//                              cv::Point2f p2d=measurements_old[aa];
//
//                              Vector3f p3d_eigen;
//                              p3d_eigen<<p3d.x, p3d.y, p3d.z;
//
//                              Vector3f p3d_c1=R_relative*p3d_eigen+T_relative;
//                              float x_c1=fx*p3d_c1[0]/p3d_c1[2]+cx;
//                              float y_c1=fy*p3d_c1[1]/p3d_c1[2]+cy;
//
////                              cout<<"匹配的两帧 单一一个点的像素坐标差："<<x_c1-p2d.x<<" "<<y_c1-p2d.y<<endl;
//                          }
                          
                          r_ca_w2_cur[clientId_other]=R_relative;
                          t_ca_w2_cur[clientId_other]=T_relative;
                          
                          
                          Eigen::Vector3f t_w2_ia_test;
                          Eigen::Matrix3f r_w2_ia_test;
                          //思考这里 R——relative是不是代表 第1个世界坐标系到c2相机坐标系
                          iter_kf_main->cam2Imu(T_relative, R_relative, t_w2_ia_test, r_w2_ia_test);
                          //a的imu坐标系 到 第2个世界坐标系
                          R_relative=r_w2_ia_test;
                          T_relative=t_w2_ia_test;
                          
                          
                          //保存信息 这里保存，暂时没用处，后续应该会删除 有用有用
                          cur_kf->clientId_server.push_back(clientId_main);
                          cur_kf->global_index_server.push_back(iter_kf_main->global_index);
                          
                          //此时 R_relative代表第2个世界坐标系到A点的相机坐标系
                          //B到A imu坐标系的转换
//                          Matrix3f R_ia_ib=r_mainKF_f.transpose()*R_relative;
//                          Vector3f t_ia_ib=r_mainKF_f.transpose()*(T_relative- t_mainKF_f);
                        //B到A imu坐标系的转换
                        Matrix3f R_ia_ib=R_relative.transpose()*r_curKF_f_real;
                        Vector3f t_ia_ib=R_relative.transpose()*(t_curKF_f_real-T_relative);
                          
                          //2020 8 没有问题
                          float relative_yaw_validate_t=Utility::normalizeAngle(Utility::R2ypr_float(R_ia_ib).x());
                          float relative_pitch_validate_t=Utility::normalizeAngle(Utility::R2ypr_float(R_ia_ib).y());
                          float relative_roll_validate_t=Utility::normalizeAngle(Utility::R2ypr_float(R_ia_ib).z());

                          
                          //这里改一改 改成世界坐标系下 角度相减
                   
                        
                          if(!isAdd_otherClientId){
                              if(!(abs(relative_yaw_validate_t) <= 30.0 && t_ia_ib.norm() <= 20.0)){
                                  cout<<"平移 或yaw变化过大"<<endl;
                                  return;
                              }
                                  
                          }
                          
                       
                              Matrix3f R_main2other;
                              Vector3f T_main2other;
                                               
                              //这里求的是 主地图世界坐标系到2号地图世界坐标系的转换关系
                              R_main2other=r_curKF_f_real*(R_relative.transpose());
                              T_main2other=t_curKF_f_real -R_main2other*T_relative;
                               
                                  
                              //这里待改
                              //这个是2号帧在1号地图的位姿
                              Matrix3f R_relative_2_in_1_w_i=R_relative;
                              Vector3f t_relative_2_in_1_w_i=T_relative;
                              //这里得到的是根据重投影误差的值 越小越好
                              //新帧的3D 世界坐标， 老帧的2D 图像坐标
       
                               //测试 后续可删除
                                                                  
//                               cout<<"新帧在主地图的位姿"<<iter_kf_main->global_index<<endl;
                               
                          //ib 到w1
                               Matrix3f  r_curKF_f_bInMain=R_main2other.transpose()*r_curKF_f_real;
                               Vector3f t_curKF_f_bInMain=R_main2other.transpose()*(t_curKF_f_real-T_main2other);
                               
                            
                              
                                 Matrix3f R_relative_best=R_main2other;
                                 Vector3f T_relative_best=T_main2other;
                              
                              //这里表示 该地图第一次与主地图发生融合
                              if(!isAdd_otherClientId){
                                 
                                  
                                  
                                  poseGraph_other->refine_path_mutex.lock();
                                 
                                  //把融合地图的位姿转到主地图 保存到refine_path_draw
                                  poseGraph_main->relative_r_mainToOther[clientId_other]=R_main2other;//记录相对位姿
                                  poseGraph_main->relative_t_mainToOther[clientId_other]=T_main2other;
                                  poseGraph_other->relative_r_mainToOther[clientId_main]=R_main2other;
                                  poseGraph_other->relative_t_mainToOther[clientId_main]=T_main2other;
                                  poseGraph_other->refine_path_mutex.unlock();
                                  
                                  poseGraph_main->fusion_poseGraph_mutex.lock();
                                  poseGraph_main->fusion_otherGraph[clientId_other]=poseGraph_other;//记录副地图
                                  poseGraph_main->fusion_poseGraph_mutex.unlock();
                                  
                                  poseGraph_other->fusion_poseGraph_mutex.lock();
                                  poseGraph_other->fusion_otherGraph[clientId_main]=poseGraph_main;//记录副地图
                                  poseGraph_other->fusion_poseGraph_mutex.unlock();
                                  
                              }

                              //加锁
                               poseGraph_other->isFirstFusion_globalMutex.lock();
                              //2号帧在1号地图的位姿 前面算过了
//                              f_manager_server_main.feature.clear();
        //                      int clientId_cur=iter_kf_other->c->id;
                              
                              if(!isAdd_otherClientId){
                                  r_w2_w1_allClient[clientId_other]=R_relative_best.cast<double>();
                                  t_w2_w1_allClient[clientId_other]=T_relative_best.cast<double>();
                              }
        //
                              r_w2_w1_allClient_cur[clientId_other]=R_relative_best.cast<double>();
                              t_w2_w1_allClient_cur[clientId_other]=T_relative_best.cast<double>();
                              
                              
                              
                              cur_globalFuse_index[clientId_other]=std::make_pair(iter_kf_main->global_index, old_index);
                              
                              if(isFirstFusion[clientId_other]==0)
                                  isFirstFusion[clientId_other]=4;
                              else if(isFirstFusion[clientId_other]==3)
                                  isFirstFusion[clientId_other]=6;
                              else
                                  isFirstFusion[clientId_other]=5;
                              cur_kf->relative_r_server.push_back(R_relative_best);
                              cur_kf->relative_t_server.push_back(T_relative_best);
                              poseGraph_other->isFirstFusion_globalMutex.unlock();
                              cout<<"地图融合成功"<<endl;
                              usleep(1000);

                      }
                        else{
                            cout<<"地图融合失败"<<endl;
                        }
                    }
                     
            }
        }
    
    
//   cout<<"PoseGraphGlobal 2592"<<endl;
 
//    usleep(50);

    //实验用 判断程序结束没
   if(poseGraph_main->isEnd==false){
       isEnd=false;
   }
    
    if(isEnd&&oneEnd){
        oneEnd=false;
        //记录位姿
        
        //此处是连接断开处，休眠3s，等回环检测和全局优化处理完
            usleep(3000);
            std::ofstream outFile;
            string path= "/Users/zhangjianhua/Desktop/VINS_MapFusion/VINS_MapFusion/data/pose_end.txt";
//        poseGraphGlobal_mutex.lock();
        readWriteLock.readLock();
        for(auto iter_start_record=PoseGraphGloabl_map.begin(),iter_end_record=PoseGraphGloabl_map.end();iter_start_record!=iter_end_record;iter_start_record++){
            PoseGraph* poseGraph_all=iter_start_record->second;
            //refine_path_draw_mutex
            unique_lock<mutex> lock_5(poseGraph_all->refine_path_draw_mutex);
            vector<Vector3f> refine_path_test=poseGraph_all->refine_path_draw;
            lock_5.unlock();
            
            unique_lock<mutex> lock_6(poseGraph_all->mMutexkeyFrameList);
            vector<double> path_time_test=poseGraph_all->path_time;//实验用
            vector<Matrix3f> refine_r_test=poseGraph_all->refine_path_r_draw;//实验用
            lock_6.unlock();
            
            Quaternion<float> Q;
            int len=refine_r_test.size();
            for(int i=0;i<len;i++){
                Q=refine_r_test[i];
                outFile.open(path, ios::binary | ios::app | ios::in | ios::out);
                outFile<<fixed <<setprecision(0)<<path_time_test[i]<<" ";
                outFile<<fixed <<setprecision(11)<<refine_path_test[i].x()<<" "<<refine_path_test[i].y()<<" "<<refine_path_test[i].z()<<" "<<Q.x()<<" "<<Q.y()<<" "<<Q.z()<<" "<<Q.w()<<"\n";
                outFile.close();
            }
        }
//        poseGraphGlobal_mutex.unlock();
        readWriteLock.readUnLock();
            printf("record pose end loopClosure13_1_2");
    }

}


//用回之前的 通过重投影找到匹配点 然后通过两边重投影 算相对位姿 论文实验最后一版
void  PoseGraphGlobal::MergeLocal_14(){
    while(true){
        int len = sizeof(isFirstFusion) / sizeof(isFirstFusion[0]);
//        poseGraphGlobal_mutex.lock();
        readWriteLock.readLock();
        if(PoseGraphGloabl_map.size()>1){
//            poseGraphGlobal_mutex.unlock();
            readWriteLock.readUnLock();
        for(int client_id=1;client_id<len;client_id++){//这里的i其实代表的就是 ClientId
            
//            poseGraphGlobal_mutex.lock();
            readWriteLock.readLock();
            map<int,PoseGraph*>::iterator iter_map = PoseGraphGloabl_map.find(client_id);
            if(iter_map==PoseGraphGloabl_map.end())
            {
//                poseGraphGlobal_mutex.unlock();
                readWriteLock.readUnLock();
                continue;
            }
            PoseGraph* pCurrentMap= iter_map->second;//新的地图 小的地图
            PoseGraph* pMergeMap=PoseGraphGloabl_map[0];//老的地图 主地图 精度更高
//            poseGraphGlobal_mutex.unlock();
            readWriteLock.readUnLock();
            
            pCurrentMap->isFirstFusion_globalMutex.lock();
            if(!(isFirstFusion[client_id]==4 || isFirstFusion[client_id]==5 || isFirstFusion[client_id]==6))
            {
                pCurrentMap->isFirstFusion_globalMutex.unlock();
                continue;
            }
            
            
            vector<cv::Point2f> measurements_old_norm_clone= measurements_norm_main[client_id];
            vector<int> feature_id_cur_clone=feature_id_cur[client_id];
            
            //得到两个匹配的关键帧
            int curKF_global_index=cur_globalFuse_index[client_id].second;
            list<KeyFrame*>::iterator curKF_iter= pCurrentMap->keyFrameList.begin();
            advance(curKF_iter, curKF_global_index);
            KeyFrame* pCurKF;
            if(curKF_global_index<pCurrentMap->keyFrameList.size()){
                pCurKF=(*curKF_iter);
                if(pCurKF->global_index!=curKF_global_index){
                    assert(false);
                }
            }
            else{
                assert(false);
            }
//            setIMUModel(pCurKF->c->FOCUS_LENGTH_X_server);// 该传哪一个fx给重投影误差因子图  这里是其它地图 如果优化是自己求导，要设置的一个权重
            
            int mainKF_global_index=cur_globalFuse_index[client_id].first;
            list<KeyFrame*>::iterator mainKF_iter= pMergeMap->keyFrameList.begin();
            advance(mainKF_iter, mainKF_global_index);
            KeyFrame* pMergeKF_main;
            if(mainKF_global_index<pMergeMap->keyFrameList.size()){
                pMergeKF_main=(*mainKF_iter);
                if(pMergeKF_main->global_index!=mainKF_global_index){
                    assert(false);
                }
            }
            else{
                assert(false);
            }
//            pCurrentMap->isFirstFusion_globalMutex.unlock();
             
            //更新共视关键帧的一个过程
            
            unique_lock<mutex> lock_curMap(pCurrentMap->mMutexkeyFrameList);
            int keyFrame_num_cur=pCurrentMap->keyFrameList.size();
            lock_curMap.unlock();
            
            
            unique_lock<mutex> lock_mainMap(pMergeMap->mMutexkeyFrameList);
            int keyFrame_num_main=pMergeMap->keyFrameList.size();
            lock_mainMap.unlock();
            
            Matrix3f R_relative_best=r_w2_w1_allClient_cur[client_id].cast<float>();
            Vector3f T_relative_best=t_w2_w1_allClient_cur[client_id].cast<float>();
            
            int max_local=10;
            int min_local=2;
            int front_max=9;//包括当前帧 如果后面没有帧，再往前填充1帧
            //先保证两个地图里面都有至少10帧 才做融合的优化
            if(keyFrame_num_cur>=min_local && keyFrame_num_main>=min_local){//这个其实一定满足 因为第一帧 没有前一帧，是检测不出来的
                //当前关键帧和它的邻居 他们看到的地图点
                list<KeyFrame*> spLocalWindowKFs;
                //主地图
                list<KeyFrame*> spMergeConnectedKFs;
                //设想是 前面取7帧 后面取2帧 加上自己，总共10帧
                //其中固定4帧 至少要固定2帧，而且必须固定不能大于当前帧的
                //-------------------------------------第2个数据----取当前帧附近参与优化的帧 前面8-9个
                //设定当前帧前面至少要有两个帧
                
//                pCurrentMap->mMutexkeyFrameList.lock();
                KeyFrame* pKFi = pCurKF;
                list<KeyFrame*>::iterator pKFi_iter=curKF_iter;
                int nInserted = 0;
                 
                while(pKFi!=pCurrentMap->keyFrameList.front() && nInserted<front_max){
                    spLocalWindowKFs.push_front(pKFi);
                    advance(pKFi_iter, -1);
                    pKFi=*pKFi_iter;
                    nInserted++;
                }
                if(nInserted<front_max){
                    spLocalWindowKFs.push_front(pKFi);
                    nInserted++;
                }
                int optimizer_less=max_local-nInserted;
                
                KeyFrame* pKFi_right = pCurKF;
                list<KeyFrame*>::iterator pKFi_iter_right = curKF_iter;
                std::advance (pKFi_iter_right,1);
                nInserted=0;
                if(pKFi_right!=pCurrentMap->keyFrameList.back()){
                    pKFi_right=*pKFi_iter_right;
                    for( ;nInserted<optimizer_less && pKFi_right!=pCurrentMap->keyFrameList.back() ;nInserted++){
                        spLocalWindowKFs.push_back(pKFi_right);
                        std::advance (pKFi_iter_right,1);
                        pKFi_right=*pKFi_iter_right;
                    }
                    
                    if(nInserted<optimizer_less){
                        spLocalWindowKFs.push_back(pKFi_right);
                        nInserted++;
                        //说明后面的帧不够 往前面补充
                        optimizer_less-=nInserted;
                        nInserted=0;
                        std::advance (pKFi_iter,-1);
                        for(;nInserted<optimizer_less && pKFi!=pCurrentMap->keyFrameList.front();nInserted++){
                            pKFi=*pKFi_iter;
                            spLocalWindowKFs.push_front(pKFi);
                            advance(pKFi_iter, -1);
                        }
                       
                    }
                }
                

//                pCurrentMap->mMutexkeyFrameList.unlock();
                
             
                //-------------------------------------第1个数据----去主地图发生融合帧附近参与优化的帧 主地图前面4个 后面5个
                
//                pMergeMap->mMutexkeyFrameList.lock();
                pKFi = pMergeKF_main;
                pKFi_iter=mainKF_iter;
                nInserted = 0;
                
                while(pKFi!=pMergeMap->keyFrameList.front() && nInserted<front_max){
                    spMergeConnectedKFs.push_front(pKFi);
                    advance(pKFi_iter, -1);
                    pKFi=*pKFi_iter;
                    nInserted++;
                }
                if(nInserted<front_max){
                    spMergeConnectedKFs.push_front(pKFi);
                    nInserted++;
                }
                optimizer_less=max_local-nInserted;
//                cout<<"optimizer_less="<<optimizer_less<<endl;
                pKFi_right = pMergeKF_main;
                pKFi_iter_right=mainKF_iter;
                std::advance (pKFi_iter_right,1);
                nInserted=0;
                if(pKFi_right!=pMergeMap->keyFrameList.back()){
                    pKFi_right=*pKFi_iter_right;
                    for( ;nInserted<optimizer_less && pKFi_right!=pMergeMap->keyFrameList.back()  ;nInserted++){
                        spMergeConnectedKFs.push_back(pKFi_right);
                        std::advance (pKFi_iter_right,1);
                        pKFi_right=*pKFi_iter_right;
                    }
                }
                if(nInserted<optimizer_less){
                    spMergeConnectedKFs.push_back(pKFi_right);
                    nInserted++;
                    //说明后面的帧不够 往前面补充
                    optimizer_less-=nInserted;
                    nInserted=0;
                    std::advance (pKFi_iter,-1);
                    for(;nInserted<optimizer_less && pKFi!=pMergeMap->keyFrameList.front();nInserted++){
                        pKFi=*pKFi_iter;
                        spMergeConnectedKFs.push_front(pKFi);
                        advance(pKFi_iter, -1);
                    }
                  
                }
//                pMergeMap->mMutexkeyFrameList.unlock();
                
                
                 
                
                 //主地图的3D点
                 Fuse_4_1_2( R_relative_best, T_relative_best, spLocalWindowKFs, spMergeConnectedKFs, 50);
                 cout<<"用于计算重投影误差的特征点的数量"<<pointsCloud_old_all.size()<<endl;
                 if(pointsCloud_old_all.size()<2){
                     if(isFirstFusion[client_id]==4){
                         isFirstFusion[client_id]=0;
                     }else if(isFirstFusion[client_id]==5){
                         isFirstFusion[client_id]=1;
                     }else if(isFirstFusion[client_id]==6){
                         isFirstFusion[client_id]=3;
                     }
                     pCurrentMap->isFirstFusion_globalMutex.unlock();
                     continue;
                 }
                 
                 int max_length=20;
                 double t_array[max_length][3];
                 Quaterniond q_array[max_length];
                 double euler_array[max_length][3];

                 //这里存的是 不在局部窗口中的帧的位姿
                 int kf_old_num=0;
                 double t_array_old[max_length][3];
                 double euler_array_old[max_length][3];
                //请求每个地图自己的全局优化结束 和大地图的全局优化停止
                //其实更新地图位姿 是会加锁的 所以相当于加了锁
                 
                ceres::Problem problem;
                ceres::Solver::Options options;
                //options.linear_solver_type = ceres::DENSE_NORMAL_CHOLESKY;
                options.linear_solver_type = ceres::DENSE_SCHUR;
                options.minimizer_progress_to_stdout = true;
                options.max_num_iterations = 10;
                ceres::Solver::Summary summary;
                ceres::LossFunction *loss_function;
                loss_function = new ceres::HuberLoss(1.0);
                ceres::LocalParameterization* angle_local_parameterization =
                AngleLocalParameterization::Create();
                
                int startId_cur=spLocalWindowKFs.front()->global_index;//把参与优化的小地图的帧序号转到0-10之间
                          
                //上面再改改 保持spFixedKFs spLocalWindowKFs有序 已经保持有序
                int num_i=0;

                for(KeyFrame* pKFi : spLocalWindowKFs)
               {
//                   cout<<"pKFi->global_index:"<<pKFi->global_index<<endl;
                   Eigen::Vector3d origin_T_w_i;//
                   Eigen::Matrix3d origin_R_w_i;
                   Quaterniond origin_q;
                       pKFi->getOriginPose(origin_T_w_i, origin_R_w_i);
//                   pKFi->getPose(origin_T_w_i, origin_R_w_i);
                   origin_q=origin_R_w_i;
                   t_array[num_i][0]=origin_T_w_i(0);
                   t_array[num_i][1]=origin_T_w_i(1);
                   t_array[num_i][2]=origin_T_w_i(2);
                   q_array[num_i]=origin_q;

                   Vector3d euler_angle=Utility::R2ypr(origin_q.toRotationMatrix());
                   euler_array[num_i][0]=euler_angle.x();
                   euler_array[num_i][1]=euler_angle.y();
                   euler_array[num_i][2]=euler_angle.z();
                   problem.AddParameterBlock(euler_array[num_i], 1, angle_local_parameterization);
                   problem.AddParameterBlock(t_array[num_i], 3);
//                   if(pKFi->global_index==startId_cur){
                       problem.SetParameterBlockConstant(euler_array[num_i]);
                       problem.SetParameterBlockConstant(t_array[num_i]);
//                   }

//                   cout<<"spLocalWindowKFs "<<pKFi->global_index<<" "<<num_i<<" euler_array[num_i].x"<< euler_array[num_i][0]<<" euler_array[num_i].y"<< euler_array[num_i][1]<<" euler_array[num_i].z"<< euler_array[num_i][2]<<" t_array[num_i].x"<< t_array[num_i][0]<<" t_array[num_i].y"<< t_array[num_i][1]<<" t_array[num_i].z"<< t_array[num_i][2]<<endl;

                   num_i++;

               }
//                cout<<"spLocalWindowKFs num_i="<<num_i<<endl;
                
                
                double t_Wcur_Wmain[3];
                double r_Wcur_Wmain[3];
    //
                t_Wcur_Wmain[0]=T_relative_best(0);
                t_Wcur_Wmain[1]=T_relative_best(1);
                t_Wcur_Wmain[2]=T_relative_best(2);
                Vector3d euler_angle=Utility::R2ypr(R_relative_best.cast<double>());
                r_Wcur_Wmain[0]=euler_angle.x();
                r_Wcur_Wmain[1]=euler_angle.y();
                r_Wcur_Wmain[2]=euler_angle.z();
                problem.AddParameterBlock(r_Wcur_Wmain, 3);
                problem.AddParameterBlock(t_Wcur_Wmain, 3);
                 
                //添加相机-imu之间的外参
                //因为是固定的 可以不当做优化参数
                Client* c_cur= pCurKF->c;
                Matrix3d ric_cur=c_cur->ric_client;
                Vector3d tic_cur=c_cur->tic_client;
                Vector3d euler_angle_ric=Utility::R2ypr(ric_cur);
     
                double cx=pCurKF->c->PX_server;
                double cy=pCurKF->c->PY_server;
                double fx=pCurKF->c->FOCUS_LENGTH_X_server;
                double fy=pCurKF->c->FOCUS_LENGTH_Y_server;
                for (int i=0,j=pointsCloud_old_all.size();i<j;i++)
               {
                   vector<Eigen::Vector3d> pointsCloud_old_3d_test=pointsCloud_old_all[i];
                   vector<cv::Point2f> measurements_cur_2d_test=measurements_cur_all[i];
                   int kf_id_cur=curKF_id_all[i];
                   int para_pose_cur_index=kf_id_cur-startId_cur;

                   for(int a=0,b=pointsCloud_old_3d_test.size();a<b;a++){
                       //找到主地图那个点 所在帧的位姿
                       Vector3d pts_i = pointsCloud_old_3d_test[a];

                       cv::Point2f pt=measurements_cur_2d_test[a];
                       float xx=pt.x;
                       float yy=pt.y;

                       double xxxx=(xx-cx)/fx;
                       double yyyy=(yy-cy)/fy;
                       double zzzz=1.0;
                        Vector3d pts_j ;//要求是归一化图像坐标
                        pts_j<<xxxx,yyyy,zzzz;

                       ceres::CostFunction* cost_function = FourDOFWeightError_reprojection::Create( pts_i.x(), pts_i.y(), pts_i.z(),pts_j.x(), pts_j.y(), pts_j.z(),tic_cur[0], tic_cur[1], tic_cur[2], euler_angle_ric.x(), euler_angle_ric.y(), euler_angle_ric.z(), euler_array[para_pose_cur_index][1], euler_array[para_pose_cur_index][2],20.0);
                       problem.AddResidualBlock(cost_function, loss_function, euler_array[para_pose_cur_index],
                                                t_array[para_pose_cur_index],
                                                r_Wcur_Wmain,
                                                t_Wcur_Wmain);
                    }

                }

                
                Fuse_4_2_2( R_relative_best, T_relative_best, spLocalWindowKFs, spMergeConnectedKFs, 50);
                cout<<"第2次 用于计算重投影误差的特征点的数量"<<pointsCloud_old_all.size()<<endl;
                if(pointsCloud_old_all.size()<2){
                    if(isFirstFusion[client_id]==4){
                        isFirstFusion[client_id]=0;
                    }else if(isFirstFusion[client_id]==5){
                        isFirstFusion[client_id]=1;
                    }else if(isFirstFusion[client_id]==6){
                        isFirstFusion[client_id]=3;
                    }
                    pCurrentMap->isFirstFusion_globalMutex.unlock();
                    continue;
                }

                int keyframe_num=num_i;
                int keyframe_main_start=spMergeConnectedKFs.front()->global_index;
                for(KeyFrame* pKFi:spMergeConnectedKFs){
                //                cout<<"pKFi->global_index:"<<pKFi->global_index<<endl;
                    Eigen::Vector3d origin_T_w_i;//
                    Eigen::Matrix3d origin_R_w_i;
                    Quaterniond origin_q;
                    pKFi->getOriginPose(origin_T_w_i, origin_R_w_i);
//                    pKFi->getPose(origin_T_w_i, origin_R_w_i);
                    origin_q=origin_R_w_i;
                    t_array[num_i][0]=origin_T_w_i(0);
                    t_array[num_i][1]=origin_T_w_i(1);
                    t_array[num_i][2]=origin_T_w_i(2);
                    q_array[num_i]=origin_q;

                    Vector3d euler_angle=Utility::R2ypr(origin_q.toRotationMatrix());
                    euler_array[num_i][0]=euler_angle.x();
                    euler_array[num_i][1]=euler_angle.y();
                    euler_array[num_i][2]=euler_angle.z();
                    problem.AddParameterBlock(euler_array[num_i], 1, angle_local_parameterization);
                    problem.AddParameterBlock(t_array[num_i], 3);
                    problem.SetParameterBlockConstant(euler_array[num_i]);
                    problem.SetParameterBlockConstant(t_array[num_i]);

//                    cout<<"spMergeConnectedKFs  "<<pKFi->global_index<<" "<<num_i<<" euler_array[num_i].x"<< euler_array[num_i][0]<<" euler_array[num_i].y"<< euler_array[num_i][1]<<" euler_array[num_i].z"<< euler_array[num_i][2]<<" t_array[num_i].x"<< t_array[num_i][0]<<" t_array[num_i].y"<< t_array[num_i][1]<<" t_array[num_i].z"<< t_array[num_i][2]<<endl;
                    num_i++;
                }

                 Client* c_main= pMergeKF_main->c;
                 Matrix3d ric_main=c_main->ric_client;
                 Vector3d tic_main=c_main->tic_client;
                 Vector3d euler_angle_ric_main=Utility::R2ypr(ric_main);
                  for (int i=0,j=pointsCloud_old_all.size();i<j;i++)
                 {
                     vector<Eigen::Vector3d> pointsCloud_old_3d_test=pointsCloud_old_all[i];
                     vector<cv::Point2f> measurements_cur_2d_test=measurements_cur_all[i];
                     int kf_id_cur=curKF_id_all[i];
                     int para_pose_cur_index=kf_id_cur-keyframe_main_start+keyframe_num;
//                     cout<<"验证id对不对: "<<kf_id_cur<<" "<<para_pose_cur_index<<endl;
                     for(int a=0,b=pointsCloud_old_3d_test.size();a<b;a++){
                         //找到主地图那个点 所在帧的位姿
                         Vector3d pts_i = pointsCloud_old_3d_test[a];

                         cv::Point2f pt=measurements_cur_2d_test[a];
                         float xx=pt.x;
                         float yy=pt.y;

                         double xxxx=(xx-cx)/fx;
                         double yyyy=(yy-cy)/fy;
                         double zzzz=1.0;
                          Vector3d pts_j ;//要求是归一化图像坐标
                          pts_j<<xxxx,yyyy,zzzz;

                         ceres::CostFunction* cost_function = FourDOFWeightError_reprojection_inverse_Wmain_Wcur::Create( pts_i.x(), pts_i.y(), pts_i.z(),pts_j.x(), pts_j.y(), pts_j.z(),tic_main[0], tic_main[1], tic_main[2], euler_angle_ric_main.x(), euler_angle_ric_main.y(), euler_angle_ric_main.z(), euler_array[para_pose_cur_index][1], euler_array[para_pose_cur_index][2],20.0);
                         problem.AddResidualBlock(cost_function, loss_function, euler_array[para_pose_cur_index],
                                                  t_array[para_pose_cur_index],
                                                  r_Wcur_Wmain,
                                                  t_Wcur_Wmain);
                      }

                  }

             
                
                ceres::Solve(options, &problem, &summary);
                std::cout <<"ceres summary:"<< summary.BriefReport()<< "\n";
                
                T_relative_best[0]=t_Wcur_Wmain[0];
               T_relative_best[1]=t_Wcur_Wmain[1];
               T_relative_best[2]=t_Wcur_Wmain[2];
               euler_angle[0]=r_Wcur_Wmain[0];
               euler_angle[1]=r_Wcur_Wmain[1];
               euler_angle[2]=r_Wcur_Wmain[2];
               R_relative_best=Utility::ypr2R(Eigen::Vector3d(euler_angle[0],euler_angle[1],euler_angle[2])).cast<float>();
                
                
                Matrix3d r_w2_w1=R_relative_best.cast<double>();
                Vector3d t_w2_w1=T_relative_best.cast<double>();
                Matrix3d r_test;
                Vector3d t_test;
                pMergeKF_main->getOriginPose(t_test, r_test);

                Matrix3d r_w2_i1=r_w2_w1* r_test;
                Vector3d t_w2_i1=r_w2_w1* t_test+ t_w2_w1;

                int para_pose_cur_index_test=pCurKF->global_index-startId_cur;
                Matrix3d tmp_r=Utility::ypr2R(Eigen::Vector3d(euler_array[para_pose_cur_index_test][0],euler_array[para_pose_cur_index_test][1],euler_array[para_pose_cur_index_test][2]));
                Vector3d tmp_t(t_array[para_pose_cur_index_test][0], t_array[para_pose_cur_index_test][1], t_array[para_pose_cur_index_test][2]);



                Vector3d relative_t = r_w2_i1.transpose() * (tmp_t - t_w2_i1);
                Matrix3d relative_r = r_w2_i1.transpose() * tmp_r;


                Quaterniond relative_q;
                relative_q=relative_r;
                double relative_yaw = Utility::normalizeAngle(euler_array[para_pose_cur_index_test][0] - Utility::R2ypr(r_w2_i1).x());
                double relative_pitch = Utility::normalizeAngle(euler_array[para_pose_cur_index_test][1] - Utility::R2ypr(r_w2_i1).y());
                double relative_roll = Utility::normalizeAngle(euler_array[para_pose_cur_index_test][2] - Utility::R2ypr(r_w2_i1).z());
                
                
//                Matrix3d tmp_w1_r_main;
//                Vector3d tmp_w1_t_main;
//                pMergeKF_main->getOriginPose(tmp_w1_t_main, tmp_w1_r_main);
//                cout<<"测试pitch roll:"<<loop_pose_r[1]<<" "<<loop_pose_r[2]<<" "<<Utility::R2ypr(tmp_w1_r_main).y()<<" "<<Utility::R2ypr(tmp_w1_r_main).z()<<endl;
//
//                Matrix3d tmp_r_main=Utility::ypr2R(Vector3d(loop_pose_r[0], loop_pose_r[1], loop_pose_r[2]));
//                Vector3d tmp_t_main=Vector3d(loop_pose_t[0], loop_pose_t[1], loop_pose_t[2]) ;
//                Vector3d relative_t = tmp_r_main.transpose() * (cur_t - tmp_t_main);
//                Matrix3d relative_r = tmp_r_main.transpose() * cur_r;
//                Quaterniond relative_q;
//                relative_q=relative_r;
//                double relative_yaw = Utility::normalizeAngle(Utility::R2ypr(cur_r).x() - Utility::R2ypr(tmp_r_main).x());
//                double relative_pitch = Utility::normalizeAngle(Utility::R2ypr(cur_r).y() - Utility::R2ypr(tmp_r_main).y());
//                double relative_roll = Utility::normalizeAngle(Utility::R2ypr(cur_r).z() - Utility::R2ypr(tmp_r_main).z());
                 if(relative_t.norm()>10 || abs(relative_yaw)>30){
                    cout<<"变化太大了"<<endl;
                    if(isFirstFusion[client_id]==4){
                        isFirstFusion[client_id]=0;
                    }else if(isFirstFusion[client_id]==5){
                        isFirstFusion[client_id]=1;
                    }else if(isFirstFusion[client_id]==6){
                        isFirstFusion[client_id]=3;
                        pCurrentMap->start_global_fuse_opti_mutex.lock();
                        pCurrentMap->start_global_fuse_opti=1;
                        pCurrentMap->start_global_fuse_opti_mutex.unlock();
                    }else{
                        assert(false);//都已经找到最老的回环了，竟然还没有记录已经发生过回环了
                    }
                    pCurrentMap->isFirstFusion_globalMutex.unlock();

                    continue;
                }
                
                if(pCurrentMap->is_fusion){
                    
                    Matrix3d Rs_loop;
                    Vector3d Ps_loop;
                    pMergeKF_main->getPose(Ps_loop,Rs_loop);


                    Vector3d relative_t = Rs_loop.transpose() * (t_w2_i1 - Ps_loop);
//                    Matrix3d relative_q = Rs_loop.transpose() * r_w2_i1;
                    double relative_yaw = Utility::normalizeAngle(Utility::R2ypr(r_w2_i1).x() - Utility::R2ypr(Rs_loop).x());

                  
                    cout<<fixed<<setprecision(6)<<"打印一下相差多少："<<relative_t.norm()<<" "<<relative_yaw<<endl;
                    if(relative_t.norm()<0.03 && abs(relative_yaw)<1.5){
                        cout<<"变化太小了"<<endl;
                        if(isFirstFusion[client_id]==4){
                            isFirstFusion[client_id]=0;
                        }else if(isFirstFusion[client_id]==5){
                            isFirstFusion[client_id]=1;
                        }else if(isFirstFusion[client_id]==6){
                            isFirstFusion[client_id]=3;
                            pCurrentMap->start_global_fuse_opti_mutex.lock();
                            pCurrentMap->start_global_fuse_opti=1;
                            pCurrentMap->start_global_fuse_opti_mutex.unlock();
                        }else{
                            assert(false);//都已经找到最老的回环了，竟然还没有记录已经发生过回环了
                        }
                        pCurrentMap->isFirstFusion_globalMutex.unlock();

                        continue;
                    }
                }
                
                
                
                pCurKF->update_globalLoopConnection(relative_t, relative_q, relative_yaw);
                pCurKF->global_relative_pitch=relative_pitch;
                pCurKF->global_relative_roll=relative_roll;
                pCurKF->detect_globalLoop(mainKF_global_index);
                pMergeKF_main->is_detected_globalLoop(curKF_global_index);
                
                pCurrentMap->is_fusion=1;
                
                
 
               //找到了
                int has_fusion_num=isFirstFusion[client_id];
                if(has_fusion_num==4){
                    isFirstFusion[client_id]=1;
                }else if(has_fusion_num==5){
                    isFirstFusion[client_id]=3;
                }
                else if(has_fusion_num==6){
                    isFirstFusion[client_id]=3;
                }else{
                    assert(false);//都已经找到最老的回环了，竟然还没有记录已经发生过回环了
                }
                   
                //思考一下赋值
                std::pair<int, int> latest_index_test= latest_global_loop_index[client_id];
                int latest_index_main_test=latest_index_test.first;
                int latest_index_cur_test=latest_index_test.second;
                latest_index_main_test=latest_index_main_test>mainKF_global_index?latest_index_main_test:mainKF_global_index;
                latest_index_cur_test=latest_index_cur_test>curKF_global_index?latest_index_cur_test:curKF_global_index;
                latest_global_loop_index[client_id]=std::make_pair(latest_index_main_test, latest_index_cur_test);
                //记录主地图和其它地图最早的融合位置
                if(earliest_global_loop_index[client_id]==-1 || earliest_global_loop_index[client_id]>mainKF_global_index){
                    earliest_global_loop_index[client_id]=mainKF_global_index;
                }
                pCurrentMap->isFirstFusion_globalMutex.unlock();
                
                pCurrentMap->start_global_fuse_opti_mutex.lock();
                pCurrentMap->start_global_fuse_opti=1;
                pCurrentMap->start_global_fuse_opti_mutex.unlock();
            }
            else{
                pCurrentMap->isFirstFusion_globalMutex.unlock();
            }
        }
        }else{
//            poseGraphGlobal_mutex.unlock();
            readWriteLock.readUnLock();
            usleep(2000);
        }
        usleep(30);
    }
}


//这里对应loopClosure13版本 换一下重投影找匹配点使用的位姿
void  PoseGraphGlobal::MergeLocal_15(){
    while(true){
        int len = sizeof(isFirstFusion) / sizeof(isFirstFusion[0]);
        if(PoseGraphGloabl_map.size()>1){
        for(int client_id=1;client_id<len;client_id++){//这里的i其实代表的就是 ClientId
            
            map<int,PoseGraph*>::iterator iter_map = PoseGraphGloabl_map.find(client_id);
            if(iter_map==PoseGraphGloabl_map.end())
            {
                continue;
            }
            PoseGraph* pCurrentMap= iter_map->second;//新的地图 小的地图
            PoseGraph* pMergeMap= PoseGraphGloabl_map[0];//老的地图 主地图 精度更高
            
            
            pCurrentMap->isFirstFusion_globalMutex.lock();
            if(!(isFirstFusion[client_id]==4 || isFirstFusion[client_id]==5 || isFirstFusion[client_id]==6))
            {
                pCurrentMap->isFirstFusion_globalMutex.unlock();
                continue;
            }
            
            //这里并没有用到
            vector<cv::Point2f> measurements_old_norm_clone= measurements_norm_main[client_id];
            vector<int> feature_id_cur_clone=feature_id_cur[client_id];
            
            //得到两个匹配的关键帧
            int curKF_global_index=cur_globalFuse_index[client_id].second;
            list<KeyFrame*>::iterator curKF_iter= pCurrentMap->keyFrameList.begin();
            advance(curKF_iter, curKF_global_index);
            KeyFrame* pCurKF;
            if(curKF_global_index<pCurrentMap->keyFrameList.size()){
                pCurKF=(*curKF_iter);
                if(pCurKF->global_index!=curKF_global_index){
                    assert(false);
                }
            }
            else{
                assert(false);
            }
//            setIMUModel(pCurKF->c->FOCUS_LENGTH_X_server);// 该传哪一个fx给重投影误差因子图  这里是其它地图 如果优化是自己求导，要设置的一个权重
            
            int mainKF_global_index=cur_globalFuse_index[client_id].first;
            list<KeyFrame*>::iterator mainKF_iter= pMergeMap->keyFrameList.begin();
            advance(mainKF_iter, mainKF_global_index);
            KeyFrame* pMergeKF_main;
            if(mainKF_global_index<pMergeMap->keyFrameList.size()){
                pMergeKF_main=(*mainKF_iter);
                if(pMergeKF_main->global_index!=mainKF_global_index){
                    assert(false);
                }
            }
            else{
                assert(false);
            }
//            pCurrentMap->isFirstFusion_globalMutex.unlock();
             
            //更新共视关键帧的一个过程
            
            unique_lock<mutex> lock_curMap(pCurrentMap->mMutexkeyFrameList);
            int keyFrame_num_cur=pCurrentMap->keyFrameList.size();
            lock_curMap.unlock();
            
            
            unique_lock<mutex> lock_mainMap(pMergeMap->mMutexkeyFrameList);
            int keyFrame_num_main=pMergeMap->keyFrameList.size();
            lock_mainMap.unlock();
            
//            Matrix3f R_relative_best=r_w2_w1_allClient_cur[client_id].cast<float>();
//            Vector3f T_relative_best=t_w2_w1_allClient_cur[client_id].cast<float>();
            
            //这里代表的是 第2个世界坐标系 到 a的相机坐标系
            Matrix3f R_relative_best=r_ca_w2_cur[client_id];
            Vector3f T_relative_best=t_ca_w2_cur[client_id];
            
            int max_local=10;
            int min_local=2;
            int front_max=9;//包括当前帧 如果后面没有帧，再往前填充1帧
            //先保证两个地图里面都有至少10帧 才做融合的优化
            if(keyFrame_num_cur>=min_local && keyFrame_num_main>=min_local){//这个其实一定满足 因为第一帧 没有前一帧，是检测不出来的
                //当前关键帧和它的邻居 他们看到的地图点
                list<KeyFrame*> spLocalWindowKFs;
                //主地图
                list<KeyFrame*> spMergeConnectedKFs;
                //设想是 前面取7帧 后面取2帧 加上自己，总共10帧
                //其中固定4帧 至少要固定2帧，而且必须固定不能大于当前帧的
                //-------------------------------------第2个数据----取当前帧附近参与优化的帧 前面8-9个
                //设定当前帧前面至少要有两个帧
                
//                pCurrentMap->mMutexkeyFrameList.lock();
                KeyFrame* pKFi = pCurKF;
                list<KeyFrame*>::iterator pKFi_iter=curKF_iter;
                int nInserted = 0;
                 
                while(pKFi!=pCurrentMap->keyFrameList.front() && nInserted<front_max){
                    spLocalWindowKFs.push_front(pKFi);
                    advance(pKFi_iter, -1);
                    pKFi=*pKFi_iter;
                    nInserted++;
                }
                if(nInserted<front_max){
                    spLocalWindowKFs.push_front(pKFi);
                    nInserted++;
                }
                int optimizer_less=max_local-nInserted;
                
                KeyFrame* pKFi_right = pCurKF;
                list<KeyFrame*>::iterator pKFi_iter_right = curKF_iter;
                std::advance (pKFi_iter_right,1);
                nInserted=0;
                if(pKFi_right!=pCurrentMap->keyFrameList.back()){
                    pKFi_right=*pKFi_iter_right;
                    for( ;nInserted<optimizer_less && pKFi_right!=pCurrentMap->keyFrameList.back() ;nInserted++){
                        spLocalWindowKFs.push_back(pKFi_right);
                        std::advance (pKFi_iter_right,1);
                        pKFi_right=*pKFi_iter_right;
                    }
                    
                    if(nInserted<optimizer_less){
                        spLocalWindowKFs.push_back(pKFi_right);
                        nInserted++;
                        //说明后面的帧不够 往前面补充
                        optimizer_less-=nInserted;
                        nInserted=0;
                        std::advance (pKFi_iter,-1);
                        for(;nInserted<optimizer_less && pKFi!=pCurrentMap->keyFrameList.front();nInserted++){
                            pKFi=*pKFi_iter;
                            spLocalWindowKFs.push_front(pKFi);
                            advance(pKFi_iter, -1);
                        }
                       
                    }
                }
                

//                pCurrentMap->mMutexkeyFrameList.unlock();
                
             
                //-------------------------------------第1个数据----去主地图发生融合帧附近参与优化的帧 主地图前面4个 后面5个
                
//                pMergeMap->mMutexkeyFrameList.lock();
                pKFi = pMergeKF_main;
                pKFi_iter=mainKF_iter;
                nInserted = 0;
                
                while(pKFi!=pMergeMap->keyFrameList.front() && nInserted<front_max){
                    spMergeConnectedKFs.push_front(pKFi);
                    advance(pKFi_iter, -1);
                    pKFi=*pKFi_iter;
                    nInserted++;
                }
                if(nInserted<front_max){
                    spMergeConnectedKFs.push_front(pKFi);
                    nInserted++;
                }
                optimizer_less=max_local-nInserted;
//                cout<<"optimizer_less="<<optimizer_less<<endl;
                pKFi_right = pMergeKF_main;
                pKFi_iter_right=mainKF_iter;
                std::advance (pKFi_iter_right,1);
                nInserted=0;
                if(pKFi_right!=pMergeMap->keyFrameList.back()){
                    pKFi_right=*pKFi_iter_right;
                    for( ;nInserted<optimizer_less && pKFi_right!=pMergeMap->keyFrameList.back()  ;nInserted++){
                        spMergeConnectedKFs.push_back(pKFi_right);
                        std::advance (pKFi_iter_right,1);
                        pKFi_right=*pKFi_iter_right;
                    }
                }
                if(nInserted<optimizer_less){
                    spMergeConnectedKFs.push_back(pKFi_right);
                    nInserted++;
                    //说明后面的帧不够 往前面补充
                    optimizer_less-=nInserted;
                    nInserted=0;
                    std::advance (pKFi_iter,-1);
                    for(;nInserted<optimizer_less && pKFi!=pMergeMap->keyFrameList.front();nInserted++){
                        pKFi=*pKFi_iter;
                        spMergeConnectedKFs.push_front(pKFi);
                        advance(pKFi_iter, -1);
                    }
                  
                }
//                pMergeMap->mMutexkeyFrameList.unlock();
                
                
                 
                
                 //主地图的3D点
//                 Fuse_4_1_2( R_relative_best, T_relative_best, spLocalWindowKFs, spMergeConnectedKFs, 50);
                
                //改成 其它地图的3D点 主地图的2D点
                Fuse_5_2_2( R_relative_best, T_relative_best, spLocalWindowKFs, pMergeKF_main, 50);
                 cout<<"用于计算重投影误差的特征点的数量"<<pointsCloud_old_all.size()<<endl;
                 if(pointsCloud_old_all.size()<2){
                     if(isFirstFusion[client_id]==4){
                         isFirstFusion[client_id]=0;
                     }else if(isFirstFusion[client_id]==5){
                         isFirstFusion[client_id]=1;
                     }else if(isFirstFusion[client_id]==6){
                         isFirstFusion[client_id]=3;
                     }
                     pCurrentMap->isFirstFusion_globalMutex.unlock();
                     continue;
                 }
                 
                 int max_length=20;
                 double t_array[max_length][3];
                 Quaterniond q_array[max_length];
                 double euler_array[max_length][3];

                 //这里存的是 不在局部窗口中的帧的位姿
                 int kf_old_num=0;
                 double t_array_old[max_length][3];
                 double euler_array_old[max_length][3];
                //请求每个地图自己的全局优化结束 和大地图的全局优化停止
                //其实更新地图位姿 是会加锁的 所以相当于加了锁
                 
                ceres::Problem problem;
                ceres::Solver::Options options;
                //options.linear_solver_type = ceres::DENSE_NORMAL_CHOLESKY;
                options.linear_solver_type = ceres::DENSE_SCHUR;
                options.minimizer_progress_to_stdout = true;
                options.max_num_iterations = 10;
                ceres::Solver::Summary summary;
                ceres::LossFunction *loss_function;
                loss_function = new ceres::HuberLoss(1.0);
                ceres::LocalParameterization* angle_local_parameterization =
                AngleLocalParameterization::Create();
                
                int startId_cur=spLocalWindowKFs.front()->global_index;//把参与优化的小地图的帧序号转到0-10之间
                          
                //上面再改改 保持spFixedKFs spLocalWindowKFs有序 已经保持有序
                int num_i=0;

                
                
                double t_c1_w2[3];
                double r_c1_w2[3];
    //
                t_c1_w2[0]=T_relative_best(0);
                t_c1_w2[1]=T_relative_best(1);
                t_c1_w2[2]=T_relative_best(2);
                Vector3d euler_angle=Utility::R2ypr(R_relative_best.cast<double>());
                r_c1_w2[0]=euler_angle.x();
                r_c1_w2[1]=euler_angle.y();
                r_c1_w2[2]=euler_angle.z();
                problem.AddParameterBlock(r_c1_w2, 3);
                problem.AddParameterBlock(t_c1_w2, 3);
                 
                //添加相机-imu之间的外参
                //因为是固定的 可以不当做优化参数
                Client* c_main= pMergeKF_main->c;
                Matrix3d ric_main=c_main->ric_client;
                Vector3d tic_main=c_main->tic_client;
                Vector3d euler_angle_ric=Utility::R2ypr(ric_main);
     
                double cx=c_main->PX_server;
                double cy=c_main->PY_server;
                double fx=c_main->FOCUS_LENGTH_X_server;
                double fy=c_main->FOCUS_LENGTH_Y_server;
                //这里其实是 新帧的3D点 老帧的2D点
                for (int i=0,j=pointsCloud_old_all.size();i<j;i++)
               {
                   vector<Eigen::Vector3d> pointsCloud_old_3d_test=pointsCloud_old_all[i];
                   vector<cv::Point2f> measurements_cur_2d_test=measurements_cur_all[i];//像素坐标
                   int kf_id_cur=curKF_id_all[i];
                   int para_pose_cur_index=kf_id_cur-startId_cur;

                   for(int a=0,b=pointsCloud_old_3d_test.size();a<b;a++){
                       //找到主地图那个点 所在帧的位姿
                       Vector3d pts_i = pointsCloud_old_3d_test[a];

                       cv::Point2f pt=measurements_cur_2d_test[a];
                       float xx=pt.x;
                       float yy=pt.y;

                       double xxxx=(xx-cx)/fx;
                       double yyyy=(yy-cy)/fy;
                       double zzzz=1.0;
                        Vector3d pts_j ;//要求是归一化图像坐标
                        pts_j<<xxxx,yyyy,zzzz;

                       ceres::CostFunction* cost_function = FourDOFWeightError_reprojection2::Create( pts_i.x(), pts_i.y(), pts_i.z(),pts_j.x(), pts_j.y(), pts_j.z(),100.0);
                       problem.AddResidualBlock(cost_function, loss_function, r_c1_w2, t_c1_w2);
                    }

                }

              
                
                ceres::Solve(options, &problem, &summary);
                std::cout <<"ceres summary:"<< summary.BriefReport()<< "\n";
                
               T_relative_best[0]=t_c1_w2[0];
               T_relative_best[1]=t_c1_w2[1];
               T_relative_best[2]=t_c1_w2[2];
               euler_angle[0]=r_c1_w2[0];
               euler_angle[1]=r_c1_w2[1];
               euler_angle[2]=r_c1_w2[2];
               R_relative_best=Utility::ypr2R(Eigen::Vector3d(euler_angle[0],euler_angle[1],euler_angle[2])).cast<float>();
                
                Matrix3f r_w2_i1;
                Vector3f t_w2_i1;
                pMergeKF_main->cam2Imu(T_relative_best, R_relative_best, t_w2_i1 , r_w2_i1);

                
                Matrix3d r_w2_i2;
                Vector3d t_w2_i2;
                pCurKF->getOriginPose(t_w2_i2, r_w2_i2);
                Matrix3f r_w2_i2_f;
                Vector3f t_w2_i2_f;
                r_w2_i2_f=r_w2_i2.cast<float>();
                t_w2_i2_f=t_w2_i2.cast<float>();


//r_i1_i2
                Vector3d relative_t = r_w2_i1.cast<double>().transpose() * (t_w2_i2 - t_w2_i1.cast<double>());
                Matrix3d relative_r = r_w2_i1.cast<double>().transpose() * r_w2_i2;


                Quaterniond relative_q;
                relative_q=relative_r;
                
                
                double relative_yaw = Utility::normalizeAngle(Utility::R2ypr(r_w2_i2).x() - Utility::R2ypr(r_w2_i1.cast<double>()).x());
                double relative_pitch = Utility::normalizeAngle(Utility::R2ypr(r_w2_i2).y() - Utility::R2ypr(r_w2_i1.cast<double>()).y());
                double relative_roll = Utility::normalizeAngle(Utility::R2ypr(r_w2_i2).z() - Utility::R2ypr(r_w2_i1.cast<double>()).z());
                
                
                 if(relative_t.norm()>10 || abs(relative_yaw)>30){
                    cout<<"变化太大了"<<endl;
                    if(isFirstFusion[client_id]==4){
                        isFirstFusion[client_id]=0;
                    }else if(isFirstFusion[client_id]==5){
                        isFirstFusion[client_id]=1;
                    }else if(isFirstFusion[client_id]==6){
                        isFirstFusion[client_id]=3;
                        pCurrentMap->start_global_fuse_opti_mutex.lock();
                        pCurrentMap->start_global_fuse_opti=1;
                        pCurrentMap->start_global_fuse_opti_mutex.unlock();
                    }else{
                        assert(false);//都已经找到最老的回环了，竟然还没有记录已经发生过回环了
                    }
                    pCurrentMap->isFirstFusion_globalMutex.unlock();

                    continue;
                }
                
                //加一个判断 防止过拟合 好像没法加
                
                               
                pCurKF->update_globalLoopConnection(relative_t, relative_q, relative_yaw);
                pCurKF->global_relative_pitch=relative_pitch;
                pCurKF->global_relative_roll=relative_roll;
                pCurKF->detect_globalLoop(mainKF_global_index);
                pMergeKF_main->is_detected_globalLoop(curKF_global_index);
                
                pCurrentMap->is_fusion=1;
                
                
 
               //找到了
                int has_fusion_num=isFirstFusion[client_id];
                if(has_fusion_num==4){
                    isFirstFusion[client_id]=1;
                }else if(has_fusion_num==5){
                    isFirstFusion[client_id]=3;
                    //这里说明地图已经融合了 可以检测是不是 过拟合了
                    
                    Matrix3d r_w1_i1;
                    Vector3d t_w1_i1;
                    pMergeKF_main->getOriginPose(t_w1_i1, r_w1_i1);
                    
                    Matrix3d r_w1_i2;
                    Vector3d t_w1_i2;
                    pCurKF->getPose(t_w1_i2, r_w1_i2);
                    
                    Matrix3d r_i1_i2;
                    Vector3d t_i1_i2;
                    r_i1_i2= r_w1_i1.transpose()*r_w1_i2;
                    t_i1_i2= r_w1_i1.transpose()*(t_w1_i2-t_w1_i1);
                    double relative_yaw_2=Utility::normalizeAngle(Utility::R2ypr(r_w1_i2).x()-Utility::R2ypr(r_w1_i1).x());
                    
                    Vector3d real_t=-relative_r*r_i1_i2.transpose()*t_i1_i2+relative_t;
                    double real_yaw_test_test=relative_yaw_2-relative_yaw;

                    cout<<fixed<<setprecision(6)<<"打印一下相差多少："<<real_t.norm()<<" "<<real_yaw_test_test<<endl;
                    if(real_t.norm()<0.03 && abs(real_yaw_test_test)<1.5){
                        pCurKF->isRemove_globalLoop=true;
                        
                    }
                    
                    
                }
                else if(has_fusion_num==6){
                    isFirstFusion[client_id]=3;
                    
                    //这里说明地图已经融合了 可以检测是不是 过拟合了
                    
                    Matrix3d r_w1_i1;
                    Vector3d t_w1_i1;
                    pMergeKF_main->getOriginPose(t_w1_i1, r_w1_i1);
                    
                    Matrix3d r_w1_i2;
                    Vector3d t_w1_i2;
                    pCurKF->getPose(t_w1_i2, r_w1_i2);
                    
                    Matrix3d r_i1_i2;
                    Vector3d t_i1_i2;
                    r_i1_i2= r_w1_i1.transpose()*r_w1_i2;
                    t_i1_i2= r_w1_i1.transpose()*(t_w1_i2-t_w1_i1);
                    double relative_yaw_2=Utility::normalizeAngle(Utility::R2ypr(r_w1_i2).x()-Utility::R2ypr(r_w1_i1).x());
                    
                    Vector3d real_t=-relative_r*r_i1_i2.transpose()*t_i1_i2+relative_t;
                    double real_yaw_test_test=relative_yaw_2-relative_yaw;

                    cout<<fixed<<setprecision(6)<<"打印一下相差多少："<<real_t.norm()<<" "<<real_yaw_test_test<<endl;
                    if(real_t.norm()<0.03 && abs(real_yaw_test_test)<1.5){
                        pCurKF->isRemove_globalLoop=true;
                        
                    }
                }else{
                    assert(false);//都已经找到最老的回环了，竟然还没有记录已经发生过回环了
                }
                   
                //思考一下赋值
                std::pair<int, int> latest_index_test= latest_global_loop_index[client_id];
                int latest_index_main_test=latest_index_test.first;
                int latest_index_cur_test=latest_index_test.second;
                latest_index_main_test=latest_index_main_test>mainKF_global_index?latest_index_main_test:mainKF_global_index;
                latest_index_cur_test=latest_index_cur_test>curKF_global_index?latest_index_cur_test:curKF_global_index;
                latest_global_loop_index[client_id]=std::make_pair(latest_index_main_test, latest_index_cur_test);
                //记录主地图和其它地图最早的融合位置
                if(earliest_global_loop_index[client_id]==-1 || earliest_global_loop_index[client_id]>mainKF_global_index){
                    earliest_global_loop_index[client_id]=mainKF_global_index;
                }
                pCurrentMap->isFirstFusion_globalMutex.unlock();
                
                pCurrentMap->start_global_fuse_opti_mutex.lock();
                pCurrentMap->start_global_fuse_opti=1;
                pCurrentMap->start_global_fuse_opti_mutex.unlock();
            }
            else{
                pCurrentMap->isFirstFusion_globalMutex.unlock();
            }
        }
        }else{
            usleep(2000);
        }
        usleep(30);
    }
}

//改成双向重投影误差 两边都是10个点
void  PoseGraphGlobal::MergeLocal_16(){
    while(true){
        int len = sizeof(isFirstFusion) / sizeof(isFirstFusion[0]);
//        poseGraphGlobal_mutex.lock();
        readWriteLock.readLock();
        if(PoseGraphGloabl_map.size()>1){
//            poseGraphGlobal_mutex.unlock();
            readWriteLock.readUnLock();
        for(int client_id=1;client_id<len;client_id++){//这里的i其实代表的就是 ClientId
            
//            poseGraphGlobal_mutex.lock();
            readWriteLock.readLock();
            map<int,PoseGraph*>::iterator iter_map = PoseGraphGloabl_map.find(client_id);
            if(iter_map==PoseGraphGloabl_map.end())
            {
//                poseGraphGlobal_mutex.unlock();
                readWriteLock.readUnLock();
                continue;
            }
            PoseGraph* pCurrentMap= iter_map->second;//新的地图 小的地图
            PoseGraph* pMergeMap= PoseGraphGloabl_map[0];//老的地图 主地图 精度更高
//            poseGraphGlobal_mutex.unlock();
            readWriteLock.readUnLock();
            
            pCurrentMap->isFirstFusion_globalMutex.lock();
            if(!(isFirstFusion[client_id]==4 || isFirstFusion[client_id]==5 || isFirstFusion[client_id]==6))
            {
                pCurrentMap->isFirstFusion_globalMutex.unlock();
                continue;
            }
            
            //这里并没有用到
            vector<cv::Point2f> measurements_old_norm_clone= measurements_norm_main[client_id];
            vector<int> feature_id_cur_clone=feature_id_cur[client_id];
            
            //得到两个匹配的关键帧
            int curKF_global_index=cur_globalFuse_index[client_id].second;
            list<KeyFrame*>::iterator curKF_iter= pCurrentMap->keyFrameList.begin();
            advance(curKF_iter, curKF_global_index);
            KeyFrame* pCurKF;
            if(curKF_global_index<pCurrentMap->keyFrameList.size()){
                pCurKF=(*curKF_iter);
                if(pCurKF->global_index!=curKF_global_index){
                    assert(false);
                }
            }
            else{
                assert(false);
            }
//            setIMUModel(pCurKF->c->FOCUS_LENGTH_X_server);// 该传哪一个fx给重投影误差因子图  这里是其它地图 如果优化是自己求导，要设置的一个权重
            
            int mainKF_global_index=cur_globalFuse_index[client_id].first;
            list<KeyFrame*>::iterator mainKF_iter= pMergeMap->keyFrameList.begin();
            advance(mainKF_iter, mainKF_global_index);
            KeyFrame* pMergeKF_main;
            if(mainKF_global_index<pMergeMap->keyFrameList.size()){
                pMergeKF_main=(*mainKF_iter);
                if(pMergeKF_main->global_index!=mainKF_global_index){
                    assert(false);
                }
            }
            else{
                assert(false);
            }
//            pCurrentMap->isFirstFusion_globalMutex.unlock();
             
            //更新共视关键帧的一个过程
            
            unique_lock<mutex> lock_curMap(pCurrentMap->mMutexkeyFrameList);
            int keyFrame_num_cur=pCurrentMap->keyFrameList.size();
            lock_curMap.unlock();
            
            
            unique_lock<mutex> lock_mainMap(pMergeMap->mMutexkeyFrameList);
            int keyFrame_num_main=pMergeMap->keyFrameList.size();
            lock_mainMap.unlock();
            

            
            //这里代表的是 第2个世界坐标系 到 a的相机坐标系
            Matrix3f R_relative_best=r_ca_w2_cur[client_id];
            Vector3f T_relative_best=t_ca_w2_cur[client_id];
            
            int max_local=10;
            int min_local=2;
            int front_max=9;//包括当前帧 如果后面没有帧，再往前填充1帧
            //先保证两个地图里面都有至少10帧 才做融合的优化
            if(keyFrame_num_cur>=min_local && keyFrame_num_main>=min_local){//这个其实一定满足 因为第一帧 没有前一帧，是检测不出来的
                //当前关键帧和它的邻居 他们看到的地图点
                list<KeyFrame*> spLocalWindowKFs;
                //主地图
                list<KeyFrame*> spMergeConnectedKFs;
                //设想是 前面取7帧 后面取2帧 加上自己，总共10帧
                //其中固定4帧 至少要固定2帧，而且必须固定不能大于当前帧的
                //-------------------------------------第2个数据----取当前帧附近参与优化的帧 前面8-9个
                //设定当前帧前面至少要有两个帧
                
//                pCurrentMap->mMutexkeyFrameList.lock();
                KeyFrame* pKFi = pCurKF;
                list<KeyFrame*>::iterator pKFi_iter=curKF_iter;
                int nInserted = 0;
                 
                while(pKFi!=pCurrentMap->keyFrameList.front() && nInserted<front_max){
                    spLocalWindowKFs.push_front(pKFi);
                    advance(pKFi_iter, -1);
                    pKFi=*pKFi_iter;
                    nInserted++;
                }
                if(nInserted<front_max){
                    spLocalWindowKFs.push_front(pKFi);
                    nInserted++;
                }
                int optimizer_less=max_local-nInserted;
                
                KeyFrame* pKFi_right = pCurKF;
                list<KeyFrame*>::iterator pKFi_iter_right = curKF_iter;
                std::advance (pKFi_iter_right,1);
                nInserted=0;
                if(pKFi_right!=pCurrentMap->keyFrameList.back()){
                    pKFi_right=*pKFi_iter_right;
                    for( ;nInserted<optimizer_less && pKFi_right!=pCurrentMap->keyFrameList.back() ;nInserted++){
                        spLocalWindowKFs.push_back(pKFi_right);
                        std::advance (pKFi_iter_right,1);
                        pKFi_right=*pKFi_iter_right;
                    }
                    
                    if(nInserted<optimizer_less){
                        spLocalWindowKFs.push_back(pKFi_right);
                        nInserted++;
                        //说明后面的帧不够 往前面补充
                        optimizer_less-=nInserted;
                        nInserted=0;
                        std::advance (pKFi_iter,-1);
                        for(;nInserted<optimizer_less && pKFi!=pCurrentMap->keyFrameList.front();nInserted++){
                            pKFi=*pKFi_iter;
                            spLocalWindowKFs.push_front(pKFi);
                            advance(pKFi_iter, -1);
                        }
                       
                    }
                }
                

//                pCurrentMap->mMutexkeyFrameList.unlock();
                
             
                //-------------------------------------第1个数据----去主地图发生融合帧附近参与优化的帧 主地图前面4个 后面5个
                
//                pMergeMap->mMutexkeyFrameList.lock();
                pKFi = pMergeKF_main;
                pKFi_iter=mainKF_iter;
                nInserted = 0;
                
                while(pKFi!=pMergeMap->keyFrameList.front() && nInserted<front_max){
                    spMergeConnectedKFs.push_front(pKFi);
                    advance(pKFi_iter, -1);
                    pKFi=*pKFi_iter;
                    nInserted++;
                }
                if(nInserted<front_max){
                    spMergeConnectedKFs.push_front(pKFi);
                    nInserted++;
                }
                optimizer_less=max_local-nInserted;
//                cout<<"optimizer_less="<<optimizer_less<<endl;
                pKFi_right = pMergeKF_main;
                pKFi_iter_right=mainKF_iter;
                std::advance (pKFi_iter_right,1);
                nInserted=0;
                if(pKFi_right!=pMergeMap->keyFrameList.back()){
                    pKFi_right=*pKFi_iter_right;
                    for( ;nInserted<optimizer_less && pKFi_right!=pMergeMap->keyFrameList.back()  ;nInserted++){
                        spMergeConnectedKFs.push_back(pKFi_right);
                        std::advance (pKFi_iter_right,1);
                        pKFi_right=*pKFi_iter_right;
                    }
                }
                if(nInserted<optimizer_less){
                    spMergeConnectedKFs.push_back(pKFi_right);
                    nInserted++;
                    //说明后面的帧不够 往前面补充
                    optimizer_less-=nInserted;
                    nInserted=0;
                    std::advance (pKFi_iter,-1);
                    for(;nInserted<optimizer_less && pKFi!=pMergeMap->keyFrameList.front();nInserted++){
                        pKFi=*pKFi_iter;
                        spMergeConnectedKFs.push_front(pKFi);
                        advance(pKFi_iter, -1);
                    }
                  
                }
//                pMergeMap->mMutexkeyFrameList.unlock();

                
                //改成 其它地图的3D点 主地图的2D点
                Fuse_6_2_2( R_relative_best, T_relative_best, spLocalWindowKFs,spMergeConnectedKFs, pMergeKF_main, 50);
                 cout<<"用于计算重投影误差的特征点的数量"<<pointsCloud_old_all.size()<<endl;
                 if(pointsCloud_old_all.size()<2){
                     if(isFirstFusion[client_id]==4){
                         isFirstFusion[client_id]=0;
                     }else if(isFirstFusion[client_id]==5){
                         isFirstFusion[client_id]=1;
                     }else if(isFirstFusion[client_id]==6){
                         isFirstFusion[client_id]=3;
                     }
                     pCurrentMap->isFirstFusion_globalMutex.unlock();
                     continue;
                 }
                 
                 int max_length=20;
                 double t_array[max_length][3];
                 Quaterniond q_array[max_length];
                 double euler_array[max_length][3];

                 //这里存的是 不在局部窗口中的帧的位姿
                 int kf_old_num=0;
                 double t_array_old[max_length][3];
                 double euler_array_old[max_length][3];
                //请求每个地图自己的全局优化结束 和大地图的全局优化停止
                //其实更新地图位姿 是会加锁的 所以相当于加了锁
                 
                ceres::Problem problem;
                ceres::Solver::Options options;
                //options.linear_solver_type = ceres::DENSE_NORMAL_CHOLESKY;
                options.linear_solver_type = ceres::DENSE_SCHUR;
                options.minimizer_progress_to_stdout = true;
                options.max_num_iterations = 6;
                ceres::Solver::Summary summary;
                ceres::LossFunction *loss_function;
                loss_function = new ceres::HuberLoss(1.0);
                ceres::LocalParameterization* angle_local_parameterization =
                AngleLocalParameterization::Create();
                
                int startId_cur=spLocalWindowKFs.front()->global_index;//把参与优化的小地图的帧序号转到0-10之间
                          
                //上面再改改 保持spFixedKFs spLocalWindowKFs有序 已经保持有序
           
                
                
                double t_c1_w2[3];
                double r_c1_w2[3];
    //
                t_c1_w2[0]=T_relative_best(0);
                t_c1_w2[1]=T_relative_best(1);
                t_c1_w2[2]=T_relative_best(2);
                Vector3d euler_angle=Utility::R2ypr(R_relative_best.cast<double>());
                r_c1_w2[0]=euler_angle.x();
                r_c1_w2[1]=euler_angle.y();
                r_c1_w2[2]=euler_angle.z();
                problem.AddParameterBlock(r_c1_w2, 3);
                problem.AddParameterBlock(t_c1_w2, 3);
                 
                //添加相机-imu之间的外参
                //因为是固定的 可以不当做优化参数
                Client* c_main= pMergeKF_main->c;
//                Matrix3d ric_main=c_main->ric_client;
//                Vector3d tic_main=c_main->tic_client;
//                Vector3d euler_angle_ric=Utility::R2ypr(ric_main);
     
                double cx=c_main->PX_server;
                double cy=c_main->PY_server;
                double fx=c_main->FOCUS_LENGTH_X_server;
                double fy=c_main->FOCUS_LENGTH_Y_server;
                //这里其实是 新帧的3D点 老帧的2D点
                for (int i=0,j=pointsCloud_old_all.size();i<j;i++)
               {
                   vector<Eigen::Vector3d> pointsCloud_old_3d_test=pointsCloud_old_all[i];
                   vector<cv::Point2f> measurements_cur_2d_test=measurements_cur_all[i];//像素坐标
                   int index=kf_index_all[i];
                   Matrix3d r_cn_c1=r_cn_c1_all[index];
                   Vector3d euler_cn_c1=Utility::R2ypr(r_cn_c1);
                   Vector3d t_cn_c1=t_cn_c1_all[index];
                   

                   for(int a=0,b=pointsCloud_old_3d_test.size();a<b;a++){
                       //找到主地图那个点 所在帧的位姿
                       Vector3d pts_i = pointsCloud_old_3d_test[a];

                       cv::Point2f pt=measurements_cur_2d_test[a];
                       float xx=pt.x;
                       float yy=pt.y;

                       double xxxx=(xx-cx)/fx;
                       double yyyy=(yy-cy)/fy;
                       double zzzz=1.0;
                        Vector3d pts_j ;//要求是归一化图像坐标
                        pts_j<<xxxx,yyyy,zzzz;

                       ceres::CostFunction* cost_function = FourDOFWeightError_reprojection3::Create( pts_i.x(), pts_i.y(), pts_i.z(),pts_j.x(), pts_j.y(), pts_j.z(),euler_cn_c1.x(), euler_cn_c1.y(), euler_cn_c1.z(), t_cn_c1.x(), t_cn_c1.y(), t_cn_c1.z(),20.0);
                       problem.AddResidualBlock(cost_function, loss_function, r_c1_w2, t_c1_w2);
                    }

                }

            
                
                ceres::Solve(options, &problem, &summary);
                std::cout <<"ceres summary:"<< summary.BriefReport()<< "\n";
                
               T_relative_best[0]=t_c1_w2[0];
               T_relative_best[1]=t_c1_w2[1];
               T_relative_best[2]=t_c1_w2[2];
               euler_angle[0]=r_c1_w2[0];
               euler_angle[1]=r_c1_w2[1];
               euler_angle[2]=r_c1_w2[2];
               R_relative_best=Utility::ypr2R(Eigen::Vector3d(euler_angle[0],euler_angle[1],euler_angle[2])).cast<float>();
                
                
//                Matrix3d r_c1_w2=R_relative_best.cast<double>();
//                Vector3d t_c1_w2=T_relative_best.cast<double>();
                Matrix3f r_w2_i1;
                Vector3f t_w2_i1;
                pMergeKF_main->cam2Imu(T_relative_best, R_relative_best, t_w2_i1 , r_w2_i1);
                
//                Matrix3d r_test;
//                Vector3d t_test;
//                pMergeKF_main->getOriginPose(t_test, r_test);
                
                Matrix3d r_w2_i2;
                Vector3d t_w2_i2;
                pCurKF->getOriginPose(t_w2_i2, r_w2_i2);
                Matrix3f r_w2_i2_f;
                Vector3f t_w2_i2_f;
                r_w2_i2_f=r_w2_i2.cast<float>();
                t_w2_i2_f=t_w2_i2.cast<float>();


//r_i1_i2
                Vector3d relative_t = r_w2_i1.cast<double>().transpose() * (t_w2_i2 - t_w2_i1.cast<double>());
                Matrix3d relative_r = r_w2_i1.cast<double>().transpose() * r_w2_i2;


                Quaterniond relative_q;
                relative_q=relative_r;
                
                
                double relative_yaw = Utility::normalizeAngle(Utility::R2ypr(r_w2_i2).x() - Utility::R2ypr(r_w2_i1.cast<double>()).x());
                double relative_pitch = Utility::normalizeAngle(Utility::R2ypr(r_w2_i2).y() - Utility::R2ypr(r_w2_i1.cast<double>()).y());
                double relative_roll = Utility::normalizeAngle(Utility::R2ypr(r_w2_i2).z() - Utility::R2ypr(r_w2_i1.cast<double>()).z());
                
                
                 if(relative_t.norm()>10 || abs(relative_yaw)>30){
                    cout<<"变化太大了"<<endl;
                    if(isFirstFusion[client_id]==4){
                        isFirstFusion[client_id]=0;
                    }else if(isFirstFusion[client_id]==5){
                        isFirstFusion[client_id]=1;
                    }else if(isFirstFusion[client_id]==6){
                        isFirstFusion[client_id]=3;
                        pCurrentMap->start_global_fuse_opti_mutex.lock();
                        pCurrentMap->start_global_fuse_opti=1;
                        pCurrentMap->start_global_fuse_opti_mutex.unlock();
                    }else{
                        assert(false);//都已经找到最老的回环了，竟然还没有记录已经发生过回环了
                    }
                    pCurrentMap->isFirstFusion_globalMutex.unlock();

                    continue;
                }
                
                //加一个判断 防止过拟合 好像没法加
                
                               
                pCurKF->update_globalLoopConnection(relative_t, relative_q, relative_yaw);
                pCurKF->global_relative_pitch=relative_pitch;
                pCurKF->global_relative_roll=relative_roll;
                pCurKF->detect_globalLoop(mainKF_global_index);
                pMergeKF_main->is_detected_globalLoop(curKF_global_index);
                
                pCurrentMap->is_fusion=1;
                
                
 
               //找到了
                int has_fusion_num=isFirstFusion[client_id];
                if(has_fusion_num==4){
                    isFirstFusion[client_id]=1;
                }else if(has_fusion_num==5){
                    isFirstFusion[client_id]=3;
                    //这里说明地图已经融合了 可以检测是不是 过拟合了
                    
                    Matrix3d r_w1_i1;
                    Vector3d t_w1_i1;
                    pMergeKF_main->getOriginPose(t_w1_i1, r_w1_i1);
                    
                    Matrix3d r_w1_i2;
                    Vector3d t_w1_i2;
                    pCurKF->getPose(t_w1_i2, r_w1_i2);
                    
                    Matrix3d r_i1_i2;
                    Vector3d t_i1_i2;
                    r_i1_i2= r_w1_i1.transpose()*r_w1_i2;
                    t_i1_i2= r_w1_i1.transpose()*(t_w1_i2-t_w1_i1);
                    double relative_yaw_2=Utility::normalizeAngle(Utility::R2ypr(r_w1_i2).x()-Utility::R2ypr(r_w1_i1).x());
                    
                    Vector3d real_t=-relative_r*r_i1_i2.transpose()*t_i1_i2+relative_t;
                    double real_yaw_test_test=relative_yaw_2-relative_yaw;

                    cout<<fixed<<setprecision(6)<<"打印一下相差多少："<<real_t.norm()<<" "<<real_yaw_test_test<<endl;
                    if(real_t.norm()<0.03 && abs(real_yaw_test_test)<1.5){
                        pCurKF->isRemove_globalLoop=true;
                        
                    }
                    
                    
                }
                else if(has_fusion_num==6){
                    isFirstFusion[client_id]=3;
                    
                    //这里说明地图已经融合了 可以检测是不是 过拟合了
                    
                    Matrix3d r_w1_i1;
                    Vector3d t_w1_i1;
                    pMergeKF_main->getOriginPose(t_w1_i1, r_w1_i1);
                    
                    Matrix3d r_w1_i2;
                    Vector3d t_w1_i2;
                    pCurKF->getPose(t_w1_i2, r_w1_i2);
                    
                    Matrix3d r_i1_i2;
                    Vector3d t_i1_i2;
                    r_i1_i2= r_w1_i1.transpose()*r_w1_i2;
                    t_i1_i2= r_w1_i1.transpose()*(t_w1_i2-t_w1_i1);
                    double relative_yaw_2=Utility::normalizeAngle(Utility::R2ypr(r_w1_i2).x()-Utility::R2ypr(r_w1_i1).x());
                    
                    Vector3d real_t=-relative_r*r_i1_i2.transpose()*t_i1_i2+relative_t;
                    double real_yaw_test_test=relative_yaw_2-relative_yaw;

                    cout<<fixed<<setprecision(6)<<"打印一下相差多少："<<real_t.norm()<<" "<<real_yaw_test_test<<endl;
                    if(real_t.norm()<0.03 && abs(real_yaw_test_test)<1.5){
                        pCurKF->isRemove_globalLoop=true;
                        
                    }
                }else{
                    assert(false);//都已经找到最老的回环了，竟然还没有记录已经发生过回环了
                }
                   
                //思考一下赋值
                std::pair<int, int> latest_index_test= latest_global_loop_index[client_id];
                int latest_index_main_test=latest_index_test.first;
                int latest_index_cur_test=latest_index_test.second;
                latest_index_main_test=latest_index_main_test>mainKF_global_index?latest_index_main_test:mainKF_global_index;
                latest_index_cur_test=latest_index_cur_test>curKF_global_index?latest_index_cur_test:curKF_global_index;
                latest_global_loop_index[client_id]=std::make_pair(latest_index_main_test, latest_index_cur_test);
                //记录主地图和其它地图最早的融合位置
                if(earliest_global_loop_index[client_id]==-1 || earliest_global_loop_index[client_id]>mainKF_global_index){
                    earliest_global_loop_index[client_id]=mainKF_global_index;
                }
                pCurrentMap->isFirstFusion_globalMutex.unlock();
                
                pCurrentMap->start_global_fuse_opti_mutex.lock();
                pCurrentMap->start_global_fuse_opti=1;
                pCurrentMap->start_global_fuse_opti_mutex.unlock();
            }
            else{
                pCurrentMap->isFirstFusion_globalMutex.unlock();
            }
        }
        }else{
//            poseGraphGlobal_mutex.unlock();
            readWriteLock.readUnLock();
            usleep(2000);
        }
        usleep(30);
    }
}



void PoseGraphGlobal::addPoseGraph(int clientID,PoseGraph *poseGraph){
    readWriteLock.writeLock();
        
//    poseGraphGlobal_mutex.lock();
    PoseGraphGloabl_map.insert(make_pair(clientID, poseGraph));
//    poseGraphGlobal_mutex.unlock();
    readWriteLock.writeUnLock();
}

PoseGraph* PoseGraphGlobal::getMainPoseGraph(){
//    poseGraphGlobal_mutex.lock();
    readWriteLock.readLock();
    for(auto iter=PoseGraphGloabl_map.begin(),iter_end=PoseGraphGloabl_map.end();iter!=iter_end;iter++){
        if((*iter).first == mainClientID){
//            poseGraphGlobal_mutex.unlock();
            readWriteLock.readUnLock();
            return (*iter).second;
        }
    }
//    poseGraphGlobal_mutex.unlock();
    readWriteLock.readUnLock();
    return nullptr;
    
}




//在这里加一个 去除外点操作
//这里主地图加入的是世界坐标 小地图加入的是图像坐标
void PoseGraphGlobal::Fuse_4_1( Matrix3f R_relative_best,Vector3f T_relative_best, list<KeyFrame*> spLocalWindowKFs, list<KeyFrame*> spFixedKFs, list<KeyFrame*> spMergeConnectedKFs, float th)
{
    
    KeyFrame* pKF_cur=*(spLocalWindowKFs.begin());
    Client* client_cur=pKF_cur->c;
    
    Matrix3d ric_curClient=client_cur->ric_client;
    Vector3d tic_curClient=client_cur->tic_client;
    Matrix3d rwi_cur;
    Vector3d twi_cur;
    
    const float &fx = client_cur->FOCUS_LENGTH_X_server;
    const float &fy = client_cur->FOCUS_LENGTH_Y_server;
    const float &cx = client_cur->PX_server;
    const float &cy = client_cur->PY_server;
    
    curKF_id_all.clear();
    pointsCloud_old_all.clear();
    measurements_cur_all.clear();
    
    int num=0;
    
    for(auto iter=spLocalWindowKFs.begin(),iter_end=spLocalWindowKFs.end(); iter!=iter_end;iter++){
        pKF_cur=(*iter);
        
        pKF_cur->getPose(twi_cur, rwi_cur);
        //这个是从主地图的世界坐标系-到-小地图的相机坐标系 目前写的是到imu坐标系 .cast<float>()
        
        Matrix3f R_w1i2=R_relative_best.transpose()*rwi_cur.cast<float>();
        Vector3f T_w1i2=R_relative_best.transpose()*(twi_cur.cast<float>()-T_relative_best);
        Matrix3f R_w1c2=R_w1i2*ric_curClient.cast<float>();
        Vector3f T_w1c2=R_w1i2*tic_curClient.cast<float>()+T_w1i2;
        Matrix3f R_c2w1=R_w1c2.transpose();
        Vector3f T_c2w1=-R_c2w1*T_w1c2;
        Matrix3f Rc2w1 =R_c2w1;
        Vector3f tc2w1 =T_c2w1;
 
        vector<Eigen::Vector3d> point_clouds_origin_cur= pKF_cur->point_clouds_origin;
        vector<int> feature_id_origin_cur=pKF_cur->features_id_origin;
        vector<cv::KeyPoint> keypoints_cur=pKF_cur->keypoints;
        const int nPoints = point_clouds_origin_cur.size();
        const int point2D_len_cur=keypoints_cur.size()-point_clouds_origin_cur.size();
        
        bool point_main_inFeature=false;//false表示主地图和小地图的点都还没被加入feature中，true表示主地图这个点已经被加入feature中，但是小地图的没有加入。对应的小地图的帧也已经被加入到feature，这种直接结束
        
        for(KeyFrame* pKF:spMergeConnectedKFs){
            vector<Eigen::Vector3d> point_clouds_origin_main=pKF->point_clouds_origin;
            std::vector<cv::Point2f> measurements_origin_main=pKF->measurements_origin;
            vector<int> feature_id_origin_main=pKF->features_id_origin;
             
            const int point_len_main=point_clouds_origin_main.size();
            const int point2D_len_main=pKF->keypoints.size()-point_len_main;
            
            for(int i=0;i<point_len_main;i++){
                Vector3d point_main=point_clouds_origin_main[i];
                
                
                
                //把主地图下 世界坐标系的点 转到小地图上一帧的图像坐标系上
                Vector3f p3D_c2=Rc2w1*point_main.cast<float>()+tc2w1;
               
                //深度必须为正
                if(p3D_c2[2]<0.0f || p3D_c2[2]>30){
//                    cout<<"深度不为正"<<endl;
                    continue;
                }
//                        cout<<fixed<<setprecision(6)<<"测试 深度 两种算法"<<p3D_c2<<" 和 "<<dep_j<<endl;
                    
                // 投影到图像上
                const float x = p3D_c2[0];
                const float y = p3D_c2[1];
                const float z = p3D_c2[2];

                //这里可能得加一个畸变校正 应该可以不用去校正 把他投影在一个没有畸变的图像上
                const float u=fx*x/z+cx;
                const float v=fy*y/z+cy;
                
                
                if(!pKF_cur->isInImage(u, v)){
//                    cout<<"投影点不在图像内"<<endl;
                    continue;
                }
                
                const vector<int> vIndices=pKF_cur->GetFeaturesInArea_1(u, v, th);
                if(vIndices.empty()){
//                    cout<<"半径为10个像素 找不到点"<<endl;
                    continue;
                }
                
                //找在这个半径内最相似的 这里可能有些问题 因为3D点的描述子 个人感觉有问题
                BRIEF::bitset point_main_des=pKF->descriptors[point2D_len_main+i];
                int bestDist = 256;
                int bestIndex = -1;
                for(vector<int>::const_iterator vit=vIndices.begin(), vit_end=vIndices.end(); vit!=vit_end; vit++)
                {
//                    cout<<"*vit"<<*vit<<endl;发现 keypoints数量不等于des数量
                    int dis = pKF_cur->HammingDis(point_main_des, pKF_cur->descriptors[*vit]);
                    if(dis < bestDist)
                    {
                        bestDist = dis;
                        bestIndex = *vit;
                    }
                }
                
                if(bestDist<=TH_LOW){
                    pointsCloud_old_3d.push_back(point_main);
                    measurements_cur_2d.push_back(keypoints_cur[bestIndex].pt);
                    measurements_old_2d.push_back(measurements_origin_main[i]);
                    
                }
                              
            }
            
            pKF_cur->rejectWithF_server_mapFuse(measurements_old_2d, measurements_cur_2d,pointsCloud_old_3d);
            
            if(pointsCloud_old_3d.size()>=22){//这个阈值 还要考虑
                curKF_id_all.push_back(pKF_cur->global_index);
                pointsCloud_old_all.push_back(pointsCloud_old_3d);
                measurements_cur_all.push_back(measurements_cur_2d);
                num+=pointsCloud_old_3d.size();
            }
            measurements_old_2d.clear();
            measurements_cur_2d.clear();
            pointsCloud_old_3d.clear();
        }
    }
    
    cout<<"通过再投影算出来的点数："<<num<<endl;
    
    
    
    for(auto iter=spFixedKFs.begin(),iter_end=spFixedKFs.end(); iter!=iter_end;iter++){
        pKF_cur=(*iter);
        
        pKF_cur->getPose(twi_cur, rwi_cur);
        //这个是从主地图的世界坐标系-到-小地图的相机坐标系 目前写的是到imu坐标系 .cast<float>()
        
        Matrix3f R_w1i2=R_relative_best.transpose()*rwi_cur.cast<float>();
       Vector3f T_w1i2=R_relative_best.transpose()*(twi_cur.cast<float>()-T_relative_best);
       Matrix3f R_w1c2=R_w1i2*ric_curClient.cast<float>();
       Vector3f T_w1c2=R_w1i2*tic_curClient.cast<float>()+T_w1i2;
       Matrix3f R_c2w1=R_w1c2.transpose();
       Vector3f T_c2w1=-R_c2w1*T_w1c2;
        Matrix3f Rc2w1 =R_c2w1;
        Vector3f tc2w1 =T_c2w1;
            
        vector<Eigen::Vector3d> point_clouds_origin_cur= pKF_cur->point_clouds_origin;
        vector<int> feature_id_origin_cur=pKF_cur->features_id_origin;
        vector<cv::KeyPoint> keypoints_cur=pKF_cur->keypoints;
        const int nPoints = point_clouds_origin_cur.size();
        const int point2D_len_cur=keypoints_cur.size()-point_clouds_origin_cur.size();
        
        bool point_main_inFeature=false;//false表示主地图和小地图的点都还没被加入feature中，true表示主地图这个点已经被加入feature中，但是小地图的没有加入。对应的小地图的帧也已经被加入到feature，这种直接结束
        
        
        for(KeyFrame* pKF:spMergeConnectedKFs){
            vector<Eigen::Vector3d> point_clouds_origin_main=pKF->point_clouds_origin;
            vector<cv::Point2f> measurements_origin_main=pKF->measurements_origin;
            vector<int> feature_id_origin_main=pKF->features_id_origin;
                 
            const int point_len_main=point_clouds_origin_main.size();
            const int point2D_len_main=pKF->keypoints.size()-point_len_main;
            
            for(int i=0;i<point_len_main;i++){
                Vector3d point_main=point_clouds_origin_main[i];
                                     
                //把主地图下 世界坐标系的点 转到小地图上一帧的图像坐标系上
                Vector3f p3D_c2=Rc2w1*point_main.cast<float>()+tc2w1;
                
                //深度必须为正
                if(p3D_c2[2]<0.0f || p3D_c2[2]>30){
//                    cout<<"深度不为正"<<endl;
                    continue;
                }
                    
                // 投影到图像上
                const float x = p3D_c2[0];
                const float y = p3D_c2[1];
                const float z = p3D_c2[2];

                //这里可能得加一个畸变校正 应该可以不用去校正 把他投影在一个没有畸变的图像上
                const float u=fx*x/z+cx;
                const float v=fy*y/z+cy;
                
                
                if(!pKF_cur->isInImage(u, v)){
//                    cout<<"投影点不在图像内"<<endl;
                    continue;
                }
                
                const vector<int> vIndices=pKF_cur->GetFeaturesInArea_1(u, v, th);
                if(vIndices.empty()){
//                    cout<<"半径为10个像素 找不到点"<<endl;
                    continue;
                }
                
                //找在这个半径内最相似的 这里可能有些问题 因为3D点的描述子 个人感觉有问题
                BRIEF::bitset point_main_des=pKF->descriptors[point2D_len_main+i];
                int bestDist = 256;
                int bestIndex = -1;
                for(vector<int>::const_iterator vit=vIndices.begin(), vit_end=vIndices.end(); vit!=vit_end; vit++)
                {
//                    cout<<"*vit"<<*vit<<endl;发现 keypoints数量不等于des数量
                    int dis = pKF_cur->HammingDis(point_main_des, pKF_cur->descriptors[*vit]);
                    if(dis < bestDist)
                    {
                        bestDist = dis;
                        bestIndex = *vit;
                    }
                }
                    
                if(bestDist<=TH_LOW){
                    pointsCloud_old_3d.push_back(point_main);
                    measurements_cur_2d.push_back(keypoints_cur[bestIndex].pt);
                    measurements_old_2d.push_back(measurements_origin_main[i]);
                }
                
            }
        
            pKF_cur->rejectWithF_server_mapFuse(measurements_old_2d, measurements_cur_2d,pointsCloud_old_3d);
            
            if(pointsCloud_old_3d.size()>=22){
                curKF_id_all.push_back(pKF_cur->global_index);
                pointsCloud_old_all.push_back(pointsCloud_old_3d);
                measurements_cur_all.push_back(measurements_cur_2d);
            }
            measurements_old_2d.clear();
            measurements_cur_2d.clear();
            pointsCloud_old_3d.clear();
            
        }
              
    }
}

void PoseGraphGlobal::Fuse_4_1_2( Matrix3f R_relative_best,Vector3f T_relative_best, list<KeyFrame*> spLocalWindowKFs,  list<KeyFrame*> spMergeConnectedKFs, float th)
{
    
    KeyFrame* pKF_cur=*(spLocalWindowKFs.begin());
    Client* client_cur=pKF_cur->c;
    
    Matrix3d ric_curClient=client_cur->ric_client;
    Vector3d tic_curClient=client_cur->tic_client;
    Matrix3d rwi_cur;
    Vector3d twi_cur;
    
    const float &fx = client_cur->FOCUS_LENGTH_X_server;
    const float &fy = client_cur->FOCUS_LENGTH_Y_server;
    const float &cx = client_cur->PX_server;
    const float &cy = client_cur->PY_server;
    
    curKF_id_all.clear();
    pointsCloud_old_all.clear();
    measurements_cur_all.clear();
    
    int num=0;
    
    for(auto iter=spLocalWindowKFs.begin(),iter_end=spLocalWindowKFs.end(); iter!=iter_end;iter++){
        pKF_cur=(*iter);
        
        if(!pKF_cur->is_des_end)
            continue;
        
        pKF_cur->getOriginPose(twi_cur, rwi_cur);
        //这个是从主地图的世界坐标系-到-小地图的相机坐标系 目前写的是到imu坐标系 .cast<float>()
        
        Matrix3f R_w1i2=R_relative_best.transpose()*rwi_cur.cast<float>();
        Vector3f T_w1i2=R_relative_best.transpose()*(twi_cur.cast<float>()-T_relative_best);
        Matrix3f R_w1c2=R_w1i2*ric_curClient.cast<float>();
        Vector3f T_w1c2=R_w1i2*tic_curClient.cast<float>()+T_w1i2;
        Matrix3f R_c2w1=R_w1c2.transpose();
        Vector3f T_c2w1=-R_c2w1*T_w1c2;
        Matrix3f Rc2w1 =R_c2w1;
        Vector3f tc2w1 =T_c2w1;
 
        vector<Eigen::Vector3d> point_clouds_origin_cur= pKF_cur->point_clouds_origin;
        vector<int> feature_id_origin_cur=pKF_cur->features_id_origin;
        vector<cv::KeyPoint> keypoints_cur=pKF_cur->keypoints;
        const int nPoints = point_clouds_origin_cur.size();
        const int point2D_len_cur=keypoints_cur.size()-point_clouds_origin_cur.size();
        
        bool point_main_inFeature=false;//false表示主地图和小地图的点都还没被加入feature中，true表示主地图这个点已经被加入feature中，但是小地图的没有加入。对应的小地图的帧也已经被加入到feature，这种直接结束
        
        for(KeyFrame* pKF:spMergeConnectedKFs){
            if(!pKF->is_des_end)
                continue;
            
            vector<Eigen::Vector3d> point_clouds_origin_main=pKF->point_clouds_origin;
            std::vector<cv::Point2f> measurements_origin_main=pKF->measurements_origin;
            vector<int> feature_id_origin_main=pKF->features_id_origin;
             
            const int point_len_main=point_clouds_origin_main.size();
            const int point2D_len_main=pKF->keypoints.size()-point_len_main;
            
            for(int i=0;i<point_len_main;i++){
                Vector3d point_main=point_clouds_origin_main[i];
                
                
                
                //把主地图下 世界坐标系的点 转到小地图上一帧的图像坐标系上
                Vector3f p3D_c2=Rc2w1*point_main.cast<float>()+tc2w1;
               
                //深度必须为正
                if(p3D_c2[2]<0.0f || p3D_c2[2]>30){
//                    cout<<"深度不为正"<<endl;
                    continue;
                }
//                        cout<<fixed<<setprecision(6)<<"测试 深度 两种算法"<<p3D_c2<<" 和 "<<dep_j<<endl;
                    
                // 投影到图像上
                const float x = p3D_c2[0];
                const float y = p3D_c2[1];
                const float z = p3D_c2[2];

                //这里可能得加一个畸变校正 应该可以不用去校正 把他投影在一个没有畸变的图像上
                const float u=fx*x/z+cx;
                const float v=fy*y/z+cy;
                
                
                if(!pKF_cur->isInImage(u, v)){
//                    cout<<"投影点不在图像内"<<endl;
                    continue;
                }
                
                const vector<int> vIndices=pKF_cur->GetFeaturesInArea_1(u, v, th);
                if(vIndices.empty()){
//                    cout<<"半径为50个像素 找不到点"<<endl;
                    continue;
                }
                
                
                //des和keypoints长度不一样
                //找在这个半径内最相似的 这里可能有些问题 因为3D点的描述子 个人感觉有问题
                BRIEF::bitset point_main_des=pKF->descriptors[point2D_len_main+i];
                int bestDist = 256;
                int bestIndex = -1;
                for(vector<int>::const_iterator vit=vIndices.begin(), vit_end=vIndices.end(); vit!=vit_end; vit++)
                {
//                    cout<<"*vit"<<*vit<<endl;发现 keypoints数量不等于des数量
                    int dis = pKF_cur->HammingDis(point_main_des, pKF_cur->descriptors[*vit]);
                    if(dis < bestDist)
                    {
                        bestDist = dis;
                        bestIndex = *vit;
                    }
                }
                
                if(bestDist<=TH_LOW){
                    pointsCloud_old_3d.push_back(point_main);
                    measurements_cur_2d.push_back(keypoints_cur[bestIndex].pt);
                    measurements_old_2d.push_back(measurements_origin_main[i]);
                    
                }
                              
            }
            
            
            cout<<"计算ransac之前，在半径50个像素内,一帧3D点找到的点数："<<pointsCloud_old_3d.size()<<endl;
            if(measurements_cur_2d.size()>=8){
                pKF_cur->rejectWithF_server_mapFuse(measurements_old_2d, measurements_cur_2d,pointsCloud_old_3d);
                
                curKF_id_all.push_back(pKF_cur->global_index);
                pointsCloud_old_all.push_back(pointsCloud_old_3d);
                measurements_cur_all.push_back(measurements_cur_2d);
                num+=pointsCloud_old_3d.size();
            }
            cout<<"正序 去除内点后 两帧的匹配点数："<<pointsCloud_old_3d.size()<<endl;

            
            //这里总共只有70几个点 可以用来做匹配 一模一样图像平均30个匹配点，而且几乎没有点减少，除非本身点数低于15这种
//            if(pointsCloud_old_3d.size()>11){//这个阈值 还要考虑
//                curKF_id_all.push_back(pKF_cur->global_index);
//                pointsCloud_old_all.push_back(pointsCloud_old_3d);
//                measurements_cur_all.push_back(measurements_cur_2d);
//                num+=pointsCloud_old_3d.size();
//            }
            measurements_old_2d.clear();
            measurements_cur_2d.clear();
            pointsCloud_old_3d.clear();
        }
    }
    
    cout<<"通过再投影算出来的点数："<<num<<endl;
    
    
}


void PoseGraphGlobal::Fuse_4_2( Matrix3f R_relative_best,Vector3f T_relative_best, list<KeyFrame*> spLocalWindowKFs, list<KeyFrame*> spFixedKFs, list<KeyFrame*> spMergeConnectedKFs, float th)
{
    
    KeyFrame* pKF_main=*(spMergeConnectedKFs.begin());
    Client* client_main=pKF_main->c;
    
    Matrix3d ric_mainClient=client_main->ric_client;
    Vector3d tic_mainClient=client_main->tic_client;
    Matrix3d rwi_main;
    Vector3d twi_main;
    
    const float &fx = client_main->FOCUS_LENGTH_X_server;
    const float &fy = client_main->FOCUS_LENGTH_Y_server;
    const float &cx = client_main->PX_server;
    const float &cy = client_main->PY_server;
    
    curKF_id_all.clear();
    pointsCloud_old_all.clear();
    measurements_cur_all.clear();
    
    int num=0;
    
    for(auto iter=spMergeConnectedKFs.begin(),iter_end=spMergeConnectedKFs.end(); iter!=iter_end;iter++){
        pKF_main=(*iter);
        
        pKF_main->getPose(twi_main, rwi_main);
        //这个是从主地图的世界坐标系-到-小地图的相机坐标系 目前写的是到imu坐标系 .cast<float>()
        
        Matrix3f R_w2i1=R_relative_best*rwi_main.cast<float>();
        Vector3f T_w2i1=R_relative_best*twi_main.cast<float>()+T_relative_best;
        Matrix3f R_w2c1=R_w2i1*ric_mainClient.cast<float>();
        Vector3f T_w2c1=R_w2i1*tic_mainClient.cast<float>()+T_w2i1;
        Matrix3f R_c1w2=R_w2c1.transpose();
        Vector3f T_c1w2=-R_c1w2*T_w2c1;
        Matrix3f Rc1w2 =R_c1w2;
        Vector3f tc1w2 =T_c1w2;
 
        vector<Eigen::Vector3d> point_clouds_origin_main= pKF_main->point_clouds_origin;
        vector<int> feature_id_origin_main=pKF_main->features_id_origin;
        vector<cv::KeyPoint> keypoints_main=pKF_main->keypoints;
        const int nPoints = point_clouds_origin_main.size();
        const int point2D_len_main=keypoints_main.size()-point_clouds_origin_main.size();
        
        bool point_cur_inFeature=false;//false表示主地图和小地图的点都还没被加入feature中，true表示主地图这个点已经被加入feature中，但是小地图的没有加入。对应的小地图的帧也已经被加入到feature，这种直接结束
        
        for(KeyFrame* pKF:spLocalWindowKFs){
            vector<Eigen::Vector3d> point_clouds_origin_cur=pKF->point_clouds_origin;
            std::vector<cv::Point2f> measurements_origin_cur=pKF->measurements_origin;
            vector<int> feature_id_origin_cur=pKF->features_id_origin;
             
            const int point_len_cur=point_clouds_origin_cur.size();
            const int point2D_len_cur=pKF->keypoints.size()-point_len_cur;
            
            for(int i=0;i<point_len_cur;i++){
                Vector3d point_cur=point_clouds_origin_cur[i];
                
                
                
                //把主地图下 世界坐标系的点 转到小地图上一帧的图像坐标系上
                Vector3f p3D_c1=Rc1w2*point_cur.cast<float>()+tc1w2;
               
                //深度必须为正
                if(p3D_c1[2]<0.0f || p3D_c1[2]>30){
//                    cout<<"深度不为正"<<endl;
                    continue;
                }
//                        cout<<fixed<<setprecision(6)<<"测试 深度 两种算法"<<p3D_c2<<" 和 "<<dep_j<<endl;
                    
                // 投影到图像上
                const float x = p3D_c1[0];
                const float y = p3D_c1[1];
                const float z = p3D_c1[2];

                //这里可能得加一个畸变校正 应该可以不用去校正 把他投影在一个没有畸变的图像上
                const float u=fx*x/z+cx;
                const float v=fy*y/z+cy;
                
                
                if(!pKF_main->isInImage(u, v)){
//                    cout<<"投影点不在图像内"<<endl;
                    continue;
                }
                
                const vector<int> vIndices=pKF_main->GetFeaturesInArea_1(u, v, th);
                if(vIndices.empty()){
//                    cout<<"半径为10个像素 找不到点"<<endl;
                    continue;
                }
                
                //找在这个半径内最相似的 这里可能有些问题 因为3D点的描述子 个人感觉有问题
                BRIEF::bitset point_cur_des=pKF->descriptors[point2D_len_cur+i];
                int bestDist = 256;
                int bestIndex = -1;
                for(vector<int>::const_iterator vit=vIndices.begin(), vit_end=vIndices.end(); vit!=vit_end; vit++)
                {
//                    cout<<"*vit"<<*vit<<endl;发现 keypoints数量不等于des数量
                    int dis = pKF_main->HammingDis(point_cur_des, pKF_main->descriptors[*vit]);
                    if(dis < bestDist)
                    {
                        bestDist = dis;
                        bestIndex = *vit;
                    }
                }
                
                if(bestDist<=TH_LOW){
                    pointsCloud_old_3d.push_back(point_cur);
                    measurements_cur_2d.push_back(keypoints_main[bestIndex].pt);
                    measurements_old_2d.push_back(measurements_origin_cur[i]);
                    
                }
                              
            }
            
            pKF_main->rejectWithF_server_mapFuse(measurements_old_2d, measurements_cur_2d,pointsCloud_old_3d);
            if(pointsCloud_old_3d.size()>=22){//这个阈值 还要考虑
                curKF_id_all.push_back(pKF_main->global_index);
                pointsCloud_old_all.push_back(pointsCloud_old_3d);
                measurements_cur_all.push_back(measurements_cur_2d);
                num+=pointsCloud_old_3d.size();
            }
            
            measurements_old_2d.clear();
            measurements_cur_2d.clear();
            pointsCloud_old_3d.clear();
        }
                        
            
        point_cur_inFeature=false;//false表示主地图和小地图的点都还没被加入feature中，true表示主地图这个点已经被加入feature中，但是小地图的没有加入。对应的小地图的帧也已经被加入到feature，这种直接结束
        
        for(KeyFrame* pKF:spFixedKFs){
            vector<Eigen::Vector3d> point_clouds_origin_cur=pKF->point_clouds_origin;
            std::vector<cv::Point2f> measurements_origin_cur=pKF->measurements_origin;
            vector<int> feature_id_origin_cur=pKF->features_id_origin;
             
            const int point_len_cur=point_clouds_origin_cur.size();
            const int point2D_len_cur=pKF->keypoints.size()-point_len_cur;
            
            for(int i=0;i<point_len_cur;i++){
                Vector3d point_cur=point_clouds_origin_cur[i];
                
                
                
                //把主地图下 世界坐标系的点 转到小地图上一帧的图像坐标系上
                Vector3f p3D_c1=Rc1w2*point_cur.cast<float>()+tc1w2;
               
                //深度必须为正
                if(p3D_c1[2]<0.0f || p3D_c1[2]>30){
//                    cout<<"深度不为正"<<endl;
                    continue;
                }
//                        cout<<fixed<<setprecision(6)<<"测试 深度 两种算法"<<p3D_c2<<" 和 "<<dep_j<<endl;
                    
                // 投影到图像上
                const float x = p3D_c1[0];
                const float y = p3D_c1[1];
                const float z = p3D_c1[2];

                //这里可能得加一个畸变校正 应该可以不用去校正 把他投影在一个没有畸变的图像上
                const float u=fx*x/z+cx;
                const float v=fy*y/z+cy;
                
                
                if(!pKF_main->isInImage(u, v)){
//                    cout<<"投影点不在图像内"<<endl;
                    continue;
                }
                
                const vector<int> vIndices=pKF_main->GetFeaturesInArea_1(u, v, th);
                if(vIndices.empty()){
//                    cout<<"半径为10个像素 找不到点"<<endl;
                    continue;
                }
                
                //找在这个半径内最相似的 这里可能有些问题 因为3D点的描述子 个人感觉有问题
                BRIEF::bitset point_cur_des=pKF->descriptors[point2D_len_cur+i];
                int bestDist = 256;
                int bestIndex = -1;
                for(vector<int>::const_iterator vit=vIndices.begin(), vit_end=vIndices.end(); vit!=vit_end; vit++)
                {
//                    cout<<"*vit"<<*vit<<endl;发现 keypoints数量不等于des数量
                    int dis = pKF_main->HammingDis(point_cur_des, pKF_main->descriptors[*vit]);
                    if(dis < bestDist)
                    {
                        bestDist = dis;
                        bestIndex = *vit;
                    }
                }
                
                if(bestDist<=TH_LOW){
                    pointsCloud_old_3d.push_back(point_cur);
                    measurements_cur_2d.push_back(keypoints_main[bestIndex].pt);
                    measurements_old_2d.push_back(measurements_origin_cur[i]);
                    
                }
                              
            }
            
            pKF_main->rejectWithF_server_mapFuse(measurements_old_2d, measurements_cur_2d,pointsCloud_old_3d);
            
            if(pointsCloud_old_3d.size()>=22){//这个阈值 还要考虑
                curKF_id_all.push_back(pKF_main->global_index);
                pointsCloud_old_all.push_back(pointsCloud_old_3d);
                measurements_cur_all.push_back(measurements_cur_2d);
                num+=pointsCloud_old_3d.size();
            }
            
            measurements_old_2d.clear();
            measurements_cur_2d.clear();
            pointsCloud_old_3d.clear();

        }
    }
    cout<<"通过再投影算出来的点数："<<num<<endl;
    
}

void PoseGraphGlobal::Fuse_4_2_2( Matrix3f R_relative_best,Vector3f T_relative_best, list<KeyFrame*> spLocalWindowKFs,  list<KeyFrame*> spMergeConnectedKFs, float th)
{
    
    KeyFrame* pKF_main=*(spMergeConnectedKFs.begin());
    Client* client_main=pKF_main->c;
    
    Matrix3d ric_mainClient=client_main->ric_client;
    Vector3d tic_mainClient=client_main->tic_client;
    Matrix3d rwi_main;
    Vector3d twi_main;
    
    const float &fx = client_main->FOCUS_LENGTH_X_server;
    const float &fy = client_main->FOCUS_LENGTH_Y_server;
    const float &cx = client_main->PX_server;
    const float &cy = client_main->PY_server;
    
    curKF_id_all.clear();
    pointsCloud_old_all.clear();
    measurements_cur_all.clear();
    
    int num=0;
    
    for(auto iter=spMergeConnectedKFs.begin(),iter_end=spMergeConnectedKFs.end(); iter!=iter_end;iter++){
        pKF_main=(*iter);
        
        if(pKF_main->is_des_end){
        pKF_main->getOriginPose(twi_main, rwi_main);
        //这个是从主地图的世界坐标系-到-小地图的相机坐标系 目前写的是到imu坐标系 .cast<float>()
        
        Matrix3f R_w2i1=R_relative_best*rwi_main.cast<float>();
        Vector3f T_w2i1=R_relative_best*twi_main.cast<float>()+T_relative_best;
        Matrix3f R_w2c1=R_w2i1*ric_mainClient.cast<float>();
        Vector3f T_w2c1=R_w2i1*tic_mainClient.cast<float>()+T_w2i1;
        Matrix3f R_c1w2=R_w2c1.transpose();
        Vector3f T_c1w2=-R_c1w2*T_w2c1;
        Matrix3f Rc1w2 =R_c1w2;
        Vector3f tc1w2 =T_c1w2;
 
        vector<Eigen::Vector3d> point_clouds_origin_main= pKF_main->point_clouds_origin;
        vector<int> feature_id_origin_main=pKF_main->features_id_origin;
        vector<cv::KeyPoint> keypoints_main=pKF_main->keypoints;
        const int nPoints = point_clouds_origin_main.size();
        const int point2D_len_main=keypoints_main.size()-point_clouds_origin_main.size();
        
        bool point_cur_inFeature=false;//false表示主地图和小地图的点都还没被加入feature中，true表示主地图这个点已经被加入feature中，但是小地图的没有加入。对应的小地图的帧也已经被加入到feature，这种直接结束
        
        for(KeyFrame* pKF:spLocalWindowKFs){
            if(pKF->is_des_end){
            vector<Eigen::Vector3d> point_clouds_origin_cur=pKF->point_clouds_origin;
            std::vector<cv::Point2f> measurements_origin_cur=pKF->measurements_origin;
            vector<int> feature_id_origin_cur=pKF->features_id_origin;
             
            const int point_len_cur=point_clouds_origin_cur.size();
            const int point2D_len_cur=pKF->keypoints.size()-point_len_cur;
            
            for(int i=0;i<point_len_cur;i++){
                Vector3d point_cur=point_clouds_origin_cur[i];
                 
                //把主地图下 世界坐标系的点 转到小地图上一帧的图像坐标系上
                Vector3f p3D_c1=Rc1w2*point_cur.cast<float>()+tc1w2;
               
                //深度必须为正
                if(p3D_c1[2]<0.0f || p3D_c1[2]>20){
//                    cout<<"深度不为正"<<endl;
                    continue;
                }
//                        cout<<fixed<<setprecision(6)<<"测试 深度 两种算法"<<p3D_c2<<" 和 "<<dep_j<<endl;
                    
                // 投影到图像上
                const float x = p3D_c1[0];
                const float y = p3D_c1[1];
                const float z = p3D_c1[2];

                //这里可能得加一个畸变校正 应该可以不用去校正 把他投影在一个没有畸变的图像上
                const float u=fx*x/z+cx;
                const float v=fy*y/z+cy;
                
                
                if(!pKF_main->isInImage(u, v)){
//                    cout<<"投影点不在图像内"<<endl;
                    continue;
                }
                
                const vector<int> vIndices=pKF_main->GetFeaturesInArea_1(u, v, th);
                if(vIndices.empty()){
//                    cout<<"半径为10个像素 找不到点"<<endl;
                    continue;
                }
                
                //找在这个半径内最相似的 这里可能有些问题 因为3D点的描述子 个人感觉有问题
                BRIEF::bitset point_cur_des=pKF->descriptors[point2D_len_cur+i];
                int bestDist = 256;
                int bestIndex = -1;
                for(vector<int>::const_iterator vit=vIndices.begin(), vit_end=vIndices.end(); vit!=vit_end; vit++)
                {
//                    cout<<"*vit"<<*vit<<endl;发现 keypoints数量不等于des数量
                    int dis = pKF_main->HammingDis(point_cur_des, pKF_main->descriptors[*vit]);
                    if(dis < bestDist)
                    {
                        bestDist = dis;
                        bestIndex = *vit;
                    }
                }
                
                if(bestDist<=TH_LOW){
                    pointsCloud_old_3d.push_back(point_cur);
                    measurements_cur_2d.push_back(keypoints_main[bestIndex].pt);
                    measurements_old_2d.push_back(measurements_origin_cur[i]);
                    
                }
                              
            }
            }
            
            if(measurements_cur_2d.size()>=8){
                pKF_main->rejectWithF_server_mapFuse(measurements_old_2d, measurements_cur_2d,pointsCloud_old_3d);
    //            cout<<"两帧的匹配点数："<<pointsCloud_old_3d.size()<<endl;
//                if(pointsCloud_old_3d.size()>=11){//这个阈值 还要考虑
                    curKF_id_all.push_back(pKF_main->global_index);
                    pointsCloud_old_all.push_back(pointsCloud_old_3d);
                    measurements_cur_all.push_back(measurements_cur_2d);
                    num+=pointsCloud_old_3d.size();
//                }
            }
            
            measurements_old_2d.clear();
            measurements_cur_2d.clear();
            pointsCloud_old_3d.clear();
        }
        }
        
    }
    cout<<"通过再投影算出来的点数："<<num<<endl;
    
}


//对应新的版本 用新帧的3D点 投影 到老帧的2D点
void PoseGraphGlobal::Fuse_5_2_2( Matrix3f R_relative_best,Vector3f T_relative_best, list<KeyFrame*> spLocalWindowKFs,  KeyFrame* pKF_main, float th)
{
    
    
    Client* client_main=pKF_main->c;
    
    Matrix3d ric_mainClient=client_main->ric_client;
    Vector3d tic_mainClient=client_main->tic_client;
    Matrix3d rwi_main;
    Vector3d twi_main;
    
    const float &fx = client_main->FOCUS_LENGTH_X_server;
    const float &fy = client_main->FOCUS_LENGTH_Y_server;
    const float &cx = client_main->PX_server;
    const float &cy = client_main->PY_server;
    
    curKF_id_all.clear();
    pointsCloud_old_all.clear();
    measurements_cur_all.clear();
    
    int num=0;
    
   
        
    if(pKF_main->is_des_end){
        
        Matrix3f Rc1w2 =R_relative_best;
        Vector3f tc1w2 =T_relative_best;
 
        vector<Eigen::Vector3d> point_clouds_origin_main= pKF_main->point_clouds_origin;
        vector<int> feature_id_origin_main=pKF_main->features_id_origin;
        vector<cv::KeyPoint> keypoints_main=pKF_main->keypoints;
        const int nPoints = point_clouds_origin_main.size();
        const int point2D_len_main=keypoints_main.size()-point_clouds_origin_main.size();
        
        bool point_cur_inFeature=false;//false表示主地图和小地图的点都还没被加入feature中，true表示主地图这个点已经被加入feature中，但是小地图的没有加入。对应的小地图的帧也已经被加入到feature，这种直接结束
        
        for(KeyFrame* pKF:spLocalWindowKFs){
            if(pKF->is_des_end){
            vector<Eigen::Vector3d> point_clouds_origin_cur=pKF->point_clouds_origin;
            std::vector<cv::Point2f> measurements_origin_cur=pKF->measurements_origin;
            vector<int> feature_id_origin_cur=pKF->features_id_origin;
             
            const int point_len_cur=point_clouds_origin_cur.size();
            const int point2D_len_cur=pKF->keypoints.size()-point_len_cur;
            
            for(int i=0;i<point_len_cur;i++){
                Vector3d point_cur=point_clouds_origin_cur[i];
                 
                //把主地图下 世界坐标系的点 转到小地图上一帧的图像坐标系上
                Vector3f p3D_c1=Rc1w2*point_cur.cast<float>()+tc1w2;
               
                //深度必须为正
                if(p3D_c1[2]<0.0f || p3D_c1[2]>20){
//                    cout<<"深度不为正"<<endl;
                    continue;
                }
//                        cout<<fixed<<setprecision(6)<<"测试 深度 两种算法"<<p3D_c2<<" 和 "<<dep_j<<endl;
                    
                // 投影到图像上
                const float x = p3D_c1[0];
                const float y = p3D_c1[1];
                const float z = p3D_c1[2];

                //这里可能得加一个畸变校正 应该可以不用去校正 把他投影在一个没有畸变的图像上
                const float u=fx*x/z+cx;
                const float v=fy*y/z+cy;
                
                
                if(!pKF_main->isInImage(u, v)){
//                    cout<<"投影点不在图像内"<<endl;
                    continue;
                }
                
                const vector<int> vIndices=pKF_main->GetFeaturesInArea_1(u, v, th);
                if(vIndices.empty()){
//                    cout<<"半径为10个像素 找不到点"<<endl;
                    continue;
                }
                
                //找在这个半径内最相似的 这里可能有些问题 因为3D点的描述子 个人感觉有问题
                BRIEF::bitset point_cur_des=pKF->descriptors[point2D_len_cur+i];
                int bestDist = 256;
                int bestIndex = -1;
                for(vector<int>::const_iterator vit=vIndices.begin(), vit_end=vIndices.end(); vit!=vit_end; vit++)
                {
//                    cout<<"*vit"<<*vit<<endl;发现 keypoints数量不等于des数量
                    int dis = pKF_main->HammingDis(point_cur_des, pKF_main->descriptors[*vit]);
                    if(dis < bestDist)
                    {
                        bestDist = dis;
                        bestIndex = *vit;
                    }
                }
                
                if(bestDist<=TH_LOW){
                    pointsCloud_old_3d.push_back(point_cur);
                    measurements_cur_2d.push_back(keypoints_main[bestIndex].pt);
                    measurements_old_2d.push_back(measurements_origin_cur[i]);
                    
                }
                              
            }
            
            
            if(measurements_cur_2d.size()>=12){
                pKF_main->rejectWithF_server_mapFuse(measurements_old_2d, measurements_cur_2d,pointsCloud_old_3d);
    //            cout<<"两帧的匹配点数："<<pointsCloud_old_3d.size()<<endl;
//                if(pointsCloud_old_3d.size()>=11){//这个阈值 还要考虑
                    curKF_id_all.push_back(pKF_main->global_index);
                    pointsCloud_old_all.push_back(pointsCloud_old_3d);
                    measurements_cur_all.push_back(measurements_cur_2d);
                    num+=pointsCloud_old_3d.size();
//                }
            }
            
            measurements_old_2d.clear();
            measurements_cur_2d.clear();
            pointsCloud_old_3d.clear();
        }
        }
        
    }
    cout<<"通过再投影算出来的点数："<<num<<endl;
    
}


//新的版本 再加上重投影误差 新帧的3D点 投影 到老帧的2D点 R_relative_best表示从w2世界坐标系 到 老帧相机坐标系
void PoseGraphGlobal::Fuse_6_2_2( Matrix3f R_relative_best,Vector3f T_relative_best, list<KeyFrame*> spLocalWindowKFs,  list<KeyFrame*> spMergeConnectedKFs, KeyFrame* pKF_main_matched,float th)
{
    KeyFrame* pKF_main_last=spMergeConnectedKFs.back();
    Client* client_main=pKF_main_last->c;
    
    Matrix3d ric_mainClient=client_main->ric_client;
    Vector3d tic_mainClient=client_main->tic_client;
    
    //是老帧那个匹配帧
    Matrix3d rwi_main_last;
    Vector3d twi_main_last;
    pKF_main_matched->getOriginPose(twi_main_last,rwi_main_last);
    
    Matrix3d r_w1_c1=rwi_main_last*ric_mainClient;
    Vector3d t_w1_c1=rwi_main_last*tic_mainClient+twi_main_last;
    
    
    const float &fx = client_main->FOCUS_LENGTH_X_server;
    const float &fy = client_main->FOCUS_LENGTH_Y_server;
    const float &cx = client_main->PX_server;
    const float &cy = client_main->PY_server;
    
    curKF_id_all.clear();
    pointsCloud_old_all.clear();
    measurements_cur_all.clear();
    kf_index_all.clear();
    
    int num=0;
    
    int index=0;
    
    for(KeyFrame* pKF_main:spMergeConnectedKFs){
        
        if(pKF_main->is_des_end){
        
            Matrix3f Rc1w2 =R_relative_best;
            Vector3f tc1w2 =T_relative_best;
            
            Matrix3f r_cn_w2;
            Vector3f t_cn_w2;
            
            if(pKF_main==pKF_main_matched){
                r_cn_w2=Rc1w2;
                t_cn_w2=tc1w2;
                
                
                Matrix3d r;
                r.setIdentity();
                Vector3d t;
                t<<0,0,0;
                r_cn_c1_all[index]=r;
                t_cn_c1_all[index]=t;
            }else{
            
                Matrix3d r_w1_in;
                Vector3d t_w1_in;
                pKF_main->getOriginPose(t_w1_in, r_w1_in);
                Matrix3d r_cn_w1=ric_mainClient.transpose() * r_w1_in.transpose();
                Vector3d t_cn_w1=-r_cn_w1*(r_w1_in.transpose()*tic_mainClient+t_w1_in);
                
                Matrix3d r_cn_c1=r_cn_w1*r_w1_c1;
                Vector3d t_cn_c1=r_cn_w1*t_w1_c1+t_cn_w1;
                
                r_cn_c1_all[index]=r_cn_c1;
                t_cn_c1_all[index]=t_cn_c1;
                
                r_cn_w2=r_cn_c1.cast<float>() * Rc1w2;
                t_cn_w2=r_cn_c1.cast<float>() * tc1w2 + t_cn_c1.cast<float>();
            }
            
            
     
            vector<Eigen::Vector3d> point_clouds_origin_main= pKF_main->point_clouds_origin;
            vector<int> feature_id_origin_main=pKF_main->features_id_origin;
            vector<cv::KeyPoint> keypoints_main=pKF_main->keypoints;
            const int nPoints = point_clouds_origin_main.size();
            const int point2D_len_main=keypoints_main.size()-point_clouds_origin_main.size();
            
            bool point_cur_inFeature=false;//false表示主地图和小地图的点都还没被加入feature中，true表示主地图这个点已经被加入feature中，但是小地图的没有加入。对应的小地图的帧也已经被加入到feature，这种直接结束
            
            for(KeyFrame* pKF:spLocalWindowKFs){
                if(pKF->is_des_end){
                    vector<Eigen::Vector3d> point_clouds_origin_cur=pKF->point_clouds_origin;
                    std::vector<cv::Point2f> measurements_origin_cur=pKF->measurements_origin;
                    vector<int> feature_id_origin_cur=pKF->features_id_origin;
                     
                    const int point_len_cur=point_clouds_origin_cur.size();
                    const int point2D_len_cur=pKF->keypoints.size()-point_len_cur;
                    
                    for(int i=0;i<point_len_cur;i++){
                        Vector3d point_cur=point_clouds_origin_cur[i];
                         
                        //把主地图下 世界坐标系的点 转到小地图上一帧的图像坐标系上
                        Vector3f p3D_c1=r_cn_w2*point_cur.cast<float>()+t_cn_w2;
                       
                        //深度必须为正
                        if(p3D_c1[2]<0.0f || p3D_c1[2]>20){
        //                    cout<<"深度不为正"<<endl;
                            continue;
                        }
        //                        cout<<fixed<<setprecision(6)<<"测试 深度 两种算法"<<p3D_c2<<" 和 "<<dep_j<<endl;
                            
                        // 投影到图像上
                        const float x = p3D_c1[0];
                        const float y = p3D_c1[1];
                        const float z = p3D_c1[2];

                        //这里可能得加一个畸变校正 应该可以不用去校正 把他投影在一个没有畸变的图像上
                        const float u=fx*x/z+cx;
                        const float v=fy*y/z+cy;
                        
                        
                        if(!pKF_main->isInImage(u, v)){
        //                    cout<<"投影点不在图像内"<<endl;
                            continue;
                        }
                        
                        const vector<int> vIndices=pKF_main->GetFeaturesInArea_1(u, v, th);
                        if(vIndices.empty()){
        //                    cout<<"半径为10个像素 找不到点"<<endl;
                            continue;
                        }
                        
                        //找在这个半径内最相似的 这里可能有些问题 因为3D点的描述子 个人感觉有问题
                        BRIEF::bitset point_cur_des=pKF->descriptors[point2D_len_cur+i];
                        int bestDist = 256;
                        int bestIndex = -1;
                        for(vector<int>::const_iterator vit=vIndices.begin(), vit_end=vIndices.end(); vit!=vit_end; vit++)
                        {
        //                    cout<<"*vit"<<*vit<<endl;发现 keypoints数量不等于des数量
                            int dis = pKF_main->HammingDis(point_cur_des, pKF_main->descriptors[*vit]);
                            if(dis < bestDist)
                            {
                                bestDist = dis;
                                bestIndex = *vit;
                            }
                        }
                        
                        if(bestDist<=TH_LOW){
                            pointsCloud_old_3d.push_back(point_cur);
                            measurements_cur_2d.push_back(keypoints_main[bestIndex].pt);
                            measurements_old_2d.push_back(measurements_origin_cur[i]);
                            
                        }
                                      
                    }
                    
                    
                    if(measurements_cur_2d.size()>8){
                        pKF_main->rejectWithF_server_mapFuse(measurements_old_2d, measurements_cur_2d,pointsCloud_old_3d);
        //            cout<<"两帧的匹配点数："<<pointsCloud_old_3d.size()<<endl;
    //                if(pointsCloud_old_3d.size()>=11){//这个阈值 还要考虑
                        curKF_id_all.push_back(pKF_main->global_index);
                        pointsCloud_old_all.push_back(pointsCloud_old_3d);
                        measurements_cur_all.push_back(measurements_cur_2d);
                        num+=pointsCloud_old_3d.size();
                        
                        kf_index_all.push_back(index);
        //                }
                    }
                    
                    measurements_old_2d.clear();
                    measurements_cur_2d.clear();
                    pointsCloud_old_3d.clear();
                }
            }
        
            index++;
        }
    }
    cout<<"通过再投影算出来的点数："<<num<<endl;
    
}


void PoseGraphGlobal::setIMUModel(double FOCUS_LENGTH_X_server)
{
    ProjectionFactor_merge::sqrt_info = FOCUS_LENGTH_X_server / 1.5 * Matrix2d::Identity();
}



//论文实验的最后一版
void PoseGraphGlobal::GlobalFuse_4(){
    while(true){
        //请求每个地图自己的全局优化结束
        //加锁
        int len = sizeof(isFirstFusion) / sizeof(isFirstFusion[0]);
        for(int i=1;i<len;i++){
            if(isFirstFusion[i]!=3)
                continue;
            //因为现在写的都是和主地图发生地图融合 所以其中一个地图直接这么获取了
//            poseGraphGlobal_mutex.lock();
            readWriteLock.readLock();
            PoseGraph* pMainMap=PoseGraphGloabl_map[0];
            map<int,PoseGraph*>::iterator iter_map = PoseGraphGloabl_map.find(i);
            if(iter_map==PoseGraphGloabl_map.end())
            {
//                poseGraphGlobal_mutex.unlock();
                readWriteLock.readUnLock();
                assert(false);//都已经发生回环了，却找不到地图 说明数据插错了
                continue;
            }
            PoseGraph* pCurMap= iter_map->second;
//            poseGraphGlobal_mutex.unlock();
            readWriteLock.readUnLock();
            
            pCurMap->isFirstFusion_globalMutex.lock();
            pCurMap->keyFrameList_global_fusion_mutex.lock();
            isFirstFusion[i]=2;
            
            map<int,std::pair<int,int>>::iterator iter_kf_id = earliest_globalFuse_index.find(i);
            if(iter_kf_id==earliest_globalFuse_index.end())
            {
                assert(false);//都已经发生3次回环了，却找不到最早一次发生回环的kf_id 说明数据插错了
                continue;
            }
            std::pair<int,int> earliest_kf_id= iter_kf_id->second;
            int earliest_globalFuse_index_main=earliest_kf_id.first;
            int earliest_globalFuse_index_other=earliest_kf_id.second;
            
            
            std::pair<int,int> latest_kf_id=latest_globalFuse_index[i];
            int latest_globalFuse_index_main=latest_kf_id.first;
            int latest_globalFuse_index_other=latest_kf_id.second;
            
            cout<<"global fuse:"<<earliest_globalFuse_index_other<<" "<<earliest_globalFuse_index_main<<" "<<latest_globalFuse_index_other <<" "<<latest_globalFuse_index_main<<endl;
            
            Matrix3d r_w2_w1=r_w2_w1_allClient[i];
            Vector3d t_w2_w1=t_w2_w1_allClient[i];
            double t_w2_w1_double[3];
            t_w2_w1_double[0]=t_w2_w1[0];
            t_w2_w1_double[1]=t_w2_w1[1];
            t_w2_w1_double[2]=t_w2_w1[2];
            Vector3d euler_angle_w2_w1 =Utility::R2ypr(r_w2_w1);
            double euler_w2_w1_double[3];
            euler_w2_w1_double[0]=euler_angle_w2_w1.x();
            euler_w2_w1_double[1]=euler_angle_w2_w1.y();
            euler_w2_w1_double[2]=euler_angle_w2_w1.z();
            


            
            ceres::Problem problem;
            ceres::Solver::Options options;
            //options.linear_solver_type = ceres::DENSE_NORMAL_CHOLESKY;
            options.linear_solver_type = ceres::DENSE_SCHUR;
            options.minimizer_progress_to_stdout = true;
            options.max_num_iterations = 6;
            ceres::Solver::Summary summary;
            ceres::LossFunction *loss_function;
            loss_function = new ceres::HuberLoss(1.0);
            //AngleLocalParameterization类的主要作用是指定yaw角优化变量的迭代更新，重载了括号运算
            ceres::LocalParameterization* angle_local_parameterization =
            AngleLocalParameterization::Create();
            
            problem.AddParameterBlock(euler_w2_w1_double, 1, angle_local_parameterization);

            
            double total_lenth_main=pMainMap->total_length;
            double total_lenth_other=pCurMap->total_length;
            //总的位姿长度 除以总的帧数
            double total_lenth_sum=total_lenth_main+total_lenth_other;
            int max_frame_num_global_main=(total_lenth_main/total_lenth_sum)*max_frame_num_global;
            int max_frame_num_global_other=max_frame_num_global-max_frame_num_global_main;
            double min_dis_main=total_lenth_main/max_frame_num_global_main;
            double min_dis_other=total_lenth_other/max_frame_num_global_other;
            cout<<"min_dis_main："<<min_dis_main<<" min_dis_other:"<<min_dis_other<<endl;
            //*****************/*********************第2个数据
//            list<KeyFrame*> keyFrameList_merge=pMainMap->keyFrameList;
            //要优化的变量的最大个数
            int max_length_main=pMainMap->keyFrameList.size()+1;
            double t_array_main[max_length_main][3];//平移数组，其中存放每个关键帧的平移向量
            Quaterniond q_array_main[max_length_main];
            double euler_array_main[max_length_main][3];
            
            
            vector<bool> need_resample_main;
            //遍历关键帧列表
            list<KeyFrame*>::iterator it_main = pMainMap->keyFrameList.begin();
            Vector3d last_P_main = Vector3d(0, 0, 0);
            double dis_main = 0;
            
            for(;it_main!=pMainMap->keyFrameList.end();it_main++){
                if((*it_main)->global_index < earliest_globalFuse_index_main){
                    continue;
                }
                Vector3d tmp_t;
                Matrix3d tmp_r;
                //获取关键帧it的位姿
                (*it_main)->getPose(tmp_t, tmp_r);
                dis_main += (tmp_t - last_P_main).norm();
                //全局优化 还是要加序列边 不然太长了 判断条件 再加个两个地图之间发生了融合
                if((*it_main)->global_index == earliest_globalFuse_index_main || dis_main > min_dis_main || (*it_main)->has_loop || (*it_main)->is_looped || (*it_main)->has_global_loop || (*it_main)->is_global_looped || pMainMap->keyFrameList.size() < max_frame_num_global_main)
                {
                    dis_main = 0;
                    last_P_main = tmp_t;
                    
                    need_resample_main.push_back(0);
                }
                else
                {
                    last_P_main = tmp_t;
                    
                    need_resample_main.push_back(1);
                }
            }
            
            
             
            int i_main = 0;
            for (it_main = pMainMap->keyFrameList.begin(); it_main != pMainMap->keyFrameList.end(); it_main++)
            {
                if ((*it_main)->global_index < earliest_globalFuse_index_main)
                    continue;
                (*it_main)->resample_globalIndex = i_main;
                Quaterniond tmp_q;
                Matrix3d tmp_r;
                Vector3d tmp_t;
                (*it_main)->getPose(tmp_t, tmp_r);
                tmp_q = tmp_r;
                t_array_main[i_main][0] = tmp_t(0);
                t_array_main[i_main][1] = tmp_t(1);
                t_array_main[i_main][2] = tmp_t(2);
                q_array_main[i_main] = tmp_q;
                //将矩阵转换为向量
                Vector3d euler_angle = Utility::R2ypr(tmp_q.toRotationMatrix());
                euler_array_main[i_main][0] = euler_angle.x();
                euler_array_main[i_main][1] = euler_angle.y();
                euler_array_main[i_main][2] = euler_angle.z();
                //将关键帧列表中所有index>=earliest_loop_index的关键帧的位姿加入到参数块当中
                problem.AddParameterBlock(euler_array_main[i_main], 1, angle_local_parameterization);
                problem.AddParameterBlock(t_array_main[i_main], 3);
                //设置约束：如果该帧是最早的闭环帧的情况下，则固定它的位姿
//                if ((*it_main)->global_index == earliest_globalFuse_index_main)
//                {
                    problem.SetParameterBlockConstant(euler_array_main[i_main]);
                    problem.SetParameterBlockConstant(t_array_main[i_main]);
//                }
                
                if(need_resample_main[i_main])
                {
                    i_main++;
                    continue;
                }
                
                
//                int j = 1, sequence_link_cnt = 0;
//                //        这里添加的是序列边，是指通过VIO计算的两帧之间的相对位姿，每帧分别与其前边最多四帧构成序列边
//                //        顺序边的测量方程：p̂_{ij}^{i} = {R̂_i^w}^{-1} (p̂_j^w - p̂_i^w)\hat{ψ}_ij = \hat{ψ}_j − \hat{ψ̂}_i
//                //        两个关键帧之间的相对位姿，由两个关键帧之间的VIO位姿估计变换得到
//                while(sequence_link_cnt < 5)
//                {
//                    if (i_main - j >= 0)
//                    {
//                        list<KeyFrame*>::iterator tmp = it_main;
//                        std::advance (tmp, -j);
//                        if(need_resample_main[i_main-j])
//                        {
//                            j++;
//                            continue;
//                        }
//                        else
//                        {
//                            sequence_link_cnt++;
//                        }
//                        Vector3d euler_conncected = Utility::R2ypr(q_array_main[i_main-j].toRotationMatrix());
//                        //p̂_j^w - p̂_i^w 计算平移量的偏差
//                        Vector3d relative_t(t_array_main[i_main][0] - t_array_main[i_main-j][0], t_array_main[i_main][1] - t_array_main[i_main-j][1], t_array_main[i_main][2] - t_array_main[i_main-j][2]);
//                        //p̂_{ij}^{i} = {R̂_i^w}^{-1} (p̂_j^w - p̂_i^w)
//                        //p̂ ij= (R̂ iw ) (p̂ jw − p̂ iw )
//                        relative_t = q_array_main[i_main-j].inverse() * relative_t;
//                        //ψ̂ _ij = ψ̂ _j − ψ̂ _i
//                        double relative_yaw = euler_array_main[i_main][0] - euler_array_main[i_main-j][0];
//                        ceres::CostFunction* cost_function = FourDOFError_another::Create( relative_t.x(), relative_t.y(), relative_t.z(),
//                                                                                  relative_yaw, euler_conncected.y(), euler_conncected.z());
//                        problem.AddResidualBlock(cost_function, loss_function, euler_array_main[i_main-j],
//                                                 t_array_main[i_main-j],
//                                                 euler_array_main[i_main],
//                                                 t_array_main[i_main]);
//                    }
//                    else
//                    {
//                        break;
//                    }
//                    j++;
//                }
//
//                //        添加的是闭环边，是指检测到闭环的两帧
//                if((*it_main)->has_loop&&(*it_main)->is_get_loop_info   )
//                {
//                    //这里后面还要添加else
//                    if((*it_main)->loop_index >= earliest_globalFuse_index_main)
//                    {
//                        //这里要改
//                        int connected_index = pMainMap->getKeyframe((*it_main)->loop_index)->resample_globalIndex;
//
//                        Vector3d euler_conncected = Utility::R2ypr(q_array_main[connected_index].toRotationMatrix());
//                        Vector3d relative_t((*it_main)->loop_info(0), (*it_main)->loop_info(1), (*it_main)->loop_info(2));
//                        double relative_yaw = (*it_main)->loop_info(7);
//
//                        cout<<fixed<<setprecision(6)<<"(*it_main)->loop_info(0)"<<(*it_main)->loop_info(0)<<" (*it_main)->loop_info(1)"<<(*it_main)->loop_info(1)<<" (*it_main)->loop_info(2)"<<(*it_main)->loop_info(2)<<" (*it_main)->loop_info(7)"<<(*it_main)->loop_info(7)<<" "<<(*it_main)->header<<" "<<pMainMap->getKeyframe((*it_main)->global_index)->header<<endl;
//
//                        ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),
//                                                                                        relative_yaw, euler_conncected.y(), euler_conncected.z());
//                        problem.AddResidualBlock(cost_function, NULL, euler_array_main[connected_index],
//                                                 t_array_main[connected_index],
//                                                 euler_array_main[i_main],
//                                                 t_array_main[i_main]);
//                    }
//
//                }

                if ((*it_main)->global_index == latest_globalFuse_index_main)
                    break;
                i_main++;
            }
            
            
            
            Matrix3d r_w1_w2=r_w2_w1.transpose();
            Vector3d t_w1_w2=-r_w1_w2*t_w2_w1;
            
            //*************************************第一个数据
            vector<bool> need_resample_other;
            //遍历关键帧列表
//            list<KeyFrame*> keyFrameList_cur=pCurMap->keyFrameList;
            list<KeyFrame*>::iterator it_other = pCurMap->keyFrameList.begin();
            Vector3d last_P_other = Vector3d(0, 0, 0);
            double dis_other = 0;

            for(;it_other!=pCurMap->keyFrameList.end();it_other++){
                if((*it_other)->global_index < earliest_globalFuse_index_other){
                    continue;
                }
                Vector3d tmp_t;
                Matrix3d tmp_r;
                //获取关键帧it的位姿
                (*it_other)->getPose(tmp_t, tmp_r);
                dis_other += (tmp_t - last_P_other).norm();
                
                
                //全局优化 还是要加序列边 不然太长了 判断条件 再加个两个地图之间发生了融合
                //第一个地图融合位置，超过长度了，发生过回环，被回环了，总共的帧长度比最大值小
                //还要再加一个 发生了融合，被融合了
                if((*it_other)->global_index == earliest_globalFuse_index_other || dis_other > min_dis_other || (*it_other)->has_loop || (*it_other)->is_looped || (*it_other)->has_global_loop || (*it_other)->is_global_looped ||pCurMap->keyFrameList.size() < max_frame_num_global_other)
                {
                    dis_other = 0;
                    last_P_other = tmp_t;
                    need_resample_other.push_back(0);
                }
                else
                {
                    last_P_other = tmp_t;
                    need_resample_other.push_back(1);
                }
            }

            //要优化的变量的最大个数
            int max_length_other=pCurMap->keyFrameList.size()+1;

            double t_array_other[max_length_other][3];//平移数组，其中存放每个关键帧的平移向量
            Quaterniond q_array_other[max_length_other];
            double euler_array_other[max_length_other][3];

            int i_other = 0;
            for (it_other = pCurMap->keyFrameList.begin(); it_other != pCurMap->keyFrameList.end(); it_other++)
            {
                if ((*it_other)->global_index < earliest_globalFuse_index_other)
                    continue;
                (*it_other)->resample_globalIndex = i_other;
                Quaterniond tmp_q;
                Matrix3d tmp_r;
                Vector3d tmp_t;
                (*it_other)->getPose(tmp_t, tmp_r);
                
//                Matrix3d tmp_w1_r=r_w1_w2*tmp_r;
//                Vector3d tmp_w1_t=r_w1_w2*tmp_t+t_w1_w2;
//                tmp_q = tmp_w1_r;
//                t_array_other[i_other][0] = tmp_w1_t(0);
//                t_array_other[i_other][1] = tmp_w1_t(1);
//                t_array_other[i_other][2] = tmp_w1_t(2);
//                q_array_other[i_other] = tmp_q;
                
                tmp_q=tmp_r;
                t_array_other[i_other][0]=tmp_t[0];
                t_array_other[i_other][1]=tmp_t[1];
                t_array_other[i_other][2]=tmp_t[2];
                q_array_other[i_other]=tmp_q;
                //将矩阵转换为向量
                Vector3d euler_angle = Utility::R2ypr(tmp_q.toRotationMatrix());
                euler_array_other[i_other][0] = euler_angle.x();
                euler_array_other[i_other][1] = euler_angle.y();
                euler_array_other[i_other][2] = euler_angle.z();
                //将关键帧列表中所有index>=earliest_loop_index的关键帧的位姿加入到参数块当中
                problem.AddParameterBlock(euler_array_other[i_other], 1, angle_local_parameterization);
                problem.AddParameterBlock(t_array_other[i_other], 3);
                //设置约束：如果该帧是最早的闭环帧的情况下，则固定它的位姿
//                if ((*it_other)->global_index == earliest_globalFuse_index_other)
//                {
                    problem.SetParameterBlockConstant(euler_array_other[i_other]);
                    problem.SetParameterBlockConstant(t_array_other[i_other]);
//                }

                if(need_resample_other[i_other])
                {
                    i_other++;
                    continue;
                }


                int j = 1, sequence_link_cnt = 0;
                //        这里添加的是序列边，是指通过VIO计算的两帧之间的相对位姿，每帧分别与其前边最多四帧构成序列边
                //        顺序边的测量方程：p̂_{ij}^{i} = {R̂_i^w}^{-1} (p̂_j^w - p̂_i^w)\hat{ψ}_ij = \hat{ψ}_j − \hat{ψ̂}_i
                //        两个关键帧之间的相对位姿，由两个关键帧之间的VIO位姿估计变换得到
                while(sequence_link_cnt < 5)
                {
                    if (i_other - j >= 0)
                    {
                        list<KeyFrame*>::iterator tmp = it_other;
                        std::advance (tmp, -j);
                        if(need_resample_other[i_other-j])
                        {
                            j++;
                            continue;
                        }
                        else
                        {
                            sequence_link_cnt++;
                        }
                        Vector3d euler_conncected = Utility::R2ypr(q_array_other[i_other-j].toRotationMatrix());
                        //p̂_j^w - p̂_i^w 计算平移量的偏差
                        Vector3d relative_t(t_array_other[i_other][0] - t_array_other[i_other-j][0], t_array_other[i_other][1] - t_array_other[i_other-j][1], t_array_other[i_other][2] - t_array_other[i_other-j][2]);
                        //p̂_{ij}^{i} = {R̂_i^w}^{-1} (p̂_j^w - p̂_i^w)
                        //p̂ ij= (R̂ iw ) (p̂ jw − p̂ iw )
                        relative_t = q_array_other[i_other-j].inverse() * relative_t;
                        //ψ̂ _ij = ψ̂ _j − ψ̂ _i
                        double relative_yaw = euler_array_other[i_other][0] - euler_array_other[i_other-j][0];
                        ceres::CostFunction* cost_function = FourDOFError_another::Create( relative_t.x(), relative_t.y(), relative_t.z(),
                                                                                  relative_yaw, euler_conncected.y(), euler_conncected.z());
                        problem.AddResidualBlock(cost_function, loss_function, euler_array_other[i_other-j],
                                                 t_array_other[i_other-j],
                                                 euler_array_other[i_other],
                                                 t_array_other[i_other]);
                    }
                    else
                    {
                        break;
                    }
                    j++;
                }

                //        添加的是闭环边，是指检测到闭环的两帧 一个数据拆成两份 这个注释掉了
//                if((*it_other)->has_loop&&(*it_other)->is_get_loop_info   )
//                {
//                    //这里后面还要添加else
//                    if((*it_other)->loop_index >= earliest_globalFuse_index_other)
//                    {
//                        //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束
//                        int connected_index = pCurMap->getKeyframe((*it_other)->loop_index)->resample_globalIndex;
//
//                        Vector3d euler_conncected = Utility::R2ypr(q_array_other[connected_index].toRotationMatrix());
//                        Vector3d relative_t((*it_other)->loop_info_better(0), (*it_other)->loop_info_better(1), (*it_other)->loop_info_better(2));
//                        double relative_yaw = (*it_other)->loop_info_better(3);
//
//                        cout<<fixed<<setprecision(6)<<"(*it_other)->loop_info(0)"<<(*it_other)->loop_info_better(0)<<" (*it_other)->loop_info(1)"<<(*it_other)->loop_info_better(1)<<" (*it_other)->loop_info(2)"<<(*it_other)->loop_info_better(2)<<" (*it_other)->loop_info(7)"<<(*it_other)->loop_info_better(3)<<" "<<(*it_other)->header<<" "<<pCurMap->getKeyframe((*it_other)->global_index)->header<<endl;
//
//                        ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z());
//                        problem.AddResidualBlock(cost_function, NULL, euler_array_other[connected_index],
//                                                 t_array_other[connected_index],
//                                                 euler_array_other[i_other],
//                                                 t_array_other[i_other]);
//                    }
//
//
//                }
                
                if((*it_other)->has_global_loop)
               {
                   //这里后面还要添加else
                   if((*it_other)->global_loop_index < earliest_globalFuse_index_main)
                   {
                       //因为这意味着数据保存出错了 发生了融合的帧的id小于最早发生融合的id
                       assert(false);
                       return;
                   }
                   //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束
                   int connected_index = pMainMap->getKeyframe((*it_other)->global_loop_index)->resample_globalIndex;
                   
//                   cout<<"global fuse has_global_loop"<<(*it_other)->global_loop_index<<" "<<connected_index<<" "<<keyFrameList_merge.size()<<endl;
                   Vector3d euler_conncected = Utility::R2ypr(q_array_main[connected_index].toRotationMatrix());
                   Vector3d relative_t((*it_other)->global_loop_info(0), (*it_other)->global_loop_info(1), (*it_other)->global_loop_info(2));
                   double relative_yaw = (*it_other)->global_loop_info(7);
                   double relative_pitch =(*it_other)->global_relative_pitch;
                   double relative_roll=(*it_other)->global_relative_roll;

//                   cout<<"(*it_other)->global_loop_info(0)"<<(*it_other)->global_loop_info(0)<<" (*it_other)->global_loop_info(1)"<<(*it_other)->global_loop_info(1)<<" (*it_other)->global_loop_info(2)"<<(*it_other)->global_loop_info(2)<<" (*it_other)->global_loop_info(7)"<<(*it_other)->global_loop_info(7)<<" "<<(*it_other)->global_index<<" "<<(*it_other)->header<<" "<<pMainMap->getKeyframe((*it_other)->global_loop_index)->header<<endl;
                   
                   //这里到时候 再写一个求导的
                   ceres::CostFunction* cost_function = FourDOFWeightError_cur2main::Create( relative_t.x(), relative_t.y(), relative_t.z(), relative_yaw, relative_pitch, relative_roll, euler_conncected.x(), euler_conncected.y(), euler_conncected.z(), t_array_main[connected_index][0] , t_array_main[connected_index][1] , t_array_main[connected_index][2], euler_array_other[i_other][1], euler_array_other[i_other][2],10.0);
                   problem.AddResidualBlock(cost_function, NULL, euler_w2_w1_double, t_w2_w1_double, euler_array_other[i_other],
                                            t_array_other[i_other]);

               }
                if ((*it_other)->global_index == latest_globalFuse_index_other)
                    break;
                i_other++;
            }

//            ceres::CostFunction* cost_function = SixDOFWeightError_relativePose::Create(t_w2_w1_double[0], t_w2_w1_double[1], t_w2_w1_double[2], euler_w2_w1_double[0], euler_w2_w1_double[1], euler_w2_w1_double[2]);
//            problem.AddResidualBlock(cost_function, NULL, euler_w2_w1_double, t_w2_w1_double);
            
            ceres::Solve(options, &problem, &summary);
            
            std::cout << "global fuse: "<<summary.BriefReport() << "\n";
            
            //之前参与局部优化的帧的位姿 地图点固定 这个可以给kf一个bool判断
            //先添加相邻帧之间的代价函数
            //如果有两个回环的发生 再加个回环边
            
            //更新相对位姿
            pCurMap->refine_path_mutex.lock();
            r_w2_w1_allClient[i]=Utility::ypr2R(Vector3d(euler_w2_w1_double[0], euler_w2_w1_double[1], euler_w2_w1_double[2]));
            t_w2_w1_allClient[i]=Vector3d(t_w2_w1_double[0], t_w2_w1_double[1], t_w2_w1_double[2]);
            pCurMap->refine_path_mutex.unlock();
            
            pMainMap->relative_r_mainToOther[i]=r_w2_w1_allClient[i].cast<float>();
            pMainMap->relative_t_mainToOther[i]=t_w2_w1_allClient[i].cast<float>();
            //------------------------------------------第一个数据优化后更新
            //优化完成，使用优化后的位姿来更新关键帧列表中index大于等于earliest_loop_index的所有关键帧的位姿
            i_other = 0;
            Vector3d t_drift_it_other = Vector3d::Zero();
            Matrix3d r_drift_it_other = Matrix3d::Identity();
            Vector3d t_drift_relativePose;
            Matrix3d r_drift_relativePose;
            for (it_other = pCurMap->keyFrameList.begin(); it_other != pCurMap->keyFrameList.end(); it_other++)
            {
                if ((*it_other)->global_index < earliest_globalFuse_index_other)
                    continue;
                
                
                Quaterniond tmp_q;
                //向量转换为矩阵
                tmp_q = Utility::ypr2R(Vector3d(euler_array_other[i_other][0], euler_array_other[i_other][1], euler_array_other[i_other][2]));
                Vector3d tmp_w1_t = Vector3d(t_array_other[i_other][0], t_array_other[i_other][1], t_array_other[i_other][2]);
                Matrix3d tmp_w1_r = tmp_q.toRotationMatrix();
                
//                Vector3d tmp_w2_t = r_w2_w1*tmp_w1_t+t_w2_w1;
//                Matrix3d tmp_w2_r = r_w2_w1*tmp_w1_r;
                
                if(need_resample_other[i_other])
                {
                    (*it_other)-> updatePose(r_drift_it_other * tmp_w1_t + t_drift_it_other, r_drift_it_other * tmp_w1_r);
                }
                else
                {
                    Vector3d origin_t_it;
                    Matrix3d origin_r_it;
                    (*it_other)->getOriginPose(origin_t_it, origin_r_it);
                    
//                    if((*it_other)->global_index==earliest_globalFuse_index_other){
//                        Vector3d cur_t_it;
//                        Matrix3d cur_r_it;
//                        (*it_other)->getPose(cur_t_it, cur_r_it);
//                        r_drift_relativePose = tmp_w2_r * cur_r_it.transpose();
//                        t_drift_relativePose = tmp_w2_t - r_drift_relativePose * cur_t_it;
//                    }
                    
                    
                    r_drift_it_other = tmp_w1_r * origin_r_it.transpose();
                    t_drift_it_other = tmp_w1_t - r_drift_it_other * origin_t_it;
                    (*it_other)-> updatePose(tmp_w1_t, tmp_w1_r);
                }
                if ((*it_other)->global_index == latest_globalFuse_index_other)
                    break;
                i_other++;
                
            }
            
            //如果将地图建模成可变形的呢
            //根据计算出当前帧的drift，更新全部关键帧位姿
//            Vector3d cur_t_other, origin_t_other;
//            Matrix3d cur_r_other, origin_r_other;
//            //获取优化后当前帧的位姿cur_t,cur_r
//            (*it_other)->getPose(cur_t_other, cur_r_other);
//            //获取优化前有漂移的当前帧的位姿vio_t,vio_r
//            (*it_other)->getOriginPose(origin_t_other, origin_r_other);
//            pCurMap->yaw_drift = Utility::R2ypr(cur_r_other).x() - Utility::R2ypr(origin_r_other).x();
//            pCurMap->r_drift = Utility::ypr2R(Vector3d(pCurMap->yaw_drift, 0, 0));
//            pCurMap->t_drift = cur_t_other - pCurMap->r_drift * origin_t_other;
//
//            //下面代码为把当前关键帧it之后的关键帧的位姿通过求解的偏移量转换到world坐标系下
//            for (; it_other != pCurMap->keyFrameList.end(); it_other++)
//            {
//                Vector3d P;
//                Matrix3d R;
//                (*it_other)->getOriginPose(P, R);
//                P = pCurMap->r_drift * P + pCurMap->t_drift;
//                R = pCurMap->r_drift * R;
//                (*it_other)-> updatePose(P, R);
//            }
            
//            for (it_other = pCurMap->keyFrameList.begin(); it_other != pCurMap->keyFrameList.end(); it_other++)
//            {
//                if ((*it_other)->global_index == earliest_globalFuse_index_other)
//                    break;
//
//                Vector3d P;
//                Matrix3d R;
//                (*it_other)->getPose(P, R);
//                P = r_drift_relativePose * P + t_drift_relativePose;
//                R = r_drift_relativePose * R;
//                (*it_other)-> updatePose(P, R);
//            }
            
            //---------------------------------------第2个数据的更新
            //优化完成，使用优化后的位姿来更新关键帧列表中index大于等于earliest_loop_index的所有关键帧的位姿
//            i_main = 0;
//            Vector3d t_drift_it_main = Vector3d::Zero();
//            Matrix3d r_drift_it_main = Matrix3d::Identity();
//            for (it_main = pMainMap->keyFrameList.begin(); it_main != pMainMap->keyFrameList.end(); it_main++)
//            {
//                if ((*it_main)->global_index < earliest_globalFuse_index_main)
//                    continue;
//
//
//                Quaterniond tmp_q;
//                //向量转换为矩阵
//                tmp_q = Utility::ypr2R(Vector3d(euler_array_main[i_main][0], euler_array_main[i_main][1], euler_array_main[i_main][2]));
//                Vector3d tmp_w1_t = Vector3d(t_array_main[i_main][0], t_array_main[i_main][1], t_array_main[i_main][2]);
//                Matrix3d tmp_w1_r = tmp_q.toRotationMatrix();
//
//
//                if(need_resample_main[i_main])
//                {
//                    (*it_main)-> updatePose(r_drift_it_main * tmp_w1_t + t_drift_it_main, r_drift_it_main * tmp_w1_r);
//                }
//                else
//                {
//                    Vector3d origin_t_it;
//                    Matrix3d origin_r_it;
//                    (*it_main)->getOriginPose(origin_t_it, origin_r_it);
//                    r_drift_it_main = tmp_w1_r * origin_r_it.transpose();
//                    t_drift_it_main = tmp_w1_t - r_drift_it_main * origin_t_it;
//                    (*it_main)-> updatePose(tmp_w1_t, tmp_w1_r);
//                }
//                if ((*it_main)->global_index == latest_globalFuse_index_main)
//                    break;
//                i_main++;
//
//            }
//            //根据计算出当前帧的drift，更新全部关键帧位姿
//            Vector3d cur_t_main, origin_t_main;
//            Matrix3d cur_r_main, origin_r_main;
//            //获取优化后当前帧的位姿cur_t,cur_r
//            (*it_main)->getPose(cur_t_main, cur_r_main);
//            //获取优化前有漂移的当前帧的位姿vio_t,vio_r
//            (*it_main)->getOriginPose(origin_t_main, origin_r_main);
//            pMainMap->yaw_drift = Utility::R2ypr(cur_r_main).x() - Utility::R2ypr(origin_r_main).x();
//            pMainMap->r_drift = Utility::ypr2R(Vector3d(pMainMap->yaw_drift, 0, 0));
//            pMainMap->t_drift = cur_t_main - pMainMap->r_drift * origin_t_main;
//
//            //下面代码为把当前关键帧it之后的关键帧的位姿通过求解的偏移量转换到world坐标系下
//            for (; it_main != pMainMap->keyFrameList.end(); it_main++)
//            {
//                Vector3d P;
//                Matrix3d R;
//                (*it_main)->getOriginPose(P, R);
//                P = pMainMap->r_drift * P + pMainMap->t_drift;
//                R = pMainMap->r_drift * R;
//                (*it_main)-> updatePose(P, R);
//            }
            
            
            pCurMap->keyFrameList_global_fusion_mutex.unlock();
            pCurMap->isFirstFusion_globalMutex.unlock();
            
            pCurMap->refine_path_mutex.lock();
            pMainMap->fusion_relative_isUpdate[i]=0;
            pCurMap->refine_path_mutex.unlock();
            
//            位姿更新都留到显示那里
            pCurMap->updateVisualization();
//            pMainMap->updateVisualization();
            
            
        }
        usleep(3000);
    }
    
    
}



//这里一定是两个地图之间存在融合 才会进来
void PoseGraphGlobal::GlobalFuse_6(int i){
            
//    poseGraphGlobal_mutex.lock();
    readWriteLock.readLock();
    //因为现在写的都是和主地图发生地图融合 所以其中一个地图直接这么获取了
    PoseGraph* pMainMap=PoseGraphGloabl_map[0];
    map<int,PoseGraph*>::iterator iter_map = PoseGraphGloabl_map.find(i);
    if(iter_map==PoseGraphGloabl_map.end())
    {
//        poseGraphGlobal_mutex.unlock();
        readWriteLock.readUnLock();
        assert(false);//都已经发生回环了，却找不到地图 说明数据插错了
        
    }
    PoseGraph* pCurMap= iter_map->second;
//    poseGraphGlobal_mutex.unlock();
    readWriteLock.readUnLock();
    
    pCurMap->isFirstFusion_globalMutex.lock();
    
    int earliest_loop_index_main=pMainMap->earliest_loop_index;
    int earliest_global_looped_index_main=earliest_global_loop_index[i];
    if (earliest_loop_index_main > earliest_global_looped_index_main || earliest_loop_index_main == -1  )
        earliest_loop_index_main=earliest_global_looped_index_main;
    
    int latest_loop_index_main=pMainMap->latest_loop_index;
    int latest_global_looped_index_main=latest_global_loop_index[i].first;
    if (latest_global_looped_index_main > latest_loop_index_main)
        latest_loop_index_main=latest_global_looped_index_main;
    
    
    int latest_loop_index_cur=pCurMap->latest_loop_index;
    int latest_global_looped_index_cur=latest_global_loop_index[i].second;
    if (latest_global_looped_index_cur > latest_loop_index_cur)
        latest_loop_index_cur=latest_global_looped_index_cur;
    
    isFirstFusion[i]=2;
    
    isFusion[i]=1;
    pMainMap->loop_index_multiClient.push(earliest_loop_index_main);
    pMainMap->curKF_loop_index_multiClient.push(latest_loop_index_main);
    pCurMap->loop_index_multiClient.push(0);
    pCurMap->curKF_loop_index_multiClient.push(latest_loop_index_cur);
            
            
    //主地图从earliest_loop_index_main开始--当前帧结束
    //小地图从第一帧开始--当前发生回环的帧 这个有可能是回环帧，也有可能是融合帧
    
    ceres::Problem problem;
    ceres::Solver::Options options;
    //options.linear_solver_type = ceres::DENSE_NORMAL_CHOLESKY;
    options.linear_solver_type = ceres::DENSE_SCHUR;
    options.minimizer_progress_to_stdout = true;
    options.max_num_iterations = 6;
    ceres::Solver::Summary summary;
    ceres::LossFunction *loss_function;
    loss_function = new ceres::HuberLoss(1.0);
    //AngleLocalParameterization类的主要作用是指定yaw角优化变量的迭代更新，重载了括号运算
    ceres::LocalParameterization* angle_local_parameterization =
    AngleLocalParameterization::Create();
    
    
    double total_lenth_main=pMainMap->total_length;
    double total_lenth_other=pCurMap->total_length;
    //总的位姿长度 除以总的帧数
    double total_lenth_sum=total_lenth_main+total_lenth_other;
    int max_frame_num_global_main=(total_lenth_main/total_lenth_sum)*max_frame_num_global;
    int max_frame_num_global_other=max_frame_num_global-max_frame_num_global_main;
    double min_dis_main=total_lenth_main/max_frame_num_global_main;
    double min_dis_other=total_lenth_other/max_frame_num_global_other;
    cout<<"min_dis_main："<<min_dis_main<<" min_dis_other:"<<min_dis_other<<endl;
    
    //要优化的变量的最大个数 主地图
    int max_length_main=pMainMap->keyFrameList.size()+1;
    double t_array_main[max_length_main][3];//平移数组，其中存放每个关键帧的平移向量
    Quaterniond q_array_main[max_length_main];
    double euler_array_main[max_length_main][3];
    vector<bool> need_resample_main;
    
    //要优化的变量的最大个数 小地图
    int max_length_other=pCurMap->keyFrameList.size()+1;
    double t_array_other[max_length_other][3];//平移数组，其中存放每个关键帧的平移向量
    Quaterniond q_array_other[max_length_other];
    double euler_array_other[max_length_other][3];
    vector<bool> need_resample_other;
    
    pMainMap->max_frame_num_global=max_frame_num_global_main;
    pMainMap->min_dis=min_dis_main;
    pCurMap->max_frame_num_global=max_frame_num_global_other;
    pCurMap->min_dis=min_dis_other;
    
//    pMainMap->clear_kf_id_hasComPlace_withOtherMap();
//    pMainMap->clear_r_global_multiClient();
//    pMainMap->clear_t_global_multiClient();
    
//    pMainMap->special_kf_inOpti.clear();
    vector<int> special_kf_inOpti_main;
    vector<int> kf_id_hasComPlace_main;
    //遍历关键帧列表
    list<KeyFrame*>::iterator it_main = pMainMap->keyFrameList.begin();
    Vector3d last_P_main = Vector3d(0, 0, 0);
    double dis_main = 0;
    for(;it_main!=pMainMap->keyFrameList.end();it_main++){
        if((*it_main)->global_index < earliest_loop_index_main){
            continue;
        }
        Vector3d tmp_t;
        Matrix3d tmp_r;
        //获取关键帧it的位姿
        (*it_main)->getPose(tmp_t, tmp_r);
        dis_main += (tmp_t - last_P_main).norm();
        //全局优化 还是要加序列边 不然太长了 判断条件 再加个两个地图之间发生了融合
        if((*it_main)->global_index == earliest_loop_index_main || dis_main > min_dis_main || (*it_main)->is_get_loop_info || (*it_main)->is_looped || (*it_main)->has_global_loop || (*it_main)->is_global_looped || pMainMap->keyFrameList.size() < max_frame_num_global_main)
        {
            dis_main = 0;
            last_P_main = tmp_t;
            need_resample_main.push_back(0);
            
//            pMainMap->special_kf_inOpti.push_back((*it_main)->global_index);
            special_kf_inOpti_main.push_back((*it_main)->global_index);
            
            if(((*it_main)->has_global_loop || (*it_main)->is_global_looped) && (*it_main)->is_Send==false ){
                kf_id_hasComPlace_main.push_back((*it_main)->global_index);
//                pMainMap->add2_kf_id_hasComPlace_withOtherMap((*it_main)->global_index);
                (*it_main)->is_Send=true;
            }
        }
        else
        {
            last_P_main = tmp_t;
            need_resample_main.push_back(1);
        }
    }
    
    pMainMap->special_kf_mutex.lock();
    pMainMap->add2_kf_id_hasComPlace_withOtherMap(kf_id_hasComPlace_main);
   pMainMap->special_kf_inOpti.push(special_kf_inOpti_main);
   pMainMap->special_kf_mutex.unlock();
     
    int i_main = 0;
    for (it_main = pMainMap->keyFrameList.begin(); it_main != pMainMap->keyFrameList.end(); it_main++)
    {
        if ((*it_main)->global_index < earliest_loop_index_main)
            continue;
        (*it_main)->resample_globalIndex = i_main;
        Quaterniond tmp_q;
        Matrix3d tmp_r;
        Vector3d tmp_t;
        (*it_main)->getOriginPose(tmp_t, tmp_r);
//                (*it_main)->getPose(tmp_t, tmp_r);
        tmp_q = tmp_r;
        t_array_main[i_main][0] = tmp_t(0);
        t_array_main[i_main][1] = tmp_t(1);
        t_array_main[i_main][2] = tmp_t(2);
        q_array_main[i_main] = tmp_q;
        //将矩阵转换为向量
        Vector3d euler_angle = Utility::R2ypr(tmp_r);
        euler_array_main[i_main][0] = euler_angle.x();
        euler_array_main[i_main][1] = euler_angle.y();
        euler_array_main[i_main][2] = euler_angle.z();
        //将关键帧列表中所有index>=earliest_loop_index的关键帧的位姿加入到参数块当中
        problem.AddParameterBlock(euler_array_main[i_main], 1, angle_local_parameterization);
        problem.AddParameterBlock(t_array_main[i_main], 3);
        //设置约束：如果该帧是最早的闭环帧的情况下，则固定它的位姿
        if ((*it_main)->global_index == earliest_loop_index_main)
        {
            problem.SetParameterBlockConstant(euler_array_main[i_main]);
            problem.SetParameterBlockConstant(t_array_main[i_main]);
//                cout<<"测试 更新哪里变了："<<euler_array_main[i_main][0]<<" "<<euler_array_main[i_main][1]<<" "<<euler_array_main[i_main][2]<<" "<<t_array_main[i_main][0]<<" "<<t_array_main[i_main][1]<<" "<<t_array_main[i_main][2]<<" "<<i_main<<endl;
        }
        
        if(need_resample_main[i_main])
        {
            i_main++;
            continue;
        }
        
        
        int j = 1, sequence_link_cnt = 0;
        while(sequence_link_cnt < 5)
        {
            if (i_main - j >= 0)
            {
//                        list<KeyFrame*>::iterator tmp = it_main;
//                        std::advance (tmp, -j);
                if(need_resample_main[i_main-j])
                {
                    j++;
                    continue;
                }
                else
                {
                    sequence_link_cnt++;
                }
                Vector3d euler_conncected = Utility::R2ypr(q_array_main[i_main-j].toRotationMatrix());
                //p̂_j^w - p̂_i^w 计算平移量的偏差
                Vector3d relative_t(t_array_main[i_main][0] - t_array_main[i_main-j][0], t_array_main[i_main][1] - t_array_main[i_main-j][1], t_array_main[i_main][2] - t_array_main[i_main-j][2]);
                //p̂_{ij}^{i} = {R̂_i^w}^{-1} (p̂_j^w - p̂_i^w)
                //p̂ ij= (R̂ iw ) (p̂ jw − p̂ iw )
                relative_t = q_array_main[i_main-j].inverse() * relative_t;
                //ψ̂ _ij = ψ̂ _j − ψ̂ _i
                double relative_yaw = euler_array_main[i_main][0] - euler_array_main[i_main-j][0];
                ceres::CostFunction* cost_function = FourDOFError_another::Create( relative_t.x(), relative_t.y(), relative_t.z(),
                                                                          relative_yaw, euler_conncected.y(), euler_conncected.z());
                problem.AddResidualBlock(cost_function, loss_function, euler_array_main[i_main-j],
                                         t_array_main[i_main-j],
                                         euler_array_main[i_main],
                                         t_array_main[i_main]);
            }
            else
            {
                break;
            }
            j++;
        }

        //        添加的是闭环边，是指检测到闭环的两帧
        if((*it_main)->is_get_loop_info   )
        {
            if((*it_main)->loop_index >= earliest_loop_index_main)
            {
                int connected_index = pMainMap->getKeyframe((*it_main)->loop_index)->resample_globalIndex;

                Vector3d euler_conncected = Utility::R2ypr(q_array_main[connected_index].toRotationMatrix());
                Vector3d relative_t((*it_main)->loop_info_better(0), (*it_main)->loop_info_better(1), (*it_main)->loop_info_better(2));
                double relative_yaw = (*it_main)->loop_info_better(3);

                ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),
                                                                                relative_yaw, euler_conncected.y(), euler_conncected.z(),10.0);
                problem.AddResidualBlock(cost_function, NULL, euler_array_main[connected_index],
                                         t_array_main[connected_index],
                                         euler_array_main[i_main],
                                         t_array_main[i_main]);
            }else{
                assert(false);
            }
        }

        if ((*it_main)->global_index == latest_loop_index_main)
            break;
        i_main++;
    }
    
    
    //*************************************第一个数据
    //遍历关键帧列表
    list<KeyFrame*>::iterator it_other = pCurMap->keyFrameList.begin();

    Vector3d last_P_other = Vector3d(0, 0, 0);
    double dis_other = 0;
    
//    pCurMap->clear_kf_id_hasComPlace_withOtherMap();
//    pCurMap->clear_r_global_multiClient();
//    pCurMap->clear_t_global_multiClient();
    
//    pCurMap->special_kf_inOpti.clear();
    vector<int> special_kf_inOpti_cur;
    vector<int> kf_id_hasCom_cur;
    //小地图是从第一个帧开始优化
    for(;it_other!=pCurMap->keyFrameList.end();it_other++){
        Vector3d tmp_t;
        Matrix3d tmp_r;
        //获取关键帧it的位姿
        (*it_other)->getPose(tmp_t, tmp_r);
        dis_other += (tmp_t - last_P_other).norm();
        
        
        //全局优化 还是要加序列边 不然太长了 判断条件 再加个两个地图之间发生了融合
        //第一个地图融合位置，超过长度了，发生过回环，被回环了，总共的帧长度比最大值小
        //还要再加一个 发生了融合，被融合了
        if((*it_other)->global_index == 0 || dis_other > min_dis_other || (*it_other)->is_get_loop_info || (*it_other)->is_looped || (*it_other)->has_global_loop || (*it_other)->is_global_looped || pCurMap->keyFrameList.size() < max_frame_num_global_other)
        {
            dis_other = 0;
            last_P_other = tmp_t;
            need_resample_other.push_back(0);
            
//            pCurMap->special_kf_inOpti.push_back((*it_other)->global_index);
            special_kf_inOpti_cur.push_back((*it_other)->global_index);
            
            if(((*it_other)->has_global_loop || (*it_other)->is_global_looped) && (*it_other)->is_Send==false ){
                kf_id_hasCom_cur.push_back((*it_other)->global_index);
//                pCurMap->add2_kf_id_hasComPlace_withOtherMap((*it_other)->global_index);
                (*it_other)->is_Send=true;
            }
        }
        else
        {
            last_P_other = tmp_t;
            need_resample_other.push_back(1);
        }
    }
    
    pCurMap->special_kf_mutex.lock();
    pCurMap->add2_kf_id_hasComPlace_withOtherMap(kf_id_hasCom_cur);
    pCurMap->special_kf_inOpti.push(special_kf_inOpti_cur);
    pCurMap->special_kf_mutex.unlock();

    int i_other = 0;
    for (it_other = pCurMap->keyFrameList.begin(); it_other != pCurMap->keyFrameList.end(); it_other++)
    {
        (*it_other)->resample_globalIndex = i_other;
        Quaterniond tmp_q;
        Matrix3d tmp_r;
        Vector3d tmp_t;
        (*it_other)->getOriginPose(tmp_t, tmp_r);

        
        tmp_q=tmp_r;
        t_array_other[i_other][0]=tmp_t[0];
        t_array_other[i_other][1]=tmp_t[1];
        t_array_other[i_other][2]=tmp_t[2];
        q_array_other[i_other]=tmp_q;
        //将矩阵转换为向量
        Vector3d euler_angle = Utility::R2ypr(tmp_r);
        euler_array_other[i_other][0] = euler_angle.x();
        euler_array_other[i_other][1] = euler_angle.y();
        euler_array_other[i_other][2] = euler_angle.z();
        //将关键帧列表中所有index>=earliest_loop_index的关键帧的位姿加入到参数块当中
        problem.AddParameterBlock(euler_array_other[i_other], 1, angle_local_parameterization);
        problem.AddParameterBlock(t_array_other[i_other], 3);


        if(need_resample_other[i_other])
        {
            i_other++;
            continue;
        }


        int j = 1, sequence_link_cnt = 0;
        while(sequence_link_cnt < 5)
        {
            if (i_other - j >= 0)
            {
//                        list<KeyFrame*>::iterator tmp = it_other;
//                        std::advance (tmp, -j);
                if(need_resample_other[i_other-j])
                {
                    j++;
                    continue;
                }
                else
                {
                    sequence_link_cnt++;
                }
                Vector3d euler_conncected = Utility::R2ypr(q_array_other[i_other-j].toRotationMatrix());
                //p̂_j^w - p̂_i^w 计算平移量的偏差
                Vector3d relative_t(t_array_other[i_other][0] - t_array_other[i_other-j][0], t_array_other[i_other][1] - t_array_other[i_other-j][1], t_array_other[i_other][2] - t_array_other[i_other-j][2]);
                //p̂_{ij}^{i} = {R̂_i^w}^{-1} (p̂_j^w - p̂_i^w)
                //p̂ ij= (R̂ iw ) (p̂ jw − p̂ iw )
                relative_t = q_array_other[i_other-j].inverse() * relative_t;
                //ψ̂ _ij = ψ̂ _j − ψ̂ _i
                double relative_yaw = euler_array_other[i_other][0] - euler_array_other[i_other-j][0];
                ceres::CostFunction* cost_function = FourDOFError_another::Create( relative_t.x(), relative_t.y(), relative_t.z(),
                                                                          relative_yaw, euler_conncected.y(), euler_conncected.z());
                problem.AddResidualBlock(cost_function, loss_function, euler_array_other[i_other-j],
                                         t_array_other[i_other-j],
                                         euler_array_other[i_other],
                                         t_array_other[i_other]);
            }
            else
            {
                break;
            }
            j++;
        }

        //        添加的是闭环边，是指检测到闭环的两帧 一个数据拆成两份 这个注释掉了
        if((*it_other)->is_get_loop_info)
        {
            //这里后面还要添加else
            if((*it_other)->loop_index <0)
            {
                assert(false);
            }
            //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束
            int connected_index = pCurMap->getKeyframe((*it_other)->loop_index)->resample_globalIndex;

            Vector3d euler_conncected = Utility::R2ypr(q_array_other[connected_index].toRotationMatrix());
            Vector3d relative_t((*it_other)->loop_info_better(0), (*it_other)->loop_info_better(1), (*it_other)->loop_info_better(2));
            double relative_yaw = (*it_other)->loop_info_better(3);

//                    cout<<fixed<<setprecision(6)<<"(*it_other)->loop_info(0)"<<(*it_other)->loop_info_better(0)<<" (*it_other)->loop_info(1)"<<(*it_other)->loop_info_better(1)<<" (*it_other)->loop_info(2)"<<(*it_other)->loop_info_better(2)<<" (*it_other)->loop_info(7)"<<(*it_other)->loop_info_better(3)<<" "<<(*it_other)->header<<" "<<pCurMap->getKeyframe((*it_other)->global_index)->header<<endl;

            ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z(),10.0);
            problem.AddResidualBlock(cost_function, NULL, euler_array_other[connected_index],
                                     t_array_other[connected_index],
                                     euler_array_other[i_other],
                                     t_array_other[i_other]);
            
        }
        
        if((*it_other)->has_global_loop)
       {
           //这里后面还要添加else
           if((*it_other)->global_loop_index < earliest_loop_index_main)
           {
               //因为这意味着数据保存出错了 发生了融合的帧的id小于最早发生融合的id
               assert(false);
               return;
           }
           //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束
           int connected_index = pMainMap->getKeyframe((*it_other)->global_loop_index)->resample_globalIndex;
           
//                   cout<<"global fuse has_global_loop"<<(*it_other)->global_loop_index<<" "<<connected_index<<" "<<keyFrameList_merge.size()<<endl;
           Vector3d euler_conncected = Utility::R2ypr(q_array_main[connected_index].toRotationMatrix());
           Vector3d relative_t((*it_other)->global_loop_info(0), (*it_other)->global_loop_info(1), (*it_other)->global_loop_info(2));
           double relative_yaw = (*it_other)->global_loop_info(7);
//                   double relative_pitch =(*it_other)->global_relative_pitch;
//                   double relative_roll=(*it_other)->global_relative_roll;

//           cout<<"(*it_other)->global_loop_info(0)"<<(*it_other)->global_loop_info(0)<<" (*it_other)->global_loop_info(1)"<<(*it_other)->global_loop_info(1)<<" (*it_other)->global_loop_info(2)"<<(*it_other)->global_loop_info(2)<<" (*it_other)->global_loop_info(7)"<<(*it_other)->global_loop_info(7)<<" "<<(*it_other)->global_index<<" "<<(*it_other)->header<<" "<<pMainMap->getKeyframe((*it_other)->global_loop_index)->header<<endl;
           
           //这里到时候 再写一个求导的
           ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z(),10.0);
           problem.AddResidualBlock(cost_function, NULL, euler_array_main[connected_index],
                                    t_array_main[connected_index],
                                    euler_array_other[i_other],
                                    t_array_other[i_other]);
       }
        if ((*it_other)->global_index == latest_loop_index_cur)
            break;
        i_other++;
    }

    ceres::Solve(options, &problem, &summary);
    
    std::cout << "global fuse: "<<summary.BriefReport() << "\n";
     
    //------------------------------------------第一个数据优化后更新
    //优化完成，使用优化后的位姿来更新关键帧列表中index大于等于earliest_loop_index的所有关键帧的位姿
    i_other = 0;
    Vector3d t_drift_it_other = Vector3d::Zero();
    Matrix3d r_drift_it_other = Matrix3d::Identity();
    
    vector<Matrix3d> r_global_cur;
    vector<Vector3d> t_global_cur;
    for (it_other = pCurMap->keyFrameList.begin(); it_other != pCurMap->keyFrameList.end(); it_other++)
    {
        
        Quaterniond tmp_q;
        //向量转换为矩阵
        tmp_q = Utility::ypr2R(Vector3d(euler_array_other[i_other][0], euler_array_other[i_other][1], euler_array_other[i_other][2]));
        Vector3d tmp_w1_t = Vector3d(t_array_other[i_other][0], t_array_other[i_other][1], t_array_other[i_other][2]);
        Matrix3d tmp_w1_r = tmp_q.toRotationMatrix();
       
        if(need_resample_other[i_other])
        {
            (*it_other)-> updatePose(r_drift_it_other * tmp_w1_t + t_drift_it_other, r_drift_it_other * tmp_w1_r);
        }
        else
        {
            Vector3d origin_t_it;
            Matrix3d origin_r_it;
            (*it_other)->getOriginPose(origin_t_it, origin_r_it);
            
            
            r_drift_it_other = tmp_w1_r * origin_r_it.transpose();
            t_drift_it_other = tmp_w1_t - r_drift_it_other * origin_t_it;
            (*it_other)-> updatePose(tmp_w1_t, tmp_w1_r);
            
//            pCurMap->add2_r_global_multiClient(tmp_w1_r);
//            pCurMap->add2_t_global_multiClient(tmp_w1_t);
            r_global_cur.push_back(tmp_w1_r);
            t_global_cur.push_back(tmp_w1_t);
        }
        if ((*it_other)->global_index == latest_loop_index_cur)
            break;
        i_other++;
        
    }
    
    //如果将地图建模成可变形的呢
    //根据计算出当前帧的drift，更新全部关键帧位姿
    Vector3d cur_t_other, origin_t_other;
    Matrix3d cur_r_other, origin_r_other;
    //获取优化后当前帧的位姿cur_t,cur_r
    (*it_other)->getPose(cur_t_other, cur_r_other);
    //获取优化前有漂移的当前帧的位姿vio_t,vio_r
    (*it_other)->getOriginPose(origin_t_other, origin_r_other);
    pCurMap->yaw_drift = Utility::R2ypr(cur_r_other).x() - Utility::R2ypr(origin_r_other).x();
    pCurMap->r_drift = Utility::ypr2R(Vector3d(pCurMap->yaw_drift, 0, 0));
    pCurMap->t_drift = cur_t_other - pCurMap->r_drift * origin_t_other;
    
//    pCurMap->add2_r_global_multiClient(pCurMap->r_drift);
//    pCurMap->add2_t_global_multiClient(pCurMap->t_drift);
    r_global_cur.push_back(pCurMap->r_drift);
    t_global_cur.push_back(pCurMap->t_drift);
    pCurMap->add2_r_global_multiClient(r_global_cur);
    pCurMap->add2_t_global_multiClient(t_global_cur);

    //下面代码为把当前关键帧it之后的关键帧的位姿通过求解的偏移量转换到world坐标系下
    for (; it_other != pCurMap->keyFrameList.end(); it_other++)
    {
        Vector3d P;
        Matrix3d R;
        (*it_other)->getOriginPose(P, R);
        P = pCurMap->r_drift * P + pCurMap->t_drift;
        R = pCurMap->r_drift * R;
        (*it_other)-> updatePose(P, R);
    }
    pCurMap->lastKF_index.push(pCurMap->keyFrameList.back()->global_index);
    
    //---------------------------------------第2个数据的更新
    //优化完成，使用优化后的位姿来更新关键帧列表中index大于等于earliest_loop_index的所有关键帧的位姿
    i_main = 0;
    Vector3d t_drift_it_main = Vector3d::Zero();
    Matrix3d r_drift_it_main = Matrix3d::Identity();
    
    vector<Matrix3d> r_global_main;
    vector<Vector3d> t_global_main;
    for (it_main = pMainMap->keyFrameList.begin(); it_main != pMainMap->keyFrameList.end(); it_main++)
    {
        if ((*it_main)->global_index < earliest_loop_index_main)
            continue;

        Quaterniond tmp_q;
        //向量转换为矩阵
        tmp_q = Utility::ypr2R(Vector3d(euler_array_main[i_main][0], euler_array_main[i_main][1], euler_array_main[i_main][2]));
        Vector3d tmp_w1_t = Vector3d(t_array_main[i_main][0], t_array_main[i_main][1], t_array_main[i_main][2]);
        Matrix3d tmp_w1_r = tmp_q.toRotationMatrix();

//                cout<<"测试 优化完成 更新哪里变了："<<euler_array_main[i_main][0]<<" "<<euler_array_main[i_main][1]<<" "<<euler_array_main[i_main][2]<<" "<<t_array_main[i_main][0]<<" "<<t_array_main[i_main][1]<<" "<<t_array_main[i_main][2]<<" "<<i_main<<endl;
        if(need_resample_main[i_main])
        {
            (*it_main)-> updatePose(r_drift_it_main * tmp_w1_t + t_drift_it_main, r_drift_it_main * tmp_w1_r);
        }
        else
        {
            Vector3d origin_t_it;
            Matrix3d origin_r_it;
            (*it_main)->getOriginPose(origin_t_it, origin_r_it);
            r_drift_it_main = tmp_w1_r * origin_r_it.transpose();
            t_drift_it_main = tmp_w1_t - r_drift_it_main * origin_t_it;
            (*it_main)-> updatePose(tmp_w1_t, tmp_w1_r);
            
//            pMainMap->add2_r_global_multiClient(tmp_w1_r);
//            pMainMap->add2_t_global_multiClient(tmp_w1_t);
            r_global_main.push_back(tmp_w1_r);
            t_global_main.push_back(tmp_w1_t);

        }
        if ((*it_main)->global_index == latest_loop_index_main)
            break;
        i_main++;

    }
    //根据计算出当前帧的drift，更新全部关键帧位姿
    Vector3d cur_t_main, origin_t_main;
    Matrix3d cur_r_main, origin_r_main;
    //获取优化后当前帧的位姿cur_t,cur_r
    (*it_main)->getPose(cur_t_main, cur_r_main);
    //获取优化前有漂移的当前帧的位姿vio_t,vio_r
    (*it_main)->getOriginPose(origin_t_main, origin_r_main);
    pMainMap->yaw_drift = Utility::R2ypr(cur_r_main).x() - Utility::R2ypr(origin_r_main).x();
    pMainMap->r_drift = Utility::ypr2R(Vector3d(pMainMap->yaw_drift, 0, 0));
    pMainMap->t_drift = cur_t_main - pMainMap->r_drift * origin_t_main;
    
//    pMainMap->add2_r_global_multiClient(pMainMap->r_drift);
//    pMainMap->add2_t_global_multiClient(pMainMap->t_drift);
    r_global_main.push_back(pMainMap->r_drift);
    t_global_main.push_back(pMainMap->t_drift);
    pMainMap->add2_r_global_multiClient(r_global_main);
    pMainMap->add2_t_global_multiClient(t_global_main);

    //下面代码为把当前关键帧it之后的关键帧的位姿通过求解的偏移量转换到world坐标系下
    for (; it_main != pMainMap->keyFrameList.end(); it_main++)
    {
        Vector3d P;
        Matrix3d R;
        (*it_main)->getOriginPose(P, R);
        P = pMainMap->r_drift * P + pMainMap->t_drift;
        R = pMainMap->r_drift * R;
        (*it_main)-> updatePose(P, R);
    }
    
    pCurMap->isFirstFusion_globalMutex.unlock();
    
    
    
    
    
    pMainMap->lastKF_index.push(pMainMap->keyFrameList.back()->global_index);
//            位姿更新都留到显示那里
    pMainMap->updateVisualization();
    pCurMap->refine_path_mutex.lock();
    pMainMap->fusion_relative_isUpdate[i]=0;
    pCurMap->refine_path_mutex.unlock();
    //发送数据
    pMainMap->isSendGloablData_multiClient=true;
    
    
    
    pCurMap->updateVisualization();
    pCurMap->isSendGloablData_multiClient=true;
    
//    cout<<"测试 偏移对不对"<<pCurMap->t_drift[0]<<" "<<pCurMap->t_drift[1]<<" "<<pCurMap->t_drift[2]<<endl;
    
    
}


//这个是多机器人同时跑的版本 和主地图去匹配 传过来的是主地图 这里应该是主地图去调用
//其它地图的3D点，主地图的2D点
//第二篇论文最终版
void PoseGraphGlobal::loopClosureRun_global_14_1(int clientId_main){
    
    assert(clientId_main==mainClientID);
    //-------------找到主地图，即调用该方法的地图-------------------------
//    poseGraphGlobal_mutex.lock();
    readWriteLock.readLock();
    

    map<int,PoseGraph*>::iterator iter_map = PoseGraphGloabl_map.find(clientId_main);
    if(iter_map==PoseGraphGloabl_map.end())
    {
//        poseGraphGlobal_mutex.unlock();
        readWriteLock.readUnLock();
        assert(false);//找不到地图是不应该的
        return ;
    }
    PoseGraph* poseGraph_main=iter_map->second;
//    poseGraphGlobal_mutex.unlock();
    readWriteLock.readUnLock();
    list<KeyFrame*> keyFrameList_main=poseGraph_main->keyFrameList;
    
   
    //实验用 记录是不是最后的结束部分了
    bool isEnd=true;
     
     //---------------拿其它所有地图和主地图去做比较
//    poseGraphGlobal_mutex.lock();
    readWriteLock.readLock();
    for(auto iter_end=PoseGraphGloabl_map.end();--iter_end , iter_map!=iter_end;){
        //-------------遍历的其它地图
        PoseGraph* poseGraph_other=iter_end->second;
        int clientId_other=iter_end->first;
        list<KeyFrame*> keyFrameList_other=poseGraph_other->keyFrameList;
        //-------------其它地图和调用该方法的地图ID 应该不一样才对
        if(clientId_other!=clientId_main){
            //---------实验用 判断程序结束没
            if(poseGraph_other->isEnd==false){
                isEnd=false;
            }
            //---------因为是做回环，所以其它地图里面要有关键帧
            if(keyFrameList_other.size()>0){
                //-----拿其它地图里面，最新的关键帧和主地图做匹配
                KeyFrame* iter_kf_other=poseGraph_other->getLastKeyframe();
                if(iter_kf_other->check_global_loop[clientId_main]==false && iter_kf_other->is_des_end){
                    iter_kf_other->check_global_loop[clientId_main]=true;
                    isEnd=false;
                    //---------去DBOW里面做检索
                    bool loop_succ=false;
                    int old_index=-1;//这个后续要记录住的 我暂时还没记录 记录了
                    vector<cv::Point2f> cur_pts;
                    vector<cv::Point2f> old_pts;
                    int min_startDetect_id=0;
                    //这里修改一下，返回的序号 ！= kf id
                    poseGraph_main->isAddKF2Database_mutex.lock();
                    loop_succ = startLoopClosure_2(iter_kf_other->keypoints, iter_kf_other->descriptors, cur_pts, old_pts, old_index,min_startDetect_id,iter_kf_other->global_index, mainClientID, poseGraph_main->demo_global_in_poseGraph, clientId_other);//返回的应该是0号地图的哪一个帧
                    old_index=poseGraph_main->treeId_kf[old_index];
                    assert(old_index!=-1);
                    poseGraph_main->isAddKF2Database_mutex.unlock();
                    //---------检测成功
                    if(loop_succ)
                     {
                         //检索到老帧 主地图的
                         list<KeyFrame*>::iterator main_kf_iter=poseGraph_main->getKeyframe_iter(old_index);
                          if(main_kf_iter==poseGraph_main->keyFrameList.end()){
                              assert(false);
                          }
                          KeyFrame* old_kf=(*main_kf_iter);
                          if (old_kf == NULL)
                          {
                              assert(false);//该关键帧不存在于主地图
                          }
                          
                          
                         
                         //这两个是粗糙的坐标
                          std::vector<cv::Point2f> measurements_old;//像素坐标
                          std::vector<cv::Point2f> measurements_old_norm;//图像坐标
                         //新帧iter_kf_other的3D点 老帧old_kf的2D点，主地图
                          iter_kf_other->findConnectionWithOldFrame_server_old(old_kf, measurements_old, measurements_old_norm);//找到匹配的特征点
//                         cout<<"measurements_old.size()<22 ="<<measurements_old.size()<<" "<<old_kf->header<<" ,"<<iter_kf_other->header<<endl;
                         if(measurements_old.size()<16){
                             
                             continue;
                         }
                         
                         Matrix3d R_relative;
                         Vector3d T_relative;
                         bool isSuccess=optiRelativePose_forMainMap(measurements_old_norm, iter_kf_other->point_clouds, old_kf, iter_kf_other, R_relative, T_relative);
                         if(isSuccess==false)
                             continue;
                         
                         //每个帧自己存一下和别人的相对位姿关系,只检索的帧存储
                         iter_kf_other->clientId.push_back(clientId_main);
                         iter_kf_other->kfId.push_back(old_kf->global_index);
                         iter_kf_other->relativePose.push_back(std::make_pair(R_relative, T_relative));
                         
                   
                          
                          bool isAdd_otherClientId=false;
                          if(poseGraph_main->fusion_relative_isUpdate[clientId_other]!=-2)
                              isAdd_otherClientId=true;
                          

                              
                              //保存信息 这里保存，暂时没用处，后续应该会删除 有用有用
                              old_kf->clientId_server.push_back(clientId_other);
                              old_kf->global_index_server.push_back(iter_kf_other->global_index);
                              
                              
                              feature_id_cur[clientId_other]=iter_kf_other->features_id;
                              measurements_norm_main[clientId_other]=measurements_old_norm;
           
                                  //这里表示 该地图第一次与主地图发生融合
                                  if(!isAdd_otherClientId){
                                     
                                      
                                      poseGraph_main->fusion_poseGraph_mutex.lock();
                                      poseGraph_main->fusion_otherGraph[clientId_other]=poseGraph_other;//记录副地图
                                      poseGraph_main->fusion_poseGraph_mutex.unlock();
                                      
                                      poseGraph_other->fusion_poseGraph_mutex.lock();
                                      poseGraph_other->fusion_otherGraph[clientId_main]=poseGraph_main;//记录副地图
                                      poseGraph_other->fusion_poseGraph_mutex.unlock();
                                      
                                  }

                                  //加锁
                                   poseGraph_other->isFirstFusion_globalMutex.lock();
                                  //2号帧在1号地图的位姿 前面算过了
                                  f_manager_server_main.feature.clear();
          
//                                  暂时注释
                         //主地图，其它地图
//                                  cur_globalFuse_index[clientId_other]=std::make_pair(old_index, iter_kf_other->global_index);
                         q_cur_globalFuse_index[clientId_other].push(std::make_pair(old_index, iter_kf_other->global_index));
                         isOpposite[clientId_other]=true;
                         
//                         cur_globalFuse_index[clientId_other]=std::make_pair(iter_kf_other->global_index，old_index);
                                  
//                                  if(isFirstFusion[clientId_other]==0)
//                                      isFirstFusion[clientId_other]=4;
//                                  else if(isFirstFusion[clientId_other]==3)
//                                      isFirstFusion[clientId_other]=6;
//                                  else
//                                      isFirstFusion[clientId_other]=5;
                         
                         isFirstFusion[clientId_other]+=1;
//                                  old_kf->relative_r_server.push_back(R_relative_best);
//                                  old_kf->relative_t_server.push_back(T_relative_best);
                                  poseGraph_other->isFirstFusion_globalMutex.unlock();
                                  cout<<"地图融合成功"<<endl;
                                  usleep(10);

                          }else{
//                              cout<<"地图融合失败"<<检测不成功<<endl;
                              usleep(10);
                          }
                          
                     
                                 
                }
            }
        }
    
    }
//    poseGraphGlobal_mutex.unlock();
    readWriteLock.readUnLock();
   
 
    usleep(30);


}

//这个是多机器人同时跑的版本 主地图和其他人做匹配 传过来的是其它地图 这里应该是其它地图去调用
//主地图的3D点，其它地图的2D点
//第二篇论文最终版
void PoseGraphGlobal::loopClosureRun_global_14_1_2(int clientId_other){
    //加一下锁试试
//    poseGraphGlobal_mutex.lock();
    readWriteLock.readLock();
    map<int,PoseGraph*>::iterator iter=PoseGraphGloabl_map.begin();
    int clientId_main=iter->first;
    assert(clientId_main==mainClientID);//验证一下是不是主地图
    PoseGraph* poseGraph_main=iter->second;
    //实验用 记录是不是最后的结束部分了
    bool isEnd=true;
        
    // 再加个判断 当前帧是否已经做过回环了 加了
    //其余所有人 都和第一个地图去比较
    
    map<int,PoseGraph*>::iterator iter_map = PoseGraphGloabl_map.find(clientId_other);
    //clientID不太对
    if(iter_map==PoseGraphGloabl_map.end())
    {
//        poseGraphGlobal_mutex.unlock();
        readWriteLock.readUnLock();
        assert(false);//找不到地图是不应该的
        return ;
    }
    PoseGraph* poseGraph_other=iter_map->second;
//    poseGraphGlobal_mutex.unlock();
    readWriteLock.readUnLock();
    
    list<KeyFrame*> keyFrameList_main=poseGraph_main->keyFrameList;
    list<KeyFrame*> keyFrameList_other=poseGraph_other->keyFrameList;
    
        
        //实验用 判断程序结束没
        if(poseGraph_other->isEnd==false){
            isEnd=false;
        }
        
        if(keyFrameList_main.size()>0){
            KeyFrame* iter_kf_main=poseGraph_main->getLastKeyframe();
            if(iter_kf_main->check_global_loop[clientId_other]==false && iter_kf_main->is_des_end){
                iter_kf_main->check_global_loop[clientId_other]=true;
                isEnd=false;
        
                bool loop_succ=false;
                int old_index=-1;//这个后续要记录住的 我暂时还没记录 记录了
                
                vector<cv::Point2f> cur_pts;
                vector<cv::Point2f> old_pts;
                int min_startDetect_id=0;

                poseGraph_other->isAddKF2Database_mutex.lock();
                loop_succ = startLoopClosure_2(iter_kf_main->keypoints, iter_kf_main->descriptors,  old_pts, cur_pts, old_index,min_startDetect_id,iter_kf_main->global_index, clientId_other, poseGraph_other->demo_global_in_poseGraph, clientId_main);//返回的应该是其它地图的哪一个帧
                old_index=poseGraph_other->treeId_kf[old_index];
                poseGraph_other->isAddKF2Database_mutex.unlock();
                
                
                if(loop_succ)
                 {
                     list<KeyFrame*>::iterator cur_kf_iter=poseGraph_other->getKeyframe_iter(old_index);
                      if(cur_kf_iter==poseGraph_other->keyFrameList.end()){
                          assert(false);
                      }
                      KeyFrame* cur_kf=(*cur_kf_iter);
                      if (cur_kf == NULL)
                      {
//                          printf("cur loopClosureRun_global NO such %dth frame in keyframe_database\n", old_index);
                          assert(false);
                      }
//                      printf("loopClosureRun_global loop succ with %drd image\n", old_index);
                      assert(old_index!=-1);
              
                      Vector3d T_w_i_cur;
                      Matrix3d R_w_i_cur;
                      cur_kf->getPose(T_w_i_cur, R_w_i_cur);
                      //老帧的位姿
                      Matrix3f r_curKF_f_real=R_w_i_cur.cast<float>();
                      Vector3f t_curKF_f_real=T_w_i_cur.cast<float>();
                     
                     
                      std::vector<cv::Point2f> measurements_cur;//像素坐标
                      std::vector<cv::Point2f> measurements_cur_norm;//图像坐标
//                      std::vector<int> features_id;
                      //老帧的3D点  新帧的2D点
                      iter_kf_main->findConnectionWithOldFrame_server_old(cur_kf, measurements_cur, measurements_cur_norm);//找到匹配的特征点
                      //这里本来用的measurements_cur和keypoints_old匹配上的
//                     cout<<"measurements_cur.size()<22 ="<<measurements_cur.size()<<" "<<iter_kf_main->header<<" ,"<<cur_kf->header<<endl;
                     
                     if(measurements_cur.size()<16){
                         
                         return;
                     }
                     
                     
                     
                     Matrix3d R_relative;
                     Vector3d T_relative;
                     bool isSuccess=optiRelativePose_forMainMap(measurements_cur_norm, iter_kf_main->point_clouds, cur_kf, iter_kf_main, R_relative, T_relative);
                     if(isSuccess==false)
                         return;
                     
                     
                     //每个帧自己存一下和别人的相对位姿关系,只检索的帧存储
                     iter_kf_main->clientId.push_back(clientId_other);
                     iter_kf_main->kfId.push_back(cur_kf->global_index);
                     iter_kf_main->relativePose.push_back(std::make_pair(R_relative, T_relative));
                     
                    

                      
                      bool isAdd_otherClientId=false;
                      if(poseGraph_main->fusion_relative_isUpdate[clientId_other]!=-2)
                          isAdd_otherClientId=true;
                      
                      //这里表示 该地图第一次与主地图发生融合
                      if(!isAdd_otherClientId){
                         
                          poseGraph_main->fusion_poseGraph_mutex.lock();
                          poseGraph_main->fusion_otherGraph[clientId_other]=poseGraph_other;//记录副地图
                          poseGraph_main->fusion_poseGraph_mutex.unlock();
                          
                          poseGraph_other->fusion_poseGraph_mutex.lock();
                          poseGraph_other->fusion_otherGraph[clientId_main]=poseGraph_main;//记录副地图
                          poseGraph_other->fusion_poseGraph_mutex.unlock();
                          
                      }

                          //加锁
                           poseGraph_other->isFirstFusion_globalMutex.lock();
                
                          
                          
                          //这里存储的是 匹配帧 要保留的 被检索的帧，检索到的匹配帧 主地图，其它地图
//                          cur_globalFuse_index[clientId_other]=std::make_pair(iter_kf_main->global_index, old_index);
                     q_cur_globalFuse_index[clientId_other].push(std::make_pair(iter_kf_main->global_index, old_index));
                     isOpposite[clientId_other]=false;
                          
//                          if(isFirstFusion[clientId_other]==0)
//                              isFirstFusion[clientId_other]=4;
//                          else if(isFirstFusion[clientId_other]==3)
//                              isFirstFusion[clientId_other]=6;
//                          else
//                              isFirstFusion[clientId_other]=5;
                     
                     isFirstFusion[clientId_other]+=1;
                          poseGraph_other->isFirstFusion_globalMutex.unlock();
                          cout<<"地图融合成功"<<endl;
                          usleep(10);

                    }
                else{
//                    cout<<"地图融合失败"<<endl;
                    usleep(10);
                }
                    
            }
        }



}

//这里的思想还是和主地图进行融合，后面改一下
//第二篇论文最终版
void  PoseGraphGlobal::MergeLocal_17(){
    while(true){
        int len = sizeof(isFirstFusion) / sizeof(isFirstFusion[0]);//
//        poseGraphGlobal_mutex.lock();
        readWriteLock.readLock();
        if(PoseGraphGloabl_map.size()>1){
//            poseGraphGlobal_mutex.unlock();
            readWriteLock.readUnLock();
        for(int client_id=1;client_id<len;client_id++){//这里的i其实代表的就是 ClientId
//            poseGraphGlobal_mutex.lock();
            readWriteLock.readLock();
            map<int,PoseGraph*>::iterator iter_map = PoseGraphGloabl_map.find(client_id);
            if(iter_map==PoseGraphGloabl_map.end()){
//                poseGraphGlobal_mutex.unlock();
                readWriteLock.readUnLock();
                continue;
            }
            
            //第一步---------------------得到两个地图和两个匹配帧------------------------------------------------
            PoseGraph* pCurrentMap= iter_map->second;//新的地图 小的地图
            PoseGraph* pMergeMap=PoseGraphGloabl_map[0];//老的地图 主地图 精度更高
//            poseGraphGlobal_mutex.unlock();
            readWriteLock.readUnLock();
            
            pCurrentMap->isFirstFusion_globalMutex.lock();
//            if(!(isFirstFusion[client_id]==4 || isFirstFusion[client_id]==5 || isFirstFusion[client_id]==6))//这里就是下面是否进行操作的激活条件
//            {
//                pCurrentMap->isFirstFusion_globalMutex.unlock();
//                continue;
//            }
            if(isFirstFusion[client_id]==0)//这里就是下面是否进行操作的激活条件
            {
                pCurrentMap->isFirstFusion_globalMutex.unlock();
                continue;
            }
            
            //得到两个匹配的关键帧
            int curKF_global_index= q_cur_globalFuse_index[client_id].front().second;
            int mainKF_global_index=q_cur_globalFuse_index[client_id].front().first;
            q_cur_globalFuse_index[client_id].pop();
            bool isOppo=isOpposite[client_id];
            pCurrentMap->isFirstFusion_globalMutex.unlock();
            
            list<KeyFrame*>::iterator curKF_iter= pCurrentMap->keyFrameList.begin();
            advance(curKF_iter, curKF_global_index);
            KeyFrame* pCurKF;
            if(curKF_global_index<pCurrentMap->keyFrameList.size()){
                pCurKF=(*curKF_iter);
                if(pCurKF->global_index!=curKF_global_index){
                    assert(false);
                }
            }
            else{
                assert(false);
            }

            
            
            list<KeyFrame*>::iterator mainKF_iter= pMergeMap->keyFrameList.begin();
            advance(mainKF_iter, mainKF_global_index);
            KeyFrame* pMergeKF_main;
            if(mainKF_global_index<pMergeMap->keyFrameList.size()){
                pMergeKF_main=(*mainKF_iter);
                if(pMergeKF_main->global_index!=mainKF_global_index){
                    assert(false);
                }
            }
            else{
                assert(false);
            }
 
           
            
            if(isOppo){
                realMergeLocal_17(pCurKF,pMergeKF_main, pCurrentMap, pMergeMap,1);
            }
            else{
                realMergeLocal_17(pMergeKF_main, pCurKF, pMergeMap,pCurrentMap,2);
            }
                
              
            
        }
        }else{
//            poseGraphGlobal_mutex.unlock();
            readWriteLock.readUnLock();
            usleep(2000);
        }
        usleep(30);
    }
}

//第二篇论文最终版
void PoseGraphGlobal::realMergeLocal_17(KeyFrame* kf_3d, KeyFrame* kf_2d, PoseGraph* pg_3d, PoseGraph* pg_2d,int noMain){
    //第二步-------------------------根据前面求得的粗糙的相对位姿求得准确的相对位姿--------重投影找匹配点---------------------------
    vector<vector<cv::Point2f>> measurements_old_norm_all;
    vector<vector<Eigen::Vector3d>> point_clouds_all;
    std::vector<cv::Point2f> measurements_old_coarse;//像素坐标
    std::vector<cv::Point2f> measurements_old_norm_coarse;//图像坐标
    std::vector<Vector3d> point_3d_cur;
    std::vector<cv::Point2f> measurements_cur;//像素坐标
    
    //这里就是假设所有的都是正的
    vector<KeyFrame*> vpCovKFi_old=kf_2d->GetBestCovisibilityKeyFrames(5);
    vpCovKFi_old.push_back(vpCovKFi_old[0]);
    vpCovKFi_old[0]=kf_2d;
    Matrix3d oldKF_r;
    Vector3d oldKF_t;
    kf_2d->getOriginPose(oldKF_t, oldKF_r);
        
    
        
    vector<Matrix3d> oldR_b_a;
    vector<Vector3d> oldT_b_a;
    int temp_index=0;
    //先算出来 在当前帧误差下，世界坐标系 到 侯选帧的共视帧的位姿关系
    for(KeyFrame* pkFi_old: vpCovKFi_old){
        if(temp_index!=0){
            Matrix3d rwi_old;
            Vector3d twi_old;
            pkFi_old->getOriginPose(twi_old, rwi_old);
            
            Matrix3d r_b_a;
            Vector3d t_b_a;
            r_b_a=oldKF_r.transpose()* rwi_old;
            t_b_a=oldKF_r.transpose()*(twi_old-oldKF_t);
            oldR_b_a.push_back(r_b_a);
            oldT_b_a.push_back(t_b_a);
        }else{
            oldR_b_a.push_back(Matrix3d::Identity());
            oldT_b_a.push_back(Vector3d::Zero());
            temp_index++;//放这里就只要执行一次
        }
    }
    
    int similarNum=0;
    temp_index=0;
    vector<Matrix3d> old_r;
    vector<Vector3d> old_t;
    vector<int> vpkf_index;
    
    
    Matrix3d R_relative;
    Vector3d T_relative;
   
    vector<int> clientId=kf_3d->clientId;
    vector<int> kfId=kf_3d->kfId;
    vector<std::pair<Matrix3d , Vector3d >  > relativePose=kf_3d->relativePose;
    int client_matchId=kf_2d->c->id, kf2d_global_index=kf_2d->global_index;//这里表示主地图的意思，后面肯定要改
    for(int i=0, len=clientId.size();i<len;i++){
        if(clientId[i]==client_matchId && kfId[i]==kf2d_global_index){
            R_relative=relativePose[i].first;
            T_relative=relativePose[i].second;
        }
    }
   
    
    Client* client_cur=kf_2d->c;
    Matrix3d ric_curClient=client_cur->ric_client;
    Vector3d tic_curClient=client_cur->tic_client;
    Vector3d euler_angle_ric_main=Utility::R2ypr(ric_curClient);
    const float &fx = client_cur->FOCUS_LENGTH_X_server;
    const float &fy = client_cur->FOCUS_LENGTH_Y_server;
    const float &cx = client_cur->PX_server;
    const float &cy = client_cur->PY_server;
    
    
        
    for(KeyFrame* pkf_old:vpCovKFi_old){
        Matrix3d r_w_imuOld=R_relative*oldR_b_a[temp_index];
        Vector3d t_w_imuOld=R_relative*oldT_b_a[temp_index] +T_relative;
        Matrix3d r_w_camOld=r_w_imuOld*ric_curClient;
        Vector3d t_w_camOld=r_w_imuOld*tic_curClient+t_w_imuOld;
        Matrix3d r_camOld_w=r_w_camOld.transpose();
        old_r.push_back(r_camOld_w);
        old_t.push_back(-r_camOld_w*t_w_camOld);
        temp_index++;
        
    }
    
    while(!kf_3d->IsOriginUpdate){
        usleep(50);
    }
    std::vector<KeyFrame*> vpCovKFi_cur = kf_3d->GetBestCovisibilityKeyFrames(5);
    vpCovKFi_cur.push_back(vpCovKFi_cur[0]);
    vpCovKFi_cur[0] = kf_3d;
    
    
    {
        //当前帧的共视帧 与 侯选帧的2级共视帧的匹配，通过重投影找
        
        point_clouds_all.clear();
        measurements_old_norm_all.clear();
        vpkf_index.clear();
        for(KeyFrame* pKFi : vpCovKFi_cur){

            //描述符得全有
            if(!pKFi->is_des_end){
                continue;
            }
            
            vector<Eigen::Vector3d> point_clouds_origin_cur= pKFi->point_clouds_origin;
            std::vector<cv::Point2f> measurements_origin_cur=pKFi->measurements_origin;
            vector<cv::KeyPoint> keypoints_cur=pKFi->keypoints;
            int nPoints = point_clouds_origin_cur.size();
            int point2D_len_cur=keypoints_cur.size()-point_clouds_origin_cur.size();
           
//                int num=0;//记录匹配点的数量
            temp_index=0;//记录遍历到哪个帧了
            //这里应该遍历候选帧的共视帧 ，只要共视点数量超过一定阈值 22
            for(KeyFrame* pkFi_old: vpCovKFi_old)
            {
                

                //描述符得全有
                if(!pkFi_old->is_des_end){
                    temp_index++;
                    continue;
                }
                
                measurements_old_coarse.clear();
                measurements_old_norm_coarse.clear();
                point_3d_cur.clear();
                measurements_cur.clear();
            
                vector<cv::KeyPoint> keypoints_old=pkFi_old->keypoints;

                //这个得到的是到imu坐标系的位姿
                Matrix3d r_camOld_w=old_r[temp_index];
                Vector3d t_camOld_w=old_t[temp_index];
                
                for(int i=0;i<nPoints;i++){
                    Vector3d point_main=point_clouds_origin_cur[i];
                    //把主地图下 世界坐标系的点 转到小地图上一帧的图像坐标系上
                    Vector3d p3D_c2=r_camOld_w*point_main+t_camOld_w;
                    //深度必须为正
                    if(p3D_c2[2]<0.0 || p3D_c2[2]>30.0){
//                            cout<<"深度不为正"<<endl;
                        continue;
                    }
                    // 投影到图像上
                    double x = p3D_c2[0];
                    double y = p3D_c2[1];
                    double z = p3D_c2[2];
                    //这里可能得加一个畸变校正 应该可以不用去校正 把他投影在一个没有畸变的图像上
                    double u=fx*x/z+cx;
                    double v=fy*y/z+cy;
                  
                    
                    if(!pkFi_old->isInImage((float)u, (float)v)){
//                            cout<<"投影点不在图像内"<<endl;
                        continue;
                    }
                    
                    const vector<int> vIndices=pkFi_old->GetFeaturesInArea_1((float)u, (float)v, 20);
                    //这里可以改为30个像素里面找不到 再扩大到50个像素 暂时未做
                    if(vIndices.empty()){
                            cout<<"半径为20个像素 找不到点"<<endl;
                        continue;
                    }
                    //des和keypoints长度不一样
                    //找在这个半径内最相似的 这里可能有些问题 因为3D点的描述子 个人感觉有问题
                    BRIEF::bitset point_main_des=pKFi->descriptors[point2D_len_cur+i];
                    int bestDist = 256;
                    int bestIndex = -1;
                    for(vector<int>::const_iterator vit=vIndices.begin(), vit_end=vIndices.end(); vit!=vit_end; vit++)
                    {
    //                    cout<<"*vit"<<*vit<<endl;发现 keypoints数量不等于des数量
                        int dis = pkFi_old->HammingDis(point_main_des, pkFi_old->descriptors[*vit]);
                        if(dis < bestDist)
                        {
                            bestDist = dis;
                            bestIndex = *vit;
                        }
                    }
                    
                    if(bestDist<70){
//                                cout<<"最终选择的半径范围："<<u-keypoints_old[bestIndex].pt.x<<" ,"<<v-keypoints_old[bestIndex].pt.y<<endl;
                        point_3d_cur.push_back(point_main);
                        measurements_old_coarse.push_back(keypoints_old[bestIndex].pt);
                        measurements_cur.push_back(measurements_origin_cur[i]);
                        
                    }
                                
                }
                
                        cout<<"50个像素内,找到的点数："<<measurements_cur.size()<<endl;
                if(measurements_cur.size()>=22){
                    pKFi->rejectWithF_server_mapFuse(measurements_cur, measurements_old_coarse,point_3d_cur);
                            cout<<"f矩阵拒绝后的点数："<<measurements_cur.size()<<", "<<pKFi->global_index<<" ,"<<pkFi_old->global_index<<endl;
                    if(measurements_old_coarse.size()>16){
                    
                        cv::Point2f norm_pt;
                        int pCount=measurements_old_coarse.size();
                        for(int aa=0;aa<pCount;aa++){
                            norm_pt.x = (measurements_old_coarse[aa].x -  client_cur->PX_server)/ client_cur->FOCUS_LENGTH_X_server;
                            norm_pt.y = (measurements_old_coarse[aa].y -  client_cur->PY_server)/ client_cur->FOCUS_LENGTH_Y_server;
                            measurements_old_coarse[aa]=norm_pt;
                            
                        }
                        
                        point_clouds_all.push_back(point_3d_cur);
                        measurements_old_norm_all.push_back(measurements_old_coarse);

                        vpkf_index.push_back(temp_index);
                        similarNum++;

                    }
                    
                }
                
                temp_index++;
            }
        }
    }

    PoseGraph* pCurrentMap;
    int client_id,mainKF_global_index,curKF_global_index;
    if(noMain==1){
        pCurrentMap=pg_3d;
        client_id=kf_3d->c->id;
        mainKF_global_index=kf_2d->global_index;
        curKF_global_index=kf_3d->global_index;
    }
    else{
        pCurrentMap=pg_2d;
        client_id=kf_2d->c->id;
        mainKF_global_index=kf_3d->global_index;
        curKF_global_index=kf_2d->global_index;
    }
    
        if(similarNum>=2){
            int optiKf_num=vpkf_index.size()+2;
            //构造优化问题
            double t_array[optiKf_num][3];//平移数组，其中存放每个关键帧的平移向量
            Quaterniond q_array[optiKf_num];
            double euler_array[optiKf_num][3];

            ceres::Problem problem;
            ceres::Solver::Options options;
            //options.linear_solver_type = ceres::DENSE_NORMAL_CHOLESKY;
            options.linear_solver_type = ceres::DENSE_SCHUR;
            //options.minimizer_progress_to_stdout = true;
            options.max_num_iterations = 20;
            ceres::Solver::Summary summary;
            ceres::LossFunction *loss_function;
            loss_function = new ceres::HuberLoss(1.0);
            //AngleLocalParameterization类的主要作用是指定yaw角优化变量的迭代更新，重载了括号运算
            ceres::LocalParameterization* angle_local_parameterization = AngleLocalParameterization::Create();

            
            Matrix3d curKF_r;
            Vector3d curKF_t;
            kf_3d->getOriginPose(curKF_t, curKF_r);
            
            
            Matrix3d tmp_r_old;
            Vector3d tmp_t_old;
            t_array[0][0] = curKF_t(0);
            t_array[0][1] = curKF_t(1);
            t_array[0][2] = curKF_t(2);
            //将矩阵转换为向量
            Vector3d euler_angle_old = Utility::R2ypr(curKF_r);
            euler_array[0][0] = euler_angle_old.x();
            euler_array[0][1] = euler_angle_old.y();
            euler_array[0][2] = euler_angle_old.z();
            problem.AddParameterBlock(euler_array[0], 3);
            problem.AddParameterBlock(t_array[0], 3);

            
            //再加一个根据当前帧与侯选帧之间的匹配关系，构造最开始的那个3d点 到候选帧的误差
            map<int,int> resample;
            
            temp_index=0;
            for(int len=vpkf_index.size(); temp_index<len; temp_index++ ){
                
                int kf_index=temp_index+1;
                Matrix3d relative_r_b_a;
                Vector3d relative_t_b_a;
                relative_r_b_a=oldR_b_a[vpkf_index[temp_index]];
                relative_t_b_a=oldT_b_a[vpkf_index[temp_index]];
                Vector3d relative_r_b_a_euler=Utility::R2ypr(relative_r_b_a);
                
                map<int,int>::iterator iter;
                iter = resample.find(vpkf_index[temp_index]);
                if(iter != resample.end())
                {
                    kf_index=resample[vpkf_index[temp_index]];
                }
                else
                {
                    resample[vpkf_index[temp_index]]=kf_index;

                    t_array[kf_index][0] = relative_t_b_a(0);
                    t_array[kf_index][1] = relative_t_b_a(1);
                    t_array[kf_index][2] = relative_t_b_a(2);
                    euler_array[kf_index][0] = relative_r_b_a_euler.x();
                    euler_array[kf_index][1] = relative_r_b_a_euler.y();
                    euler_array[kf_index][2] = relative_r_b_a_euler.z();
                    problem.AddParameterBlock(euler_array[kf_index], 1, angle_local_parameterization);
                    problem.AddParameterBlock(t_array[kf_index], 3);
                   
                    ceres::CostFunction* cost_function = FourSixDOFError::Create( relative_t_b_a(0),relative_t_b_a(1),relative_t_b_a(2),relative_r_b_a_euler(0),1);
                    problem.AddResidualBlock(cost_function, loss_function, euler_array[kf_index],t_array[kf_index]);
                    
                }

                vector<Vector3d> point_single=point_clouds_all[temp_index];
                vector<cv::Point2f> measure_single=measurements_old_norm_all[temp_index];
                for(int a=0,b=point_single.size();a<b;a++){

                    //找到主地图那个点 所在帧的位姿
                    Vector3d pts_i = point_single[a];

                    //相机平面坐标
                    cv::Point2f pt=measure_single[a];

                    ceres::CostFunction* cost_function = FourSixDOFWeightError_reprojection_3::Create( pts_i.x(), pts_i.y(), pts_i.z(),pt.x, pt.y, tic_curClient[0], tic_curClient[1], tic_curClient[2], euler_angle_ric_main.x(), euler_angle_ric_main.y(), euler_angle_ric_main.z() ,relative_r_b_a_euler(1),relative_r_b_a_euler(2),100.0);
                    problem.AddResidualBlock(cost_function, loss_function, euler_array[0],t_array[0], euler_array[kf_index],t_array[kf_index]);
                    
                 }
            }
            
            
            ceres::Solve(options, &problem, &summary);
            std::cout <<"全局-精确相对位姿："<< summary.BriefReport() << "\n";

            if(summary.termination_type!=ceres::CONVERGENCE){
                pCurrentMap->isFirstFusion_globalMutex.lock();
                isFirstFusion[client_id]-=1;
                pCurrentMap->isFirstFusion_globalMutex.unlock();
                return;}
            
            
            
            Matrix3d Rs_i ;
            Vector3d Ps_i ;//当前帧
            kf_3d->getOriginPose(Ps_i, Rs_i);
            



            Vector3d q;
            q<<euler_array[0][0],euler_array[0][1],euler_array[0][2];
            Matrix3d Rs_loop = Utility::ypr2R(q);
            Vector3d Ps_loop = Vector3d( t_array[0][0],  t_array[0][1],  t_array[0][2]);

//求得的是3d到2d的关系
            Vector3d relative_t = Rs_loop.transpose() * (Ps_i - Ps_loop);
                Matrix3d relative_q = Rs_loop.transpose() * Rs_i;
            double relative_yaw = Utility::normalizeAngle(Utility::R2ypr(Rs_i).x() - Utility::R2ypr(Rs_loop).x());
            double relative_pitch = Utility::normalizeAngle(Utility::R2ypr(Rs_i).y() - Utility::R2ypr(Rs_loop).y());
            double relative_roll = Utility::normalizeAngle(Utility::R2ypr(Rs_i).z() - Utility::R2ypr(Rs_loop).z());
            Quaterniond rela_q=Quaterniond(relative_q);
            
            //实验记录
//            std::ofstream outFile;
//            //打开文件
//            outFile.open("/Users/zhangjianhua/Desktop/hh/VINS_MapFusion/VINS_MapFusion/data/"+
//                             to_string(kf_3d->global_index)+"&"+to_string(kf_3d->header)+"&"+to_string(kf_2d->global_index)+"&"+to_string(kf_2d->header)+".txt");
//            outFile.setf(ios::fixed, ios::floatfield);  // 设定为 fixed 模式，以小数点表示浮点数
//            outFile.precision(19);
//                //写入数据
////                outFile <<"测试是否存在误匹配，当前client.id:\n"<<kf_3d->c->id<<"\n当作帧的header:\n"<<kf_3d->header<<"\n当作帧的global_index:\n"<<kf_3d->global_index<<"\n2d帧的client.id:\n"<<kf_2d->c->id <<"\n2d帧的header:\n"<<kf_2d->header<<"\n2d帧的global_index:\n"<<kf_2d->global_index  <<"\n3d-2d的r:\n"<<rela_q<<"\n3d-2d的t\n"<<relative_t;
//            outFile <<kf_3d->c->id<<"\n"<<kf_3d->header<<"\n"<<kf_3d->global_index<<"\n"<<kf_2d->c->id <<"\n"<<kf_2d->header<<"\n"<<kf_2d->global_index  <<"\n"<<rela_q.x()<<"\n"<<rela_q.y()<<"\n"<<rela_q.z()<<"\n"<<rela_q.w()<<"\n"<<relative_t[0]<<"\n"<<relative_t[1]<<"\n"<<relative_t[2];
//                //关闭文件
//            outFile.close();
            
        
        
        kf_3d->update_globalLoopConnection(relative_t, rela_q, relative_yaw);
            kf_3d->global_relative_pitch=relative_pitch;
            kf_3d->global_relative_roll=relative_roll;
            kf_3d->detect_globalLoop(kf_2d->global_index);
        kf_2d->is_detected_globalLoop(kf_3d->global_index);
        
            
        pCurrentMap->is_fusion=1;
            
        pCurrentMap->isFirstFusion_globalMutex.lock();
       //找到了
            isFirstFusion[client_id]-=1;
//        int has_fusion_num=isFirstFusion[client_id];
//        if(has_fusion_num==4){
//            isFirstFusion[client_id]=1;
//        }else if(has_fusion_num==5){
//            isFirstFusion[client_id]=3;
//        }
//        else if(has_fusion_num==6){
//            isFirstFusion[client_id]=3;
//        }else{
//            assert(false);//都已经找到最老的回环了，竟然还没有记录已经发生过回环了
//        }
           
        //思考一下赋值
        std::pair<int, int> latest_index_test= latest_global_loop_index[client_id];
        int latest_index_main_test=latest_index_test.first;
        int latest_index_cur_test=latest_index_test.second;
        latest_index_main_test=latest_index_main_test>mainKF_global_index?latest_index_main_test:mainKF_global_index;
        latest_index_cur_test=latest_index_cur_test>curKF_global_index?latest_index_cur_test:curKF_global_index;
        latest_global_loop_index[client_id]=std::make_pair(latest_index_main_test, latest_index_cur_test);
        //记录主地图和其它地图最早的融合位置
        if(earliest_global_loop_index[client_id]==-1 || earliest_global_loop_index[client_id]>mainKF_global_index){
            earliest_global_loop_index[client_id]=mainKF_global_index;
        }
        pCurrentMap->isFirstFusion_globalMutex.unlock();
        
        pCurrentMap->start_global_fuse_opti_mutex.lock();
        pCurrentMap->start_global_fuse_opti=1;
        pCurrentMap->start_global_fuse_opti_mutex.unlock();
            
//            std::ofstream outFile;
//            //打开文件
//            outFile.open("/Users/zhangjianhua/Desktop/VINS_MapFusion/VINS_MapFusion/data/"+
//                         to_string(kf_3d->global_index)+"&"+to_string(kf_2d->global_index)+"&"+to_string(kf_3d->c->id)+".txt");
//
//
//                //写入数据
//                outFile << relative_t.x()<<","<<relative_t.y()<<","<< relative_t.z()<<","<<relative_q(0,0)<<","<<relative_q(0,1) <<","<<relative_q(0,2)<<","<< relative_q(1,0)<<","<<relative_q(1,1)<<","<<relative_q(1,2)<<","<< relative_q(2,0)<<","<< relative_q(2,1)<<","<<relative_q(2,2);
//
//            outFile<<"\n";
//
//            //关闭文件
//            outFile.close();
    }
    else{
        cout<<"全局匹配帧数不够="<<similarNum<<endl;
        pCurrentMap->isFirstFusion_globalMutex.lock();
//        if(isFirstFusion[client_id]==4){
//            isFirstFusion[client_id]=0;
//        }else if(isFirstFusion[client_id]==5){
//            isFirstFusion[client_id]=1;
//        }else if(isFirstFusion[client_id]==6){
//            isFirstFusion[client_id]=3;
//        }
        isFirstFusion[client_id]-=1;
        pCurrentMap->isFirstFusion_globalMutex.unlock();
    }
}

//基于6的基础改的
//第二篇论文最终版
void PoseGraphGlobal::GlobalFuse_8(int i){
            
    //因为现在写的都是和主地图发生地图融合 所以其中一个地图直接这么获取了
//    poseGraphGlobal_mutex.lock();
    readWriteLock.readLock();
    PoseGraph* pMainMap=PoseGraphGloabl_map[0];
    map<int,PoseGraph*>::iterator iter_map = PoseGraphGloabl_map.find(i);
    if(iter_map==PoseGraphGloabl_map.end())
    {
//        poseGraphGlobal_mutex.unlock();
        readWriteLock.readUnLock();
        assert(false);//都已经发生回环了，却找不到地图 说明数据插错了
        
    }
    
    PoseGraph* pCurMap= iter_map->second;
//    poseGraphGlobal_mutex.unlock();
    readWriteLock.readUnLock();
    
   
    
    int earliest_loop_index_main=pMainMap->earliest_loop_index;
    int earliest_global_looped_index_main=earliest_global_loop_index[i];
    if (earliest_loop_index_main > earliest_global_looped_index_main || earliest_loop_index_main == -1  )
        earliest_loop_index_main=earliest_global_looped_index_main;
    
    int latest_loop_index_main=pMainMap->latest_loop_index;
    int latest_global_looped_index_main=latest_global_loop_index[i].first;
    if (latest_global_looped_index_main > latest_loop_index_main)
        latest_loop_index_main=latest_global_looped_index_main;
    
    
    int latest_loop_index_cur=pCurMap->latest_loop_index;
    int latest_global_looped_index_cur=latest_global_loop_index[i].second;
    if (latest_global_looped_index_cur > latest_loop_index_cur)
        latest_loop_index_cur=latest_global_looped_index_cur;
    
//    isFirstFusion[i]=2;
   
    pMainMap->loop_index_multiClient.push(earliest_loop_index_main);
    pMainMap->curKF_loop_index_multiClient.push(latest_loop_index_main);
    pCurMap->isFirstFusion_globalMutex.lock();
    isFusion[i]=1;
    pCurMap->loop_index_multiClient.push(0);
    pCurMap->curKF_loop_index_multiClient.push(latest_loop_index_cur);
    pCurMap->isFirstFusion_globalMutex.unlock();
            
    //主地图从earliest_loop_index_main开始--当前帧结束
    //小地图从第一帧开始--当前发生回环的帧 这个有可能是回环帧，也有可能是融合帧
    
    ceres::Problem problem;
    ceres::Solver::Options options;
    //options.linear_solver_type = ceres::DENSE_NORMAL_CHOLESKY;
    options.linear_solver_type = ceres::DENSE_SCHUR;
    options.minimizer_progress_to_stdout = false;
    options.max_num_iterations = 6;
    ceres::Solver::Summary summary;
    ceres::LossFunction *loss_function;
    loss_function = new ceres::HuberLoss(1.0);
    //AngleLocalParameterization类的主要作用是指定yaw角优化变量的迭代更新，重载了括号运算
    ceres::LocalParameterization* angle_local_parameterization =
    AngleLocalParameterization::Create();
    
    
    double total_lenth_main=pMainMap->total_length;
    double total_lenth_other=pCurMap->total_length;
    //总的位姿长度 除以总的帧数
    double total_lenth_sum=total_lenth_main+total_lenth_other;
    int max_frame_num_global_main=(total_lenth_main/total_lenth_sum)*max_frame_num_global;
    int max_frame_num_global_other=max_frame_num_global-max_frame_num_global_main;
    double min_dis_main=total_lenth_main/max_frame_num_global_main;
    double min_dis_other=total_lenth_other/max_frame_num_global_other;
    cout<<"min_dis_main："<<min_dis_main<<" min_dis_other:"<<min_dis_other<<endl;
    
    //要优化的变量的最大个数 主地图
    int max_length_main=pMainMap->keyFrameList.size()+1;
    double t_array_main[max_length_main][3];//平移数组，其中存放每个关键帧的平移向量
    Quaterniond q_array_main[max_length_main];
    double euler_array_main[max_length_main][3];
    vector<bool> need_resample_main;
    
    //要优化的变量的最大个数 小地图
    int max_length_other=pCurMap->keyFrameList.size()+1;
    double t_array_other[max_length_other][3];//平移数组，其中存放每个关键帧的平移向量
    Quaterniond q_array_other[max_length_other];
    double euler_array_other[max_length_other][3];
    vector<bool> need_resample_other;
    
    pMainMap->max_frame_num_global=max_frame_num_global_main;
    pMainMap->min_dis=min_dis_main;
    pCurMap->max_frame_num_global=max_frame_num_global_other;
    pCurMap->min_dis=min_dis_other;
    
//    pMainMap->clear_kf_id_hasComPlace_withOtherMap();
//    pMainMap->clear_r_global_multiClient();
//    pMainMap->clear_t_global_multiClient();
    
//    pMainMap->special_kf_inOpti.clear();
    vector<int> special_kf_inOpti_main;
    vector<int> kf_id_hasComPlace_main;
    //遍历关键帧列表
    list<KeyFrame*>::iterator it_main = pMainMap->keyFrameList.begin();
    Vector3d last_P_main = Vector3d(0, 0, 0);
    double dis_main = 0;
    int resample_id=0;
    for(;it_main!=pMainMap->keyFrameList.end();it_main++){
        if((*it_main)->global_index < earliest_loop_index_main){
            continue;
        }
        (*it_main)->resample_globalIndex = resample_id;
        Vector3d tmp_t;
        Matrix3d tmp_r;
        //获取关键帧it的位姿
        (*it_main)->getPose(tmp_t, tmp_r);
        dis_main += (tmp_t - last_P_main).norm();
        //全局优化 还是要加序列边 不然太长了 判断条件 再加个两个地图之间发生了融合
        if((*it_main)->global_index == earliest_loop_index_main || dis_main > min_dis_main || (*it_main)->is_get_loop_info || (*it_main)->is_looped || (*it_main)->has_global_loop || (*it_main)->is_global_looped || pMainMap->keyFrameList.size() < max_frame_num_global_main)
        {
            dis_main = 0;
            last_P_main = tmp_t;
            need_resample_main.push_back(0);
            
//            pMainMap->special_kf_inOpti.push_back((*it_main)->global_index);
            special_kf_inOpti_main.push_back((*it_main)->global_index);
            
            if(((*it_main)->has_global_loop || (*it_main)->is_global_looped) && (*it_main)->is_Send==false ){
                kf_id_hasComPlace_main.push_back((*it_main)->global_index);
//                pMainMap->add2_kf_id_hasComPlace_withOtherMap((*it_main)->global_index);
                (*it_main)->is_Send=true;
            }
        }
        else
        {
            last_P_main = tmp_t;
            need_resample_main.push_back(1);
        }
        resample_id++;
    }
    
    pMainMap->special_kf_mutex.lock();
    pMainMap->add2_kf_id_hasComPlace_withOtherMap(kf_id_hasComPlace_main);
   pMainMap->special_kf_inOpti.push(special_kf_inOpti_main);
   pMainMap->special_kf_mutex.unlock();
    
    
    //遍历关键帧列表
    list<KeyFrame*>::iterator it_other = pCurMap->keyFrameList.begin();

    Vector3d last_P_other = Vector3d(0, 0, 0);
    double dis_other = 0;
    
    vector<int> special_kf_inOpti_cur;
    vector<int> kf_id_hasCom_cur;
    resample_id=0;
    //小地图是从第一个帧开始优化
    for(;it_other!=pCurMap->keyFrameList.end();it_other++){
        (*it_other)->resample_globalIndex = resample_id;
        
        Vector3d tmp_t;
        Matrix3d tmp_r;
        //获取关键帧it的位姿
        (*it_other)->getPose(tmp_t, tmp_r);
        dis_other += (tmp_t - last_P_other).norm();
        
        
        //全局优化 还是要加序列边 不然太长了 判断条件 再加个两个地图之间发生了融合
        //第一个地图融合位置，超过长度了，发生过回环，被回环了，总共的帧长度比最大值小
        //还要再加一个 发生了融合，被融合了
        if((*it_other)->global_index == 0 || dis_other > min_dis_other || (*it_other)->is_get_loop_info || (*it_other)->is_looped || (*it_other)->has_global_loop || (*it_other)->is_global_looped || pCurMap->keyFrameList.size() < max_frame_num_global_other)
        {
            dis_other = 0;
            last_P_other = tmp_t;
            need_resample_other.push_back(0);
            
//            pCurMap->special_kf_inOpti.push_back((*it_other)->global_index);
            special_kf_inOpti_cur.push_back((*it_other)->global_index);
            
            if(((*it_other)->has_global_loop || (*it_other)->is_global_looped) && (*it_other)->is_Send==false ){
                kf_id_hasCom_cur.push_back((*it_other)->global_index);
//                pCurMap->add2_kf_id_hasComPlace_withOtherMap((*it_other)->global_index);
                (*it_other)->is_Send=true;
            }
        }
        else
        {
            last_P_other = tmp_t;
            need_resample_other.push_back(1);
        }
        resample_id++;
    }
    pCurMap->special_kf_mutex.lock();
    pCurMap->add2_kf_id_hasComPlace_withOtherMap(kf_id_hasCom_cur);
    pCurMap->special_kf_inOpti.push(special_kf_inOpti_cur);
    pCurMap->special_kf_mutex.unlock();
    
    int i_main = 0;
    for (it_main = pMainMap->keyFrameList.begin(); it_main != pMainMap->keyFrameList.end(); it_main++)
    {
        if ((*it_main)->global_index < earliest_loop_index_main)
            continue;
//        (*it_main)->resample_globalIndex = i_main;
        Quaterniond tmp_q;
        Matrix3d tmp_r;
        Vector3d tmp_t;
        (*it_main)->getOriginPose(tmp_t, tmp_r);
//                (*it_main)->getPose(tmp_t, tmp_r);
        tmp_q = tmp_r;
        t_array_main[i_main][0] = tmp_t(0);
        t_array_main[i_main][1] = tmp_t(1);
        t_array_main[i_main][2] = tmp_t(2);
        q_array_main[i_main] = tmp_q;
        //将矩阵转换为向量
        Vector3d euler_angle = Utility::R2ypr(tmp_r);
        euler_array_main[i_main][0] = euler_angle.x();
        euler_array_main[i_main][1] = euler_angle.y();
        euler_array_main[i_main][2] = euler_angle.z();
        //将关键帧列表中所有index>=earliest_loop_index的关键帧的位姿加入到参数块当中
        problem.AddParameterBlock(euler_array_main[i_main], 1, angle_local_parameterization);
        problem.AddParameterBlock(t_array_main[i_main], 3);
        //设置约束：如果该帧是最早的闭环帧的情况下，则固定它的位姿
        if ((*it_main)->global_index == earliest_loop_index_main)
        {
            problem.SetParameterBlockConstant(euler_array_main[i_main]);
            problem.SetParameterBlockConstant(t_array_main[i_main]);
//                cout<<"测试 更新哪里变了："<<euler_array_main[i_main][0]<<" "<<euler_array_main[i_main][1]<<" "<<euler_array_main[i_main][2]<<" "<<t_array_main[i_main][0]<<" "<<t_array_main[i_main][1]<<" "<<t_array_main[i_main][2]<<" "<<i_main<<endl;
        }
        
        if(need_resample_main[i_main])
        {
            i_main++;
            continue;
        }
        
        
        int j = 1, sequence_link_cnt = 0;
        while(sequence_link_cnt < 5)
        {
            if (i_main - j >= 0)
            {
//                        list<KeyFrame*>::iterator tmp = it_main;
//                        std::advance (tmp, -j);
                if(need_resample_main[i_main-j])
                {
                    j++;
                    continue;
                }
                else
                {
                    sequence_link_cnt++;
                }
                Vector3d euler_conncected = Utility::R2ypr(q_array_main[i_main-j].toRotationMatrix());
                //p̂_j^w - p̂_i^w 计算平移量的偏差
                Vector3d relative_t(t_array_main[i_main][0] - t_array_main[i_main-j][0], t_array_main[i_main][1] - t_array_main[i_main-j][1], t_array_main[i_main][2] - t_array_main[i_main-j][2]);
                //p̂_{ij}^{i} = {R̂_i^w}^{-1} (p̂_j^w - p̂_i^w)
                //p̂ ij= (R̂ iw ) (p̂ jw − p̂ iw )
                relative_t = q_array_main[i_main-j].inverse() * relative_t;
                //ψ̂ _ij = ψ̂ _j − ψ̂ _i
                double relative_yaw = euler_array_main[i_main][0] - euler_array_main[i_main-j][0];
                ceres::CostFunction* cost_function = FourDOFError_another::Create( relative_t.x(), relative_t.y(), relative_t.z(),
                                                                          relative_yaw, euler_conncected.y(), euler_conncected.z());
                problem.AddResidualBlock(cost_function, loss_function, euler_array_main[i_main-j],
                                         t_array_main[i_main-j],
                                         euler_array_main[i_main],
                                         t_array_main[i_main]);
            }
            else
            {
                break;
            }
            j++;
        }

        //        添加的是闭环边，是指检测到闭环的两帧
        if((*it_main)->is_get_loop_info   )
        {
            if((*it_main)->loop_index >= earliest_loop_index_main)
            {
                int connected_index = pMainMap->getKeyframe((*it_main)->loop_index)->resample_globalIndex;

                Vector3d euler_conncected = Utility::R2ypr(q_array_main[connected_index].toRotationMatrix());
                Vector3d relative_t((*it_main)->loop_info_better(0), (*it_main)->loop_info_better(1), (*it_main)->loop_info_better(2));
                double relative_yaw = (*it_main)->loop_info_better(3);

                ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),
                                                                                relative_yaw, euler_conncected.y(), euler_conncected.z(),10.0);
                problem.AddResidualBlock(cost_function, NULL, euler_array_main[connected_index],
                                         t_array_main[connected_index],
                                         euler_array_main[i_main],
                                         t_array_main[i_main]);
            }else{
                assert(false);
            }
        }

        
        if((*it_main)->has_global_loop)
       {
           //这里后面还要添加else
           if((*it_main)->global_loop_index < 0)
           {
               //因为这意味着数据保存出错了 发生了融合的帧的id小于最早发生融合的id
               assert(false);
               return;
           }
           //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束 会出现空指针的问题
           int connected_index = pCurMap->getKeyframe((*it_main)->global_loop_index)->resample_globalIndex;
           
//                   cout<<"global fuse has_global_loop"<<(*it_main)->global_loop_index<<endl;
           Vector3d euler_conncected = Utility::R2ypr(q_array_other[connected_index].toRotationMatrix());
           Vector3d relative_t((*it_main)->global_loop_info(0), (*it_main)->global_loop_info(1), (*it_main)->global_loop_info(2));
           double relative_yaw = (*it_main)->global_loop_info(7);
//                   double relative_pitch =(*it_other)->global_relative_pitch;
//                   double relative_roll=(*it_other)->global_relative_roll;

//           cout<<"(*it_other)->global_loop_info(0)"<<(*it_other)->global_loop_info(0)<<" (*it_other)->global_loop_info(1)"<<(*it_other)->global_loop_info(1)<<" (*it_other)->global_loop_info(2)"<<(*it_other)->global_loop_info(2)<<" (*it_other)->global_loop_info(7)"<<(*it_other)->global_loop_info(7)<<" "<<(*it_other)->global_index<<" "<<(*it_other)->header<<" "<<pMainMap->getKeyframe((*it_other)->global_loop_index)->header<<endl;
           
           //这里到时候 再写一个求导的
           ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z(),10.0);
           problem.AddResidualBlock(cost_function, NULL, euler_array_other[connected_index],
                                    t_array_other[connected_index],
                                    euler_array_main[i_main],
                                    t_array_main[i_main]);
       }
        
        
        if ((*it_main)->global_index == latest_loop_index_main)
            break;
        i_main++;
    }
    
    
    //*************************************第一个数据
    
    
    

    int i_other = 0;
    for (it_other = pCurMap->keyFrameList.begin(); it_other != pCurMap->keyFrameList.end(); it_other++)
    {
//        (*it_other)->resample_globalIndex = i_other;
        Quaterniond tmp_q;
        Matrix3d tmp_r;
        Vector3d tmp_t;
        (*it_other)->getOriginPose(tmp_t, tmp_r);

        
        tmp_q=tmp_r;
        t_array_other[i_other][0]=tmp_t[0];
        t_array_other[i_other][1]=tmp_t[1];
        t_array_other[i_other][2]=tmp_t[2];
        q_array_other[i_other]=tmp_q;
        //将矩阵转换为向量
        Vector3d euler_angle = Utility::R2ypr(tmp_r);
        euler_array_other[i_other][0] = euler_angle.x();
        euler_array_other[i_other][1] = euler_angle.y();
        euler_array_other[i_other][2] = euler_angle.z();
        //将关键帧列表中所有index>=earliest_loop_index的关键帧的位姿加入到参数块当中
        problem.AddParameterBlock(euler_array_other[i_other], 1, angle_local_parameterization);
        problem.AddParameterBlock(t_array_other[i_other], 3);


        if(need_resample_other[i_other])
        {
            i_other++;
            continue;
        }


        int j = 1, sequence_link_cnt = 0;
        while(sequence_link_cnt < 5)
        {
            if (i_other - j >= 0)
            {
//                        list<KeyFrame*>::iterator tmp = it_other;
//                        std::advance (tmp, -j);
                if(need_resample_other[i_other-j])
                {
                    j++;
                    continue;
                }
                else
                {
                    sequence_link_cnt++;
                }
                Vector3d euler_conncected = Utility::R2ypr(q_array_other[i_other-j].toRotationMatrix());
                //p̂_j^w - p̂_i^w 计算平移量的偏差
                Vector3d relative_t(t_array_other[i_other][0] - t_array_other[i_other-j][0], t_array_other[i_other][1] - t_array_other[i_other-j][1], t_array_other[i_other][2] - t_array_other[i_other-j][2]);
                //p̂_{ij}^{i} = {R̂_i^w}^{-1} (p̂_j^w - p̂_i^w)
                //p̂ ij= (R̂ iw ) (p̂ jw − p̂ iw )
                relative_t = q_array_other[i_other-j].inverse() * relative_t;
                //ψ̂ _ij = ψ̂ _j − ψ̂ _i
                double relative_yaw = euler_array_other[i_other][0] - euler_array_other[i_other-j][0];
                ceres::CostFunction* cost_function = FourDOFError_another::Create( relative_t.x(), relative_t.y(), relative_t.z(),
                                                                          relative_yaw, euler_conncected.y(), euler_conncected.z());
                problem.AddResidualBlock(cost_function, loss_function, euler_array_other[i_other-j],
                                         t_array_other[i_other-j],
                                         euler_array_other[i_other],
                                         t_array_other[i_other]);
            }
            else
            {
                break;
            }
            j++;
        }

        //        添加的是闭环边，是指检测到闭环的两帧 一个数据拆成两份 这个注释掉了
        if((*it_other)->is_get_loop_info)
        {
            //这里后面还要添加else
            if((*it_other)->loop_index <0)
            {
                assert(false);
            }
            //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束
            int connected_index = pCurMap->getKeyframe((*it_other)->loop_index)->resample_globalIndex;

            Vector3d euler_conncected = Utility::R2ypr(q_array_other[connected_index].toRotationMatrix());
            Vector3d relative_t((*it_other)->loop_info_better(0), (*it_other)->loop_info_better(1), (*it_other)->loop_info_better(2));
            double relative_yaw = (*it_other)->loop_info_better(3);

//                    cout<<fixed<<setprecision(6)<<"(*it_other)->loop_info(0)"<<(*it_other)->loop_info_better(0)<<" (*it_other)->loop_info(1)"<<(*it_other)->loop_info_better(1)<<" (*it_other)->loop_info(2)"<<(*it_other)->loop_info_better(2)<<" (*it_other)->loop_info(7)"<<(*it_other)->loop_info_better(3)<<" "<<(*it_other)->header<<" "<<pCurMap->getKeyframe((*it_other)->global_index)->header<<endl;

            ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z(),10.0);
            problem.AddResidualBlock(cost_function, NULL, euler_array_other[connected_index],
                                     t_array_other[connected_index],
                                     euler_array_other[i_other],
                                     t_array_other[i_other]);
            
        }
        
        if((*it_other)->has_global_loop)
       {
           //这里后面还要添加else
           if((*it_other)->global_loop_index < earliest_loop_index_main)
           {
               //因为这意味着数据保存出错了 发生了融合的帧的id小于最早发生融合的id
               assert(false);
               return;
           }
           //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束
           int connected_index = pMainMap->getKeyframe((*it_other)->global_loop_index)->resample_globalIndex;
           
//                   cout<<"global fuse has_global_loop"<<(*it_other)->global_loop_index<<" "<<connected_index<<" "<<keyFrameList_merge.size()<<endl;
           Vector3d euler_conncected = Utility::R2ypr(q_array_main[connected_index].toRotationMatrix());
           Vector3d relative_t((*it_other)->global_loop_info(0), (*it_other)->global_loop_info(1), (*it_other)->global_loop_info(2));
           double relative_yaw = (*it_other)->global_loop_info(7);
//                   double relative_pitch =(*it_other)->global_relative_pitch;
//                   double relative_roll=(*it_other)->global_relative_roll;

//           cout<<"(*it_other)->global_loop_info(0)"<<(*it_other)->global_loop_info(0)<<" (*it_other)->global_loop_info(1)"<<(*it_other)->global_loop_info(1)<<" (*it_other)->global_loop_info(2)"<<(*it_other)->global_loop_info(2)<<" (*it_other)->global_loop_info(7)"<<(*it_other)->global_loop_info(7)<<" "<<(*it_other)->global_index<<" "<<(*it_other)->header<<" "<<pMainMap->getKeyframe((*it_other)->global_loop_index)->header<<endl;
           
           //这里到时候 再写一个求导的
           ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z(),10.0);
           problem.AddResidualBlock(cost_function, NULL, euler_array_main[connected_index],
                                    t_array_main[connected_index],
                                    euler_array_other[i_other],
                                    t_array_other[i_other]);
       }
        if ((*it_other)->global_index == latest_loop_index_cur)
            break;
        i_other++;
    }

    ceres::Solve(options, &problem, &summary);
    
    std::cout << "global fuse: "<<summary.BriefReport() << "\n";
     
    //------------------------------------------第一个数据优化后更新
    //优化完成，使用优化后的位姿来更新关键帧列表中index大于等于earliest_loop_index的所有关键帧的位姿
    i_other = 0;
    Vector3d t_drift_it_other = Vector3d::Zero();
    Matrix3d r_drift_it_other = Matrix3d::Identity();
    
    vector<Matrix3d> r_global_cur;
    vector<Vector3d> t_global_cur;
    for (it_other = pCurMap->keyFrameList.begin(); it_other != pCurMap->keyFrameList.end(); it_other++)
    {
        
        Quaterniond tmp_q;
        //向量转换为矩阵
        tmp_q = Utility::ypr2R(Vector3d(euler_array_other[i_other][0], euler_array_other[i_other][1], euler_array_other[i_other][2]));
        Vector3d tmp_w1_t = Vector3d(t_array_other[i_other][0], t_array_other[i_other][1], t_array_other[i_other][2]);
        Matrix3d tmp_w1_r = tmp_q.toRotationMatrix();
       
        if(need_resample_other[i_other])
        {
            (*it_other)-> updatePose(r_drift_it_other * tmp_w1_t + t_drift_it_other, r_drift_it_other * tmp_w1_r);
        }
        else
        {
            Vector3d origin_t_it;
            Matrix3d origin_r_it;
            (*it_other)->getOriginPose(origin_t_it, origin_r_it);
            
            
            r_drift_it_other = tmp_w1_r * origin_r_it.transpose();
            t_drift_it_other = tmp_w1_t - r_drift_it_other * origin_t_it;
            (*it_other)-> updatePose(tmp_w1_t, tmp_w1_r);
            
//            pCurMap->add2_r_global_multiClient(tmp_w1_r);
//            pCurMap->add2_t_global_multiClient(tmp_w1_t);
            r_global_cur.push_back(tmp_w1_r);
            t_global_cur.push_back(tmp_w1_t);
        }
        if ((*it_other)->global_index == latest_loop_index_cur)
            break;
        i_other++;
        
    }
    
    //如果将地图建模成可变形的呢
    //根据计算出当前帧的drift，更新全部关键帧位姿
    Vector3d cur_t_other, origin_t_other;
    Matrix3d cur_r_other, origin_r_other;
    //获取优化后当前帧的位姿cur_t,cur_r
    (*it_other)->getPose(cur_t_other, cur_r_other);
    //获取优化前有漂移的当前帧的位姿vio_t,vio_r
    (*it_other)->getOriginPose(origin_t_other, origin_r_other);
    pCurMap->yaw_drift = Utility::R2ypr(cur_r_other).x() - Utility::R2ypr(origin_r_other).x();
    pCurMap->r_drift = Utility::ypr2R(Vector3d(pCurMap->yaw_drift, 0, 0));
    pCurMap->t_drift = cur_t_other - pCurMap->r_drift * origin_t_other;
    
//    pCurMap->add2_r_global_multiClient(pCurMap->r_drift);
//    pCurMap->add2_t_global_multiClient(pCurMap->t_drift);
    r_global_cur.push_back(pCurMap->r_drift);
    t_global_cur.push_back(pCurMap->t_drift);
    pCurMap->add2_r_global_multiClient(r_global_cur);
    pCurMap->add2_t_global_multiClient(t_global_cur);

    //下面代码为把当前关键帧it之后的关键帧的位姿通过求解的偏移量转换到world坐标系下
    for (; it_other != pCurMap->keyFrameList.end(); it_other++)
    {
        Vector3d P;
        Matrix3d R;
        (*it_other)->getOriginPose(P, R);
        P = pCurMap->r_drift * P + pCurMap->t_drift;
        R = pCurMap->r_drift * R;
        (*it_other)-> updatePose(P, R);
    }
    pCurMap->lastKF_index.push(pCurMap->keyFrameList.back()->global_index);
    
    //---------------------------------------第2个数据的更新
    //优化完成，使用优化后的位姿来更新关键帧列表中index大于等于earliest_loop_index的所有关键帧的位姿
    i_main = 0;
    Vector3d t_drift_it_main = Vector3d::Zero();
    Matrix3d r_drift_it_main = Matrix3d::Identity();
    
    vector<Matrix3d> r_global_main;
    vector<Vector3d> t_global_main;
    for (it_main = pMainMap->keyFrameList.begin(); it_main != pMainMap->keyFrameList.end(); it_main++)
    {
        if ((*it_main)->global_index < earliest_loop_index_main)
            continue;

        Quaterniond tmp_q;
        //向量转换为矩阵
        tmp_q = Utility::ypr2R(Vector3d(euler_array_main[i_main][0], euler_array_main[i_main][1], euler_array_main[i_main][2]));
        Vector3d tmp_w1_t = Vector3d(t_array_main[i_main][0], t_array_main[i_main][1], t_array_main[i_main][2]);
        Matrix3d tmp_w1_r = tmp_q.toRotationMatrix();

//                cout<<"测试 优化完成 更新哪里变了："<<euler_array_main[i_main][0]<<" "<<euler_array_main[i_main][1]<<" "<<euler_array_main[i_main][2]<<" "<<t_array_main[i_main][0]<<" "<<t_array_main[i_main][1]<<" "<<t_array_main[i_main][2]<<" "<<i_main<<endl;
        if(need_resample_main[i_main])
        {
            (*it_main)-> updatePose(r_drift_it_main * tmp_w1_t + t_drift_it_main, r_drift_it_main * tmp_w1_r);
        }
        else
        {
            Vector3d origin_t_it;
            Matrix3d origin_r_it;
            (*it_main)->getOriginPose(origin_t_it, origin_r_it);
            r_drift_it_main = tmp_w1_r * origin_r_it.transpose();
            t_drift_it_main = tmp_w1_t - r_drift_it_main * origin_t_it;
            (*it_main)-> updatePose(tmp_w1_t, tmp_w1_r);
            
//            pMainMap->add2_r_global_multiClient(tmp_w1_r);
//            pMainMap->add2_t_global_multiClient(tmp_w1_t);
            r_global_main.push_back(tmp_w1_r);
            t_global_main.push_back(tmp_w1_t);

        }
        if ((*it_main)->global_index == latest_loop_index_main)
            break;
        i_main++;

    }
    //根据计算出当前帧的drift，更新全部关键帧位姿
    Vector3d cur_t_main, origin_t_main;
    Matrix3d cur_r_main, origin_r_main;
    //获取优化后当前帧的位姿cur_t,cur_r
    (*it_main)->getPose(cur_t_main, cur_r_main);
    //获取优化前有漂移的当前帧的位姿vio_t,vio_r
    (*it_main)->getOriginPose(origin_t_main, origin_r_main);
    pMainMap->yaw_drift = Utility::R2ypr(cur_r_main).x() - Utility::R2ypr(origin_r_main).x();
    pMainMap->r_drift = Utility::ypr2R(Vector3d(pMainMap->yaw_drift, 0, 0));
    pMainMap->t_drift = cur_t_main - pMainMap->r_drift * origin_t_main;
    
//    pMainMap->add2_r_global_multiClient(pMainMap->r_drift);
//    pMainMap->add2_t_global_multiClient(pMainMap->t_drift);
    r_global_main.push_back(pMainMap->r_drift);
    t_global_main.push_back(pMainMap->t_drift);
    pMainMap->add2_r_global_multiClient(r_global_main);
    pMainMap->add2_t_global_multiClient(t_global_main);

    //下面代码为把当前关键帧it之后的关键帧的位姿通过求解的偏移量转换到world坐标系下
    for (; it_main != pMainMap->keyFrameList.end(); it_main++)
    {
        Vector3d P;
        Matrix3d R;
        (*it_main)->getOriginPose(P, R);
        P = pMainMap->r_drift * P + pMainMap->t_drift;
        R = pMainMap->r_drift * R;
        (*it_main)-> updatePose(P, R);
    }
    
//    pCurMap->isFirstFusion_globalMutex.unlock();
    
    
    
    
    
    pMainMap->lastKF_index.push(pMainMap->keyFrameList.back()->global_index);
//            位姿更新都留到显示那里
    pMainMap->updateVisualization();
    pCurMap->refine_path_mutex.lock();
    pMainMap->fusion_relative_isUpdate[i]=0;
    pCurMap->refine_path_mutex.unlock();
    //发送数据
    pMainMap->isSendGloablData_multiClient=true;
    
    
    
    pCurMap->updateVisualization();
    pCurMap->isSendGloablData_multiClient=true;
    
//    cout<<"测试 偏移对不对"<<pCurMap->t_drift[0]<<" "<<pCurMap->t_drift[1]<<" "<<pCurMap->t_drift[2]<<endl;
    
    
}

/**
void PoseGraphGlobal::GlobalFuse_8(int i){
            
    //因为现在写的都是和主地图发生地图融合 所以其中一个地图直接这么获取了
//    poseGraphGlobal_mutex.lock();
    readWriteLock.readLock();
    PoseGraph* pMainMap=PoseGraphGloabl_map[0];
    map<int,PoseGraph*>::iterator iter_map = PoseGraphGloabl_map.find(i);
    if(iter_map==PoseGraphGloabl_map.end())
    {
//        poseGraphGlobal_mutex.unlock();
        readWriteLock.readUnLock();
        assert(false);//都已经发生回环了，却找不到地图 说明数据插错了
        
    }
    
    PoseGraph* pCurMap= iter_map->second;
//    poseGraphGlobal_mutex.unlock();
    readWriteLock.readUnLock();
    
   
    
    int earliest_loop_index_main=pMainMap->earliest_loop_index;
    int earliest_global_looped_index_main=earliest_global_loop_index[i];
    if (earliest_loop_index_main > earliest_global_looped_index_main || earliest_loop_index_main == -1  )
        earliest_loop_index_main=earliest_global_looped_index_main;
    
    int latest_loop_index_main=pMainMap->latest_loop_index;
    int latest_global_looped_index_main=latest_global_loop_index[i].first;
    if (latest_global_looped_index_main > latest_loop_index_main)
        latest_loop_index_main=latest_global_looped_index_main;
    
    
    int latest_loop_index_cur=pCurMap->latest_loop_index;
    int latest_global_looped_index_cur=latest_global_loop_index[i].second;
    if (latest_global_looped_index_cur > latest_loop_index_cur)
        latest_loop_index_cur=latest_global_looped_index_cur;
    
//    isFirstFusion[i]=2;
   
    pMainMap->loop_index_multiClient.push(earliest_loop_index_main);
    pMainMap->curKF_loop_index_multiClient.push(latest_loop_index_main);
    pCurMap->isFirstFusion_globalMutex.lock();
    isFusion[i]=1;
    pCurMap->loop_index_multiClient.push(0);
    pCurMap->curKF_loop_index_multiClient.push(latest_loop_index_cur);
    pCurMap->isFirstFusion_globalMutex.unlock();
            
    //主地图从earliest_loop_index_main开始--当前帧结束
    //小地图从第一帧开始--当前发生回环的帧 这个有可能是回环帧，也有可能是融合帧
    
    ceres::Problem problem;
    ceres::Solver::Options options;
    //options.linear_solver_type = ceres::DENSE_NORMAL_CHOLESKY;
    options.linear_solver_type = ceres::DENSE_SCHUR;
    options.minimizer_progress_to_stdout = false;
    options.max_num_iterations = 6;
    ceres::Solver::Summary summary;
    ceres::LossFunction *loss_function;
    loss_function = new ceres::HuberLoss(1.0);
    //AngleLocalParameterization类的主要作用是指定yaw角优化变量的迭代更新，重载了括号运算
    ceres::LocalParameterization* angle_local_parameterization =
    AngleLocalParameterization::Create();
    
    
    double total_lenth_main=pMainMap->total_length;
    double total_lenth_other=pCurMap->total_length;
    //总的位姿长度 除以总的帧数
    double total_lenth_sum=total_lenth_main+total_lenth_other;
    int max_frame_num_global_main=(total_lenth_main/total_lenth_sum)*max_frame_num_global;
    int max_frame_num_global_other=max_frame_num_global-max_frame_num_global_main;
    double min_dis_main=total_lenth_main/max_frame_num_global_main;
    double min_dis_other=total_lenth_other/max_frame_num_global_other;
    cout<<"min_dis_main："<<min_dis_main<<" min_dis_other:"<<min_dis_other<<endl;
    
    //要优化的变量的最大个数 主地图
    int max_length_main=pMainMap->keyFrameList.size()+1;
    double t_array_main[max_length_main][3];//平移数组，其中存放每个关键帧的平移向量
    Quaterniond q_array_main[max_length_main];
    double euler_array_main[max_length_main][3];
    vector<bool> need_resample_main;
    
    //要优化的变量的最大个数 小地图
    int max_length_other=pCurMap->keyFrameList.size()+1;
    double t_array_other[max_length_other][3];//平移数组，其中存放每个关键帧的平移向量
    Quaterniond q_array_other[max_length_other];
    double euler_array_other[max_length_other][3];
    vector<bool> need_resample_other;
    
    pMainMap->max_frame_num_global=max_frame_num_global_main;
    pMainMap->min_dis=min_dis_main;
    pCurMap->max_frame_num_global=max_frame_num_global_other;
    pCurMap->min_dis=min_dis_other;
    
//    pMainMap->clear_kf_id_hasComPlace_withOtherMap();
//    pMainMap->clear_r_global_multiClient();
//    pMainMap->clear_t_global_multiClient();
    
//    pMainMap->special_kf_inOpti.clear();
    vector<int> special_kf_inOpti_main;
    vector<int> kf_id_hasComPlace_main;
    //遍历关键帧列表
    list<KeyFrame*>::iterator it_main = pMainMap->keyFrameList.begin();
    Vector3d last_P_main = Vector3d(0, 0, 0);
    double dis_main = 0;
    for(;it_main!=pMainMap->keyFrameList.end();it_main++){
        if((*it_main)->global_index < earliest_loop_index_main){
            continue;
        }
        Vector3d tmp_t;
        Matrix3d tmp_r;
        //获取关键帧it的位姿
        (*it_main)->getPose(tmp_t, tmp_r);
        dis_main += (tmp_t - last_P_main).norm();
        //全局优化 还是要加序列边 不然太长了 判断条件 再加个两个地图之间发生了融合
        if((*it_main)->global_index == earliest_loop_index_main || dis_main > min_dis_main || (*it_main)->is_get_loop_info || (*it_main)->is_looped || (*it_main)->has_global_loop || (*it_main)->is_global_looped || pMainMap->keyFrameList.size() < max_frame_num_global_main)
        {
            dis_main = 0;
            last_P_main = tmp_t;
            need_resample_main.push_back(0);
            
//            pMainMap->special_kf_inOpti.push_back((*it_main)->global_index);
            special_kf_inOpti_main.push_back((*it_main)->global_index);
            
            if(((*it_main)->has_global_loop || (*it_main)->is_global_looped) && (*it_main)->is_Send==false ){
                kf_id_hasComPlace_main.push_back((*it_main)->global_index);
//                pMainMap->add2_kf_id_hasComPlace_withOtherMap((*it_main)->global_index);
                (*it_main)->is_Send=true;
            }
        }
        else
        {
            last_P_main = tmp_t;
            need_resample_main.push_back(1);
        }
    }
    
    pMainMap->special_kf_mutex.lock();
    pMainMap->add2_kf_id_hasComPlace_withOtherMap(kf_id_hasComPlace_main);
   pMainMap->special_kf_inOpti.push(special_kf_inOpti_main);
   pMainMap->special_kf_mutex.unlock();
     
    int i_main = 0;
    for (it_main = pMainMap->keyFrameList.begin(); it_main != pMainMap->keyFrameList.end(); it_main++)
    {
        if ((*it_main)->global_index < earliest_loop_index_main)
            continue;
        (*it_main)->resample_globalIndex = i_main;
        Quaterniond tmp_q;
        Matrix3d tmp_r;
        Vector3d tmp_t;
        (*it_main)->getOriginPose(tmp_t, tmp_r);
//                (*it_main)->getPose(tmp_t, tmp_r);
        tmp_q = tmp_r;
        t_array_main[i_main][0] = tmp_t(0);
        t_array_main[i_main][1] = tmp_t(1);
        t_array_main[i_main][2] = tmp_t(2);
        q_array_main[i_main] = tmp_q;
        //将矩阵转换为向量
        Vector3d euler_angle = Utility::R2ypr(tmp_r);
        euler_array_main[i_main][0] = euler_angle.x();
        euler_array_main[i_main][1] = euler_angle.y();
        euler_array_main[i_main][2] = euler_angle.z();
        //将关键帧列表中所有index>=earliest_loop_index的关键帧的位姿加入到参数块当中
        problem.AddParameterBlock(euler_array_main[i_main], 1, angle_local_parameterization);
        problem.AddParameterBlock(t_array_main[i_main], 3);
        //设置约束：如果该帧是最早的闭环帧的情况下，则固定它的位姿
        if ((*it_main)->global_index == earliest_loop_index_main)
        {
            problem.SetParameterBlockConstant(euler_array_main[i_main]);
            problem.SetParameterBlockConstant(t_array_main[i_main]);
//                cout<<"测试 更新哪里变了："<<euler_array_main[i_main][0]<<" "<<euler_array_main[i_main][1]<<" "<<euler_array_main[i_main][2]<<" "<<t_array_main[i_main][0]<<" "<<t_array_main[i_main][1]<<" "<<t_array_main[i_main][2]<<" "<<i_main<<endl;
        }
        
        if(need_resample_main[i_main])
        {
            i_main++;
            continue;
        }
        
        
        int j = 1, sequence_link_cnt = 0;
        while(sequence_link_cnt < 5)
        {
            if (i_main - j >= 0)
            {
//                        list<KeyFrame*>::iterator tmp = it_main;
//                        std::advance (tmp, -j);
                if(need_resample_main[i_main-j])
                {
                    j++;
                    continue;
                }
                else
                {
                    sequence_link_cnt++;
                }
                Vector3d euler_conncected = Utility::R2ypr(q_array_main[i_main-j].toRotationMatrix());
                //p̂_j^w - p̂_i^w 计算平移量的偏差
                Vector3d relative_t(t_array_main[i_main][0] - t_array_main[i_main-j][0], t_array_main[i_main][1] - t_array_main[i_main-j][1], t_array_main[i_main][2] - t_array_main[i_main-j][2]);
                //p̂_{ij}^{i} = {R̂_i^w}^{-1} (p̂_j^w - p̂_i^w)
                //p̂ ij= (R̂ iw ) (p̂ jw − p̂ iw )
                relative_t = q_array_main[i_main-j].inverse() * relative_t;
                //ψ̂ _ij = ψ̂ _j − ψ̂ _i
                double relative_yaw = euler_array_main[i_main][0] - euler_array_main[i_main-j][0];
                ceres::CostFunction* cost_function = FourDOFError_another::Create( relative_t.x(), relative_t.y(), relative_t.z(),
                                                                          relative_yaw, euler_conncected.y(), euler_conncected.z());
                problem.AddResidualBlock(cost_function, loss_function, euler_array_main[i_main-j],
                                         t_array_main[i_main-j],
                                         euler_array_main[i_main],
                                         t_array_main[i_main]);
            }
            else
            {
                break;
            }
            j++;
        }

        //        添加的是闭环边，是指检测到闭环的两帧
        if((*it_main)->is_get_loop_info   )
        {
            if((*it_main)->loop_index >= earliest_loop_index_main)
            {
                int connected_index = pMainMap->getKeyframe((*it_main)->loop_index)->resample_globalIndex;

                Vector3d euler_conncected = Utility::R2ypr(q_array_main[connected_index].toRotationMatrix());
                Vector3d relative_t((*it_main)->loop_info_better(0), (*it_main)->loop_info_better(1), (*it_main)->loop_info_better(2));
                double relative_yaw = (*it_main)->loop_info_better(3);

                ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),
                                                                                relative_yaw, euler_conncected.y(), euler_conncected.z());
                problem.AddResidualBlock(cost_function, NULL, euler_array_main[connected_index],
                                         t_array_main[connected_index],
                                         euler_array_main[i_main],
                                         t_array_main[i_main]);
            }else{
                assert(false);
            }
        }

        
        if((*it_main)->has_global_loop)
       {
           //这里后面还要添加else
           if((*it_main)->global_loop_index < 0)
           {
               //因为这意味着数据保存出错了 发生了融合的帧的id小于最早发生融合的id
               assert(false);
               return;
           }
           //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束
           int connected_index = pCurMap->getKeyframe((*it_main)->global_loop_index)->resample_globalIndex;
           
//                   cout<<"global fuse has_global_loop"<<(*it_main)->global_loop_index<<endl;
           Vector3d euler_conncected = Utility::R2ypr(q_array_other[connected_index].toRotationMatrix());
           Vector3d relative_t((*it_main)->global_loop_info(0), (*it_main)->global_loop_info(1), (*it_main)->global_loop_info(2));
           double relative_yaw = (*it_main)->global_loop_info(7);
//                   double relative_pitch =(*it_other)->global_relative_pitch;
//                   double relative_roll=(*it_other)->global_relative_roll;

//           cout<<"(*it_other)->global_loop_info(0)"<<(*it_other)->global_loop_info(0)<<" (*it_other)->global_loop_info(1)"<<(*it_other)->global_loop_info(1)<<" (*it_other)->global_loop_info(2)"<<(*it_other)->global_loop_info(2)<<" (*it_other)->global_loop_info(7)"<<(*it_other)->global_loop_info(7)<<" "<<(*it_other)->global_index<<" "<<(*it_other)->header<<" "<<pMainMap->getKeyframe((*it_other)->global_loop_index)->header<<endl;
           
           //这里到时候 再写一个求导的
           ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z());
           problem.AddResidualBlock(cost_function, NULL, euler_array_other[connected_index],
                                    t_array_other[connected_index],
                                    euler_array_main[i_main],
                                    t_array_main[i_main]);
       }
        
        
        if ((*it_main)->global_index == latest_loop_index_main)
            break;
        i_main++;
    }
    
    
    //*************************************第一个数据
    //遍历关键帧列表
    list<KeyFrame*>::iterator it_other = pCurMap->keyFrameList.begin();

    Vector3d last_P_other = Vector3d(0, 0, 0);
    double dis_other = 0;
    
//    pCurMap->clear_kf_id_hasComPlace_withOtherMap();
//    pCurMap->clear_r_global_multiClient();
//    pCurMap->clear_t_global_multiClient();
    
//    pCurMap->special_kf_inOpti.clear();
    vector<int> special_kf_inOpti_cur;
    vector<int> kf_id_hasCom_cur;
    //小地图是从第一个帧开始优化
    for(;it_other!=pCurMap->keyFrameList.end();it_other++){
        Vector3d tmp_t;
        Matrix3d tmp_r;
        //获取关键帧it的位姿
        (*it_other)->getPose(tmp_t, tmp_r);
        dis_other += (tmp_t - last_P_other).norm();
        
        
        //全局优化 还是要加序列边 不然太长了 判断条件 再加个两个地图之间发生了融合
        //第一个地图融合位置，超过长度了，发生过回环，被回环了，总共的帧长度比最大值小
        //还要再加一个 发生了融合，被融合了
        if((*it_other)->global_index == 0 || dis_other > min_dis_other || (*it_other)->is_get_loop_info || (*it_other)->is_looped || (*it_other)->has_global_loop || (*it_other)->is_global_looped || pCurMap->keyFrameList.size() < max_frame_num_global_other)
        {
            dis_other = 0;
            last_P_other = tmp_t;
            need_resample_other.push_back(0);
            
//            pCurMap->special_kf_inOpti.push_back((*it_other)->global_index);
            special_kf_inOpti_cur.push_back((*it_other)->global_index);
            
            if(((*it_other)->has_global_loop || (*it_other)->is_global_looped) && (*it_other)->is_Send==false ){
                kf_id_hasCom_cur.push_back((*it_other)->global_index);
//                pCurMap->add2_kf_id_hasComPlace_withOtherMap((*it_other)->global_index);
                (*it_other)->is_Send=true;
            }
        }
        else
        {
            last_P_other = tmp_t;
            need_resample_other.push_back(1);
        }
    }
    
    pCurMap->special_kf_mutex.lock();
    pCurMap->add2_kf_id_hasComPlace_withOtherMap(kf_id_hasCom_cur);
    pCurMap->special_kf_inOpti.push(special_kf_inOpti_cur);
    pCurMap->special_kf_mutex.unlock();

    int i_other = 0;
    for (it_other = pCurMap->keyFrameList.begin(); it_other != pCurMap->keyFrameList.end(); it_other++)
    {
        (*it_other)->resample_globalIndex = i_other;
        Quaterniond tmp_q;
        Matrix3d tmp_r;
        Vector3d tmp_t;
        (*it_other)->getOriginPose(tmp_t, tmp_r);

        
        tmp_q=tmp_r;
        t_array_other[i_other][0]=tmp_t[0];
        t_array_other[i_other][1]=tmp_t[1];
        t_array_other[i_other][2]=tmp_t[2];
        q_array_other[i_other]=tmp_q;
        //将矩阵转换为向量
        Vector3d euler_angle = Utility::R2ypr(tmp_r);
        euler_array_other[i_other][0] = euler_angle.x();
        euler_array_other[i_other][1] = euler_angle.y();
        euler_array_other[i_other][2] = euler_angle.z();
        //将关键帧列表中所有index>=earliest_loop_index的关键帧的位姿加入到参数块当中
        problem.AddParameterBlock(euler_array_other[i_other], 1, angle_local_parameterization);
        problem.AddParameterBlock(t_array_other[i_other], 3);


        if(need_resample_other[i_other])
        {
            i_other++;
            continue;
        }


        int j = 1, sequence_link_cnt = 0;
        while(sequence_link_cnt < 5)
        {
            if (i_other - j >= 0)
            {
//                        list<KeyFrame*>::iterator tmp = it_other;
//                        std::advance (tmp, -j);
                if(need_resample_other[i_other-j])
                {
                    j++;
                    continue;
                }
                else
                {
                    sequence_link_cnt++;
                }
                Vector3d euler_conncected = Utility::R2ypr(q_array_other[i_other-j].toRotationMatrix());
                //p̂_j^w - p̂_i^w 计算平移量的偏差
                Vector3d relative_t(t_array_other[i_other][0] - t_array_other[i_other-j][0], t_array_other[i_other][1] - t_array_other[i_other-j][1], t_array_other[i_other][2] - t_array_other[i_other-j][2]);
                //p̂_{ij}^{i} = {R̂_i^w}^{-1} (p̂_j^w - p̂_i^w)
                //p̂ ij= (R̂ iw ) (p̂ jw − p̂ iw )
                relative_t = q_array_other[i_other-j].inverse() * relative_t;
                //ψ̂ _ij = ψ̂ _j − ψ̂ _i
                double relative_yaw = euler_array_other[i_other][0] - euler_array_other[i_other-j][0];
                ceres::CostFunction* cost_function = FourDOFError_another::Create( relative_t.x(), relative_t.y(), relative_t.z(),
                                                                          relative_yaw, euler_conncected.y(), euler_conncected.z());
                problem.AddResidualBlock(cost_function, loss_function, euler_array_other[i_other-j],
                                         t_array_other[i_other-j],
                                         euler_array_other[i_other],
                                         t_array_other[i_other]);
            }
            else
            {
                break;
            }
            j++;
        }

        //        添加的是闭环边，是指检测到闭环的两帧 一个数据拆成两份 这个注释掉了
        if((*it_other)->is_get_loop_info)
        {
            //这里后面还要添加else
            if((*it_other)->loop_index <0)
            {
                assert(false);
            }
            //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束
            int connected_index = pCurMap->getKeyframe((*it_other)->loop_index)->resample_globalIndex;

            Vector3d euler_conncected = Utility::R2ypr(q_array_other[connected_index].toRotationMatrix());
            Vector3d relative_t((*it_other)->loop_info_better(0), (*it_other)->loop_info_better(1), (*it_other)->loop_info_better(2));
            double relative_yaw = (*it_other)->loop_info_better(3);

//                    cout<<fixed<<setprecision(6)<<"(*it_other)->loop_info(0)"<<(*it_other)->loop_info_better(0)<<" (*it_other)->loop_info(1)"<<(*it_other)->loop_info_better(1)<<" (*it_other)->loop_info(2)"<<(*it_other)->loop_info_better(2)<<" (*it_other)->loop_info(7)"<<(*it_other)->loop_info_better(3)<<" "<<(*it_other)->header<<" "<<pCurMap->getKeyframe((*it_other)->global_index)->header<<endl;

            ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z());
            problem.AddResidualBlock(cost_function, NULL, euler_array_other[connected_index],
                                     t_array_other[connected_index],
                                     euler_array_other[i_other],
                                     t_array_other[i_other]);
            
        }
        
        if((*it_other)->has_global_loop)
       {
           //这里后面还要添加else
           if((*it_other)->global_loop_index < earliest_loop_index_main)
           {
               //因为这意味着数据保存出错了 发生了融合的帧的id小于最早发生融合的id
               assert(false);
               return;
           }
           //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束
           int connected_index = pMainMap->getKeyframe((*it_other)->global_loop_index)->resample_globalIndex;
           
//                   cout<<"global fuse has_global_loop"<<(*it_other)->global_loop_index<<" "<<connected_index<<" "<<keyFrameList_merge.size()<<endl;
           Vector3d euler_conncected = Utility::R2ypr(q_array_main[connected_index].toRotationMatrix());
           Vector3d relative_t((*it_other)->global_loop_info(0), (*it_other)->global_loop_info(1), (*it_other)->global_loop_info(2));
           double relative_yaw = (*it_other)->global_loop_info(7);
//                   double relative_pitch =(*it_other)->global_relative_pitch;
//                   double relative_roll=(*it_other)->global_relative_roll;

//           cout<<"(*it_other)->global_loop_info(0)"<<(*it_other)->global_loop_info(0)<<" (*it_other)->global_loop_info(1)"<<(*it_other)->global_loop_info(1)<<" (*it_other)->global_loop_info(2)"<<(*it_other)->global_loop_info(2)<<" (*it_other)->global_loop_info(7)"<<(*it_other)->global_loop_info(7)<<" "<<(*it_other)->global_index<<" "<<(*it_other)->header<<" "<<pMainMap->getKeyframe((*it_other)->global_loop_index)->header<<endl;
           
           //这里到时候 再写一个求导的
           ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z());
           problem.AddResidualBlock(cost_function, NULL, euler_array_main[connected_index],
                                    t_array_main[connected_index],
                                    euler_array_other[i_other],
                                    t_array_other[i_other]);
       }
        if ((*it_other)->global_index == latest_loop_index_cur)
            break;
        i_other++;
    }

    ceres::Solve(options, &problem, &summary);
    
    std::cout << "global fuse: "<<summary.BriefReport() << "\n";
     
    //------------------------------------------第一个数据优化后更新
    //优化完成，使用优化后的位姿来更新关键帧列表中index大于等于earliest_loop_index的所有关键帧的位姿
    i_other = 0;
    Vector3d t_drift_it_other = Vector3d::Zero();
    Matrix3d r_drift_it_other = Matrix3d::Identity();
    
    vector<Matrix3d> r_global_cur;
    vector<Vector3d> t_global_cur;
    for (it_other = pCurMap->keyFrameList.begin(); it_other != pCurMap->keyFrameList.end(); it_other++)
    {
        
        Quaterniond tmp_q;
        //向量转换为矩阵
        tmp_q = Utility::ypr2R(Vector3d(euler_array_other[i_other][0], euler_array_other[i_other][1], euler_array_other[i_other][2]));
        Vector3d tmp_w1_t = Vector3d(t_array_other[i_other][0], t_array_other[i_other][1], t_array_other[i_other][2]);
        Matrix3d tmp_w1_r = tmp_q.toRotationMatrix();
       
        if(need_resample_other[i_other])
        {
            (*it_other)-> updatePose(r_drift_it_other * tmp_w1_t + t_drift_it_other, r_drift_it_other * tmp_w1_r);
        }
        else
        {
            Vector3d origin_t_it;
            Matrix3d origin_r_it;
            (*it_other)->getOriginPose(origin_t_it, origin_r_it);
            
            
            r_drift_it_other = tmp_w1_r * origin_r_it.transpose();
            t_drift_it_other = tmp_w1_t - r_drift_it_other * origin_t_it;
            (*it_other)-> updatePose(tmp_w1_t, tmp_w1_r);
            
//            pCurMap->add2_r_global_multiClient(tmp_w1_r);
//            pCurMap->add2_t_global_multiClient(tmp_w1_t);
            r_global_cur.push_back(tmp_w1_r);
            t_global_cur.push_back(tmp_w1_t);
        }
        if ((*it_other)->global_index == latest_loop_index_cur)
            break;
        i_other++;
        
    }
    
    //如果将地图建模成可变形的呢
    //根据计算出当前帧的drift，更新全部关键帧位姿
    Vector3d cur_t_other, origin_t_other;
    Matrix3d cur_r_other, origin_r_other;
    //获取优化后当前帧的位姿cur_t,cur_r
    (*it_other)->getPose(cur_t_other, cur_r_other);
    //获取优化前有漂移的当前帧的位姿vio_t,vio_r
    (*it_other)->getOriginPose(origin_t_other, origin_r_other);
    pCurMap->yaw_drift = Utility::R2ypr(cur_r_other).x() - Utility::R2ypr(origin_r_other).x();
    pCurMap->r_drift = Utility::ypr2R(Vector3d(pCurMap->yaw_drift, 0, 0));
    pCurMap->t_drift = cur_t_other - pCurMap->r_drift * origin_t_other;
    
//    pCurMap->add2_r_global_multiClient(pCurMap->r_drift);
//    pCurMap->add2_t_global_multiClient(pCurMap->t_drift);
    r_global_cur.push_back(pCurMap->r_drift);
    t_global_cur.push_back(pCurMap->t_drift);
    pCurMap->add2_r_global_multiClient(r_global_cur);
    pCurMap->add2_t_global_multiClient(t_global_cur);

    //下面代码为把当前关键帧it之后的关键帧的位姿通过求解的偏移量转换到world坐标系下
    for (; it_other != pCurMap->keyFrameList.end(); it_other++)
    {
        Vector3d P;
        Matrix3d R;
        (*it_other)->getOriginPose(P, R);
        P = pCurMap->r_drift * P + pCurMap->t_drift;
        R = pCurMap->r_drift * R;
        (*it_other)-> updatePose(P, R);
    }
    pCurMap->lastKF_index.push(pCurMap->keyFrameList.back()->global_index);
    
    //---------------------------------------第2个数据的更新
    //优化完成，使用优化后的位姿来更新关键帧列表中index大于等于earliest_loop_index的所有关键帧的位姿
    i_main = 0;
    Vector3d t_drift_it_main = Vector3d::Zero();
    Matrix3d r_drift_it_main = Matrix3d::Identity();
    
    vector<Matrix3d> r_global_main;
    vector<Vector3d> t_global_main;
    for (it_main = pMainMap->keyFrameList.begin(); it_main != pMainMap->keyFrameList.end(); it_main++)
    {
        if ((*it_main)->global_index < earliest_loop_index_main)
            continue;

        Quaterniond tmp_q;
        //向量转换为矩阵
        tmp_q = Utility::ypr2R(Vector3d(euler_array_main[i_main][0], euler_array_main[i_main][1], euler_array_main[i_main][2]));
        Vector3d tmp_w1_t = Vector3d(t_array_main[i_main][0], t_array_main[i_main][1], t_array_main[i_main][2]);
        Matrix3d tmp_w1_r = tmp_q.toRotationMatrix();

//                cout<<"测试 优化完成 更新哪里变了："<<euler_array_main[i_main][0]<<" "<<euler_array_main[i_main][1]<<" "<<euler_array_main[i_main][2]<<" "<<t_array_main[i_main][0]<<" "<<t_array_main[i_main][1]<<" "<<t_array_main[i_main][2]<<" "<<i_main<<endl;
        if(need_resample_main[i_main])
        {
            (*it_main)-> updatePose(r_drift_it_main * tmp_w1_t + t_drift_it_main, r_drift_it_main * tmp_w1_r);
        }
        else
        {
            Vector3d origin_t_it;
            Matrix3d origin_r_it;
            (*it_main)->getOriginPose(origin_t_it, origin_r_it);
            r_drift_it_main = tmp_w1_r * origin_r_it.transpose();
            t_drift_it_main = tmp_w1_t - r_drift_it_main * origin_t_it;
            (*it_main)-> updatePose(tmp_w1_t, tmp_w1_r);
            
//            pMainMap->add2_r_global_multiClient(tmp_w1_r);
//            pMainMap->add2_t_global_multiClient(tmp_w1_t);
            r_global_main.push_back(tmp_w1_r);
            t_global_main.push_back(tmp_w1_t);

        }
        if ((*it_main)->global_index == latest_loop_index_main)
            break;
        i_main++;

    }
    //根据计算出当前帧的drift，更新全部关键帧位姿
    Vector3d cur_t_main, origin_t_main;
    Matrix3d cur_r_main, origin_r_main;
    //获取优化后当前帧的位姿cur_t,cur_r
    (*it_main)->getPose(cur_t_main, cur_r_main);
    //获取优化前有漂移的当前帧的位姿vio_t,vio_r
    (*it_main)->getOriginPose(origin_t_main, origin_r_main);
    pMainMap->yaw_drift = Utility::R2ypr(cur_r_main).x() - Utility::R2ypr(origin_r_main).x();
    pMainMap->r_drift = Utility::ypr2R(Vector3d(pMainMap->yaw_drift, 0, 0));
    pMainMap->t_drift = cur_t_main - pMainMap->r_drift * origin_t_main;
    
//    pMainMap->add2_r_global_multiClient(pMainMap->r_drift);
//    pMainMap->add2_t_global_multiClient(pMainMap->t_drift);
    r_global_main.push_back(pMainMap->r_drift);
    t_global_main.push_back(pMainMap->t_drift);
    pMainMap->add2_r_global_multiClient(r_global_main);
    pMainMap->add2_t_global_multiClient(t_global_main);

    //下面代码为把当前关键帧it之后的关键帧的位姿通过求解的偏移量转换到world坐标系下
    for (; it_main != pMainMap->keyFrameList.end(); it_main++)
    {
        Vector3d P;
        Matrix3d R;
        (*it_main)->getOriginPose(P, R);
        P = pMainMap->r_drift * P + pMainMap->t_drift;
        R = pMainMap->r_drift * R;
        (*it_main)-> updatePose(P, R);
    }
    
//    pCurMap->isFirstFusion_globalMutex.unlock();
    
    
    
    
    
    pMainMap->lastKF_index.push(pMainMap->keyFrameList.back()->global_index);
//            位姿更新都留到显示那里
    pMainMap->updateVisualization();
    pCurMap->refine_path_mutex.lock();
    pMainMap->fusion_relative_isUpdate[i]=0;
    pCurMap->refine_path_mutex.unlock();
    //发送数据
    pMainMap->isSendGloablData_multiClient=true;
    
    
    
    pCurMap->updateVisualization();
    pCurMap->isSendGloablData_multiClient=true;
    
//    cout<<"测试 偏移对不对"<<pCurMap->t_drift[0]<<" "<<pCurMap->t_drift[1]<<" "<<pCurMap->t_drift[2]<<endl;
    
    
}
*/

void PoseGraphGlobal::GlobalFuse_7(int i){
            
//    poseGraphGlobal_mutex.lock();
    readWriteLock.readLock();
    //因为现在写的都是和主地图发生地图融合 所以其中一个地图直接这么获取了
    PoseGraph* pMainMap=PoseGraphGloabl_map[0];
    map<int,PoseGraph*>::iterator iter_map = PoseGraphGloabl_map.find(i);
    if(iter_map==PoseGraphGloabl_map.end())
    {
//        poseGraphGlobal_mutex.unlock();
        readWriteLock.readUnLock();
        assert(false);//都已经发生回环了，却找不到地图 说明数据插错了
        
    }
    PoseGraph* pCurMap= iter_map->second;
//    poseGraphGlobal_mutex.unlock();
    readWriteLock.readUnLock();
    
    pCurMap->isFirstFusion_globalMutex.lock();
    
    int earliest_loop_index_main=pMainMap->earliest_loop_index;
    int earliest_global_looped_index_main=earliest_global_loop_index[i];
    if (earliest_loop_index_main > earliest_global_looped_index_main || earliest_loop_index_main == -1  )
        earliest_loop_index_main=earliest_global_looped_index_main;
    
    int latest_loop_index_main=pMainMap->latest_loop_index;
    int latest_global_looped_index_main=latest_global_loop_index[i].first;
    if (latest_global_looped_index_main > latest_loop_index_main)
        latest_loop_index_main=latest_global_looped_index_main;
    
    
    int latest_loop_index_cur=pCurMap->latest_loop_index;
    int latest_global_looped_index_cur=latest_global_loop_index[i].second;
    if (latest_global_looped_index_cur > latest_loop_index_cur)
        latest_loop_index_cur=latest_global_looped_index_cur;
    
    isFirstFusion[i]=2;
    
    isFusion[i]=1;
    pMainMap->loop_index_multiClient.push(earliest_loop_index_main);
    pMainMap->curKF_loop_index_multiClient.push(latest_loop_index_main);
    pCurMap->loop_index_multiClient.push(0);
    pCurMap->curKF_loop_index_multiClient.push(latest_loop_index_cur);
    
            
            
            
    //主地图从earliest_loop_index_main开始--当前帧结束
    //小地图从第一帧开始--当前发生回环的帧 这个有可能是回环帧，也有可能是融合帧
    
    ceres::Problem problem;
    ceres::Solver::Options options;
    //options.linear_solver_type = ceres::DENSE_NORMAL_CHOLESKY;
    options.linear_solver_type = ceres::DENSE_SCHUR;
    options.minimizer_progress_to_stdout = true;
    options.max_num_iterations = 6;
    ceres::Solver::Summary summary;
    ceres::LossFunction *loss_function;
    loss_function = new ceres::HuberLoss(1.0);
    //AngleLocalParameterization类的主要作用是指定yaw角优化变量的迭代更新，重载了括号运算
    ceres::LocalParameterization* angle_local_parameterization =
    AngleLocalParameterization::Create();
    
    
    double total_lenth_main=pMainMap->total_length;
    double total_lenth_other=pCurMap->total_length;
    //总的位姿长度 除以总的帧数
    double total_lenth_sum=total_lenth_main+total_lenth_other;
    int max_frame_num_global_main=(total_lenth_main/total_lenth_sum)*max_frame_num_global;
    int max_frame_num_global_other=max_frame_num_global-max_frame_num_global_main;
    double min_dis_main=total_lenth_main/max_frame_num_global_main;
    double min_dis_other=total_lenth_other/max_frame_num_global_other;
    cout<<"min_dis_main："<<min_dis_main<<" min_dis_other:"<<min_dis_other<<endl;
    
    //要优化的变量的最大个数 主地图
    int max_length_main=pMainMap->keyFrameList.size()+1;
    double t_array_main[max_length_main][3];//平移数组，其中存放每个关键帧的平移向量
    Quaterniond q_array_main[max_length_main];
    double euler_array_main[max_length_main][3];
    vector<bool> need_resample_main;
    
    //要优化的变量的最大个数 小地图
    int max_length_other=pCurMap->keyFrameList.size()+1;
    double t_array_other[max_length_other][3];//平移数组，其中存放每个关键帧的平移向量
    Quaterniond q_array_other[max_length_other];
    double euler_array_other[max_length_other][3];
    vector<bool> need_resample_other;
    
    pMainMap->max_frame_num_global=max_frame_num_global_main;
    pMainMap->min_dis=min_dis_main;
    pCurMap->max_frame_num_global=max_frame_num_global_other;
    pCurMap->min_dis=min_dis_other;
    
//    pMainMap->clear_kf_id_hasComPlace_withOtherMap();
//    pMainMap->clear_r_global_multiClient();
//    pMainMap->clear_t_global_multiClient();
    
//    pMainMap->special_kf_inOpti.clear();
    vector<int> special_kf_inOpti_main;
    vector<int> kf_id_hasComPlace_main;
    //遍历关键帧列表
    list<KeyFrame*>::iterator it_main = pMainMap->keyFrameList.begin();
    Vector3d last_P_main = Vector3d(0, 0, 0);
    double dis_main = 0;
    for(;it_main!=pMainMap->keyFrameList.end();it_main++){
        if((*it_main)->global_index < earliest_loop_index_main){
            continue;
        }
        Vector3d tmp_t;
        Matrix3d tmp_r;
        //获取关键帧it的位姿
        (*it_main)->getPose(tmp_t, tmp_r);
        dis_main += (tmp_t - last_P_main).norm();
        //全局优化 还是要加序列边 不然太长了 判断条件 再加个两个地图之间发生了融合
        if((*it_main)->global_index == earliest_loop_index_main || dis_main > min_dis_main || (*it_main)->is_get_loop_info || (*it_main)->is_looped || (*it_main)->has_global_loop || (*it_main)->is_global_looped || pMainMap->keyFrameList.size() < max_frame_num_global_main)
        {
            dis_main = 0;
            last_P_main = tmp_t;
            need_resample_main.push_back(0);
            
//            pMainMap->special_kf_inOpti.push_back((*it_main)->global_index);
            special_kf_inOpti_main.push_back((*it_main)->global_index);
            
            if(((*it_main)->has_global_loop || (*it_main)->is_global_looped) && (*it_main)->is_Send==false ){
                kf_id_hasComPlace_main.push_back((*it_main)->global_index);
//                pMainMap->add2_kf_id_hasComPlace_withOtherMap((*it_main)->global_index);
                (*it_main)->is_Send=true;
            }
        }
        else
        {
            last_P_main = tmp_t;
            need_resample_main.push_back(1);
        }
        
        if ((*it_main)->global_index == latest_loop_index_main)
            break;
    }
    
    pMainMap->special_kf_mutex.lock();
    pMainMap->add2_kf_id_hasComPlace_withOtherMap(kf_id_hasComPlace_main);
    pMainMap->special_kf_inOpti.push(special_kf_inOpti_main);
    pMainMap->special_kf_mutex.unlock();
    
    
     
    int i_main = 0;
    for (it_main = pMainMap->keyFrameList.begin(); it_main != pMainMap->keyFrameList.end(); it_main++)
    {
        if ((*it_main)->global_index < earliest_loop_index_main)
            continue;
        (*it_main)->resample_globalIndex = i_main;
        Quaterniond tmp_q;
        Matrix3d tmp_r;
        Vector3d tmp_t;
        (*it_main)->getOriginPose(tmp_t, tmp_r);
//                (*it_main)->getPose(tmp_t, tmp_r);
        tmp_q = tmp_r;
        t_array_main[i_main][0] = tmp_t(0);
        t_array_main[i_main][1] = tmp_t(1);
        t_array_main[i_main][2] = tmp_t(2);
        q_array_main[i_main] = tmp_q;
        //将矩阵转换为向量
        Vector3d euler_angle = Utility::R2ypr(tmp_r);
        euler_array_main[i_main][0] = euler_angle.x();
        euler_array_main[i_main][1] = euler_angle.y();
        euler_array_main[i_main][2] = euler_angle.z();
        //将关键帧列表中所有index>=earliest_loop_index的关键帧的位姿加入到参数块当中
        problem.AddParameterBlock(euler_array_main[i_main], 1, angle_local_parameterization);
        problem.AddParameterBlock(t_array_main[i_main], 3);
        //设置约束：如果该帧是最早的闭环帧的情况下，则固定它的位姿
        if ((*it_main)->global_index == earliest_loop_index_main)
        {
            problem.SetParameterBlockConstant(euler_array_main[i_main]);
            problem.SetParameterBlockConstant(t_array_main[i_main]);
//                cout<<"测试 更新哪里变了："<<euler_array_main[i_main][0]<<" "<<euler_array_main[i_main][1]<<" "<<euler_array_main[i_main][2]<<" "<<t_array_main[i_main][0]<<" "<<t_array_main[i_main][1]<<" "<<t_array_main[i_main][2]<<" "<<i_main<<endl;
        }
        
        if(need_resample_main[i_main])
        {
            i_main++;
            continue;
        }
        
        
        int j = 1, sequence_link_cnt = 0;
        while(sequence_link_cnt < 5)
        {
            if (i_main - j >= 0)
            {
//                        list<KeyFrame*>::iterator tmp = it_main;
//                        std::advance (tmp, -j);
                if(need_resample_main[i_main-j])
                {
                    j++;
                    continue;
                }
                else
                {
                    sequence_link_cnt++;
                }
                Vector3d euler_conncected = Utility::R2ypr(q_array_main[i_main-j].toRotationMatrix());
                //p̂_j^w - p̂_i^w 计算平移量的偏差
                Vector3d relative_t(t_array_main[i_main][0] - t_array_main[i_main-j][0], t_array_main[i_main][1] - t_array_main[i_main-j][1], t_array_main[i_main][2] - t_array_main[i_main-j][2]);
                //p̂_{ij}^{i} = {R̂_i^w}^{-1} (p̂_j^w - p̂_i^w)
                //p̂ ij= (R̂ iw ) (p̂ jw − p̂ iw )
                relative_t = q_array_main[i_main-j].inverse() * relative_t;
                //ψ̂ _ij = ψ̂ _j − ψ̂ _i
                double relative_yaw = euler_array_main[i_main][0] - euler_array_main[i_main-j][0];
                ceres::CostFunction* cost_function = FourDOFError_another::Create( relative_t.x(), relative_t.y(), relative_t.z(),
                                                                          relative_yaw, euler_conncected.y(), euler_conncected.z());
                problem.AddResidualBlock(cost_function, loss_function, euler_array_main[i_main-j],
                                         t_array_main[i_main-j],
                                         euler_array_main[i_main],
                                         t_array_main[i_main]);
            }
            else
            {
                break;
            }
            j++;
        }

        //        添加的是闭环边，是指检测到闭环的两帧
        if((*it_main)->is_get_loop_info   )
        {
            if((*it_main)->loop_index >= earliest_loop_index_main)
            {
                int connected_index = pMainMap->getKeyframe((*it_main)->loop_index)->resample_globalIndex;

                Vector3d euler_conncected = Utility::R2ypr(q_array_main[connected_index].toRotationMatrix());
                Vector3d relative_t((*it_main)->loop_info_better(0), (*it_main)->loop_info_better(1), (*it_main)->loop_info_better(2));
                double relative_yaw = (*it_main)->loop_info_better(3);
                
                if((*it_main)->isRemove_loop){
                    ceres::CostFunction* cost_function = FourDOFWeightError_forRemove::Create( relative_t.x(), relative_t.y(), relative_t.z(),
                                                                                    relative_yaw, euler_conncected.y(), euler_conncected.z(),3.0);
                    problem.AddResidualBlock(cost_function, NULL, euler_array_main[connected_index],
                                             t_array_main[connected_index],
                                             euler_array_main[i_main],
                                             t_array_main[i_main]);
                }else{
                    ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),
                                                                                    relative_yaw, euler_conncected.y(), euler_conncected.z(),10.0);
                    problem.AddResidualBlock(cost_function, NULL, euler_array_main[connected_index],
                                             t_array_main[connected_index],
                                         euler_array_main[i_main],
                                         t_array_main[i_main]);
                }
            }else{
                assert(false);
            }
        }

        if ((*it_main)->global_index == latest_loop_index_main)
            break;
        i_main++;
    }
    
    
    //*************************************第一个数据
    //遍历关键帧列表
    list<KeyFrame*>::iterator it_other = pCurMap->keyFrameList.begin();

    Vector3d last_P_other = Vector3d(0, 0, 0);
    double dis_other = 0;
    
//    pCurMap->clear_kf_id_hasComPlace_withOtherMap();
//    pCurMap->clear_r_global_multiClient();
//    pCurMap->clear_t_global_multiClient();
    
//    pCurMap->special_kf_inOpti.clear();
    vector<int> special_kf_inOpti_cur;
    vector<int> kf_id_hasCom_cur;
    //小地图是从第一个帧开始优化
    for(;it_other!=pCurMap->keyFrameList.end();it_other++){
        Vector3d tmp_t;
        Matrix3d tmp_r;
        //获取关键帧it的位姿
        (*it_other)->getPose(tmp_t, tmp_r);
        dis_other += (tmp_t - last_P_other).norm();
        
        
        //全局优化 还是要加序列边 不然太长了 判断条件 再加个两个地图之间发生了融合
        //第一个地图融合位置，超过长度了，发生过回环，被回环了，总共的帧长度比最大值小
        //还要再加一个 发生了融合，被融合了
        if((*it_other)->global_index == 0 || dis_other > min_dis_other || (*it_other)->is_get_loop_info || (*it_other)->is_looped || (*it_other)->has_global_loop || (*it_other)->is_global_looped || pCurMap->keyFrameList.size() < max_frame_num_global_other)
        {
            dis_other = 0;
            last_P_other = tmp_t;
            need_resample_other.push_back(0);
            
//            pCurMap->special_kf_inOpti.push_back((*it_other)->global_index);
            special_kf_inOpti_cur.push_back((*it_other)->global_index);
            
            if(((*it_other)->has_global_loop || (*it_other)->is_global_looped) && (*it_other)->is_Send==false ){
                kf_id_hasCom_cur.push_back((*it_other)->global_index);
//                pCurMap->add2_kf_id_hasComPlace_withOtherMap((*it_other)->global_index);
                (*it_other)->is_Send=true;
            }
        }
        else
        {
            last_P_other = tmp_t;
            need_resample_other.push_back(1);
        }
        
        if ((*it_other)->global_index == latest_loop_index_cur)
            break;
    }
    
    pCurMap->special_kf_mutex.lock();
    pCurMap->add2_kf_id_hasComPlace_withOtherMap(kf_id_hasCom_cur);
    pCurMap->special_kf_inOpti.push(special_kf_inOpti_cur);
    pCurMap->special_kf_mutex.unlock();

    int i_other = 0;
    for (it_other = pCurMap->keyFrameList.begin(); it_other != pCurMap->keyFrameList.end(); it_other++)
    {
        (*it_other)->resample_globalIndex = i_other;
        Quaterniond tmp_q;
        Matrix3d tmp_r;
        Vector3d tmp_t;
        (*it_other)->getOriginPose(tmp_t, tmp_r);

        
        tmp_q=tmp_r;
        t_array_other[i_other][0]=tmp_t[0];
        t_array_other[i_other][1]=tmp_t[1];
        t_array_other[i_other][2]=tmp_t[2];
        q_array_other[i_other]=tmp_q;
        //将矩阵转换为向量
        Vector3d euler_angle = Utility::R2ypr(tmp_r);
        euler_array_other[i_other][0] = euler_angle.x();
        euler_array_other[i_other][1] = euler_angle.y();
        euler_array_other[i_other][2] = euler_angle.z();
        //将关键帧列表中所有index>=earliest_loop_index的关键帧的位姿加入到参数块当中
        problem.AddParameterBlock(euler_array_other[i_other], 1, angle_local_parameterization);
        problem.AddParameterBlock(t_array_other[i_other], 3);


        if(need_resample_other[i_other])
        {
            i_other++;
            continue;
        }


        int j = 1, sequence_link_cnt = 0;
        while(sequence_link_cnt < 5)
        {
            if (i_other - j >= 0)
            {
//                        list<KeyFrame*>::iterator tmp = it_other;
//                        std::advance (tmp, -j);
                if(need_resample_other[i_other-j])
                {
                    j++;
                    continue;
                }
                else
                {
                    sequence_link_cnt++;
                }
                Vector3d euler_conncected = Utility::R2ypr(q_array_other[i_other-j].toRotationMatrix());
                //p̂_j^w - p̂_i^w 计算平移量的偏差
                Vector3d relative_t(t_array_other[i_other][0] - t_array_other[i_other-j][0], t_array_other[i_other][1] - t_array_other[i_other-j][1], t_array_other[i_other][2] - t_array_other[i_other-j][2]);
                //p̂_{ij}^{i} = {R̂_i^w}^{-1} (p̂_j^w - p̂_i^w)
                //p̂ ij= (R̂ iw ) (p̂ jw − p̂ iw )
                relative_t = q_array_other[i_other-j].inverse() * relative_t;
                //ψ̂ _ij = ψ̂ _j − ψ̂ _i
                double relative_yaw = euler_array_other[i_other][0] - euler_array_other[i_other-j][0];
                ceres::CostFunction* cost_function = FourDOFError_another::Create( relative_t.x(), relative_t.y(), relative_t.z(),
                                                                          relative_yaw, euler_conncected.y(), euler_conncected.z());
                problem.AddResidualBlock(cost_function, loss_function, euler_array_other[i_other-j],
                                         t_array_other[i_other-j],
                                         euler_array_other[i_other],
                                         t_array_other[i_other]);
            }
            else
            {
                break;
            }
            j++;
        }

        //        添加的是闭环边，是指检测到闭环的两帧 一个数据拆成两份 这个注释掉了
        if((*it_other)->is_get_loop_info)
        {
            //这里后面还要添加else
            if((*it_other)->loop_index <0)
            {
                assert(false);
            }
            //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束
            int connected_index = pCurMap->getKeyframe((*it_other)->loop_index)->resample_globalIndex;

            Vector3d euler_conncected = Utility::R2ypr(q_array_other[connected_index].toRotationMatrix());
            Vector3d relative_t((*it_other)->loop_info_better(0), (*it_other)->loop_info_better(1), (*it_other)->loop_info_better(2));
            double relative_yaw = (*it_other)->loop_info_better(3);

//                    cout<<fixed<<setprecision(6)<<"(*it_other)->loop_info(0)"<<(*it_other)->loop_info_better(0)<<" (*it_other)->loop_info(1)"<<(*it_other)->loop_info_better(1)<<" (*it_other)->loop_info(2)"<<(*it_other)->loop_info_better(2)<<" (*it_other)->loop_info(7)"<<(*it_other)->loop_info_better(3)<<" "<<(*it_other)->header<<" "<<pCurMap->getKeyframe((*it_other)->global_index)->header<<endl;

            if((*it_other)->isRemove_loop){
                ceres::CostFunction* cost_function = FourDOFWeightError_forRemove::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z(),3.0);
                problem.AddResidualBlock(cost_function, NULL, euler_array_other[connected_index],
                                         t_array_other[connected_index],
                                         euler_array_other[i_other],
                                         t_array_other[i_other]);
                cout<<"降权重 发生过"<<endl;
            }else{
                ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z(),10.0);
                problem.AddResidualBlock(cost_function, NULL, euler_array_other[connected_index],
                                     t_array_other[connected_index],
                                     euler_array_other[i_other],
                                     t_array_other[i_other]);
            }
            
        }
        
        if((*it_other)->has_global_loop)
       {
           //这里后面还要添加else
           if((*it_other)->global_loop_index < earliest_loop_index_main)
           {
               //因为这意味着数据保存出错了 发生了融合的帧的id小于最早发生融合的id
               assert(false);
               return;
           }
           //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束
           int connected_index = pMainMap->getKeyframe((*it_other)->global_loop_index)->resample_globalIndex;
           
//                   cout<<"global fuse has_global_loop"<<(*it_other)->global_loop_index<<" "<<connected_index<<" "<<keyFrameList_merge.size()<<endl;
           Vector3d euler_conncected = Utility::R2ypr(q_array_main[connected_index].toRotationMatrix());
           Vector3d relative_t((*it_other)->global_loop_info(0), (*it_other)->global_loop_info(1), (*it_other)->global_loop_info(2));
           double relative_yaw = (*it_other)->global_loop_info(7);
//                   double relative_pitch =(*it_other)->global_relative_pitch;
//                   double relative_roll=(*it_other)->global_relative_roll;

//           cout<<"(*it_other)->global_loop_info(0)"<<(*it_other)->global_loop_info(0)<<" (*it_other)->global_loop_info(1)"<<(*it_other)->global_loop_info(1)<<" (*it_other)->global_loop_info(2)"<<(*it_other)->global_loop_info(2)<<" (*it_other)->global_loop_info(7)"<<(*it_other)->global_loop_info(7)<<" "<<(*it_other)->global_index<<" "<<(*it_other)->header<<" "<<pMainMap->getKeyframe((*it_other)->global_loop_index)->header<<endl;
           
           
//           if((*it_other)->isRemove_globalLoop){
//               ceres::CostFunction* cost_function = FourDOFWeightError_forRemove::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z(),3.0);
//               problem.AddResidualBlock(cost_function, NULL, euler_array_main[connected_index],
//                                        t_array_main[connected_index],
//                                        euler_array_other[i_other],
//                                        t_array_other[i_other]);
//               cout<<"global 降权重 发生过"<<endl;
//           }else{
               
               //这里到时候 再写一个求导的
               ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z(),10.0);
               problem.AddResidualBlock(cost_function, NULL, euler_array_main[connected_index],
                                    t_array_main[connected_index],
                                    euler_array_other[i_other],
                                    t_array_other[i_other]);
//           }
       }
        if ((*it_other)->global_index == latest_loop_index_cur)
            break;
        i_other++;
    }

    ceres::Solve(options, &problem, &summary);
    
    std::cout << "global fuse: "<<summary.BriefReport() << "\n";
     
    //------------------------------------------第一个数据优化后更新
    //优化完成，使用优化后的位姿来更新关键帧列表中index大于等于earliest_loop_index的所有关键帧的位姿
    i_other = 0;
    Vector3d t_drift_it_other = Vector3d::Zero();
    Matrix3d r_drift_it_other = Matrix3d::Identity();
    
    vector<Matrix3d> r_global_cur;
    vector<Vector3d> t_global_cur;
    for (it_other = pCurMap->keyFrameList.begin(); it_other != pCurMap->keyFrameList.end(); it_other++)
    {
        
        Quaterniond tmp_q;
        //向量转换为矩阵
        tmp_q = Utility::ypr2R(Vector3d(euler_array_other[i_other][0], euler_array_other[i_other][1], euler_array_other[i_other][2]));
        Vector3d tmp_w1_t = Vector3d(t_array_other[i_other][0], t_array_other[i_other][1], t_array_other[i_other][2]);
        Matrix3d tmp_w1_r = tmp_q.toRotationMatrix();
       
        if(need_resample_other[i_other])
        {
            (*it_other)-> updatePose(r_drift_it_other * tmp_w1_t + t_drift_it_other, r_drift_it_other * tmp_w1_r);
            
//            Vector3d t=r_drift_it_other * tmp_w1_t + t_drift_it_other;
//            cout<<"PoseGraphGlobal::GlobalFuse7 6252 测试位姿哪一步变差了：";
//            for(int i=0;i<3;i++){
//                cout<<t[i]<<" ";
//            }
//            cout<<endl;
        }
        else
        {
            Vector3d origin_t_it;
            Matrix3d origin_r_it;
            (*it_other)->getOriginPose(origin_t_it, origin_r_it);
            
            
            r_drift_it_other = tmp_w1_r * origin_r_it.transpose();
            t_drift_it_other = tmp_w1_t - r_drift_it_other * origin_t_it;
            (*it_other)-> updatePose(tmp_w1_t, tmp_w1_r);
            
//            cout<<"PoseGraphGlobal::GlobalFuse7 6269 测试位姿哪一步变差了：";
//            for(int i=0;i<3;i++){
//                cout<<tmp_w1_t[i]<<" ";
//            }
//            cout<<endl;
            
//            pCurMap->add2_r_global_multiClient(tmp_w1_r);
//            pCurMap->add2_t_global_multiClient(tmp_w1_t);
            r_global_cur.push_back(tmp_w1_r);
           t_global_cur.push_back(tmp_w1_t);
        }
        if ((*it_other)->global_index == latest_loop_index_cur)
            break;
        i_other++;
        
    }
    
    //如果将地图建模成可变形的呢
    //根据计算出当前帧的drift，更新全部关键帧位姿
    Vector3d cur_t_other, origin_t_other;
    Matrix3d cur_r_other, origin_r_other;
    //获取优化后当前帧的位姿cur_t,cur_r
    (*it_other)->getPose(cur_t_other, cur_r_other);
    //获取优化前有漂移的当前帧的位姿vio_t,vio_r
    (*it_other)->getOriginPose(origin_t_other, origin_r_other);
    pCurMap->yaw_drift = Utility::R2ypr(cur_r_other).x() - Utility::R2ypr(origin_r_other).x();
    pCurMap->r_drift = Utility::ypr2R(Vector3d(pCurMap->yaw_drift, 0, 0));
    pCurMap->t_drift = cur_t_other - pCurMap->r_drift * origin_t_other;
    
//    pCurMap->add2_r_global_multiClient(pCurMap->r_drift);
//    pCurMap->add2_t_global_multiClient(pCurMap->t_drift);
    r_global_cur.push_back(pCurMap->r_drift);
    t_global_cur.push_back(pCurMap->t_drift);
    pCurMap->add2_r_global_multiClient(r_global_cur);
    pCurMap->add2_t_global_multiClient(t_global_cur);

    //下面代码为把当前关键帧it之后的关键帧的位姿通过求解的偏移量转换到world坐标系下
    for (; it_other != pCurMap->keyFrameList.end(); it_other++)
    {
        Vector3d P;
        Matrix3d R;
        (*it_other)->getOriginPose(P, R);
        P = pCurMap->r_drift * P + pCurMap->t_drift;
        R = pCurMap->r_drift * R;
        (*it_other)-> updatePose(P, R);
        
//        cout<<"PoseGraphGlobal::GlobalFuse7 6309 测试位姿哪一步变差了：";
//        for(int i=0;i<3;i++){
//            cout<<P[i]<<" ";
//        }
//        cout<<endl;
    }
    pCurMap->lastKF_index.push(pCurMap->keyFrameList.back()->global_index);
    
    //---------------------------------------第2个数据的更新
    //优化完成，使用优化后的位姿来更新关键帧列表中index大于等于earliest_loop_index的所有关键帧的位姿
    i_main = 0;
    Vector3d t_drift_it_main = Vector3d::Zero();
    Matrix3d r_drift_it_main = Matrix3d::Identity();
    
    vector<Matrix3d> r_global_main;
    vector<Vector3d> t_global_main;
    for (it_main = pMainMap->keyFrameList.begin(); it_main != pMainMap->keyFrameList.end(); it_main++)
    {
        if ((*it_main)->global_index < earliest_loop_index_main)
            continue;

        Quaterniond tmp_q;
        //向量转换为矩阵
        tmp_q = Utility::ypr2R(Vector3d(euler_array_main[i_main][0], euler_array_main[i_main][1], euler_array_main[i_main][2]));
        Vector3d tmp_w1_t = Vector3d(t_array_main[i_main][0], t_array_main[i_main][1], t_array_main[i_main][2]);
        Matrix3d tmp_w1_r = tmp_q.toRotationMatrix();

//                cout<<"测试 优化完成 更新哪里变了："<<euler_array_main[i_main][0]<<" "<<euler_array_main[i_main][1]<<" "<<euler_array_main[i_main][2]<<" "<<t_array_main[i_main][0]<<" "<<t_array_main[i_main][1]<<" "<<t_array_main[i_main][2]<<" "<<i_main<<endl;
        if(need_resample_main[i_main])
        {
            (*it_main)-> updatePose(r_drift_it_main * tmp_w1_t + t_drift_it_main, r_drift_it_main * tmp_w1_r);
            
//            Vector3d t=r_drift_it_main * tmp_w1_t + t_drift_it_main;
//            cout<<"PoseGraphGlobal::GlobalFuse7 6309 测试位姿哪一步变差了：";
//            for(int i=0;i<3;i++){
//                cout<<t[i]<<" ";
//            }
//            cout<<endl;
        }
        else
        {
            Vector3d origin_t_it;
            Matrix3d origin_r_it;
            (*it_main)->getOriginPose(origin_t_it, origin_r_it);
            r_drift_it_main = tmp_w1_r * origin_r_it.transpose();
            t_drift_it_main = tmp_w1_t - r_drift_it_main * origin_t_it;
            (*it_main)-> updatePose(tmp_w1_t, tmp_w1_r);
            
            
            
//            cout<<"PoseGraphGlobal::GlobalFuse7 6354 测试位姿哪一步变差了：";
//            for(int i=0;i<3;i++){
//                cout<<tmp_w1_t[i]<<" ";
//            }
//            cout<<endl;
            
//            pMainMap->add2_r_global_multiClient(tmp_w1_r);
//            pMainMap->add2_t_global_multiClient(tmp_w1_t);
            r_global_main.push_back(tmp_w1_r);
          t_global_main.push_back(tmp_w1_t);


        }
        if ((*it_main)->global_index == latest_loop_index_main)
            break;
        i_main++;

    }
    //根据计算出当前帧的drift，更新全部关键帧位姿
    Vector3d cur_t_main, origin_t_main;
    Matrix3d cur_r_main, origin_r_main;
    //获取优化后当前帧的位姿cur_t,cur_r
    (*it_main)->getPose(cur_t_main, cur_r_main);
    //获取优化前有漂移的当前帧的位姿vio_t,vio_r
    (*it_main)->getOriginPose(origin_t_main, origin_r_main);
    pMainMap->yaw_drift = Utility::R2ypr(cur_r_main).x() - Utility::R2ypr(origin_r_main).x();
    pMainMap->r_drift = Utility::ypr2R(Vector3d(pMainMap->yaw_drift, 0, 0));
    pMainMap->t_drift = cur_t_main - pMainMap->r_drift * origin_t_main;
    
//    pMainMap->add2_r_global_multiClient(pMainMap->r_drift);
//    pMainMap->add2_t_global_multiClient(pMainMap->t_drift);
    r_global_main.push_back(pMainMap->r_drift);
    t_global_main.push_back(pMainMap->t_drift);
    pMainMap->add2_r_global_multiClient(r_global_main);
    pMainMap->add2_t_global_multiClient(t_global_main);

    //下面代码为把当前关键帧it之后的关键帧的位姿通过求解的偏移量转换到world坐标系下
    for (; it_main != pMainMap->keyFrameList.end(); it_main++)
    {
        Vector3d P;
        Matrix3d R;
        (*it_main)->getOriginPose(P, R);
        P = pMainMap->r_drift * P + pMainMap->t_drift;
        R = pMainMap->r_drift * R;
        (*it_main)-> updatePose(P, R);
        
//        cout<<"PoseGraphGlobal::GlobalFuse7 6395 测试位姿哪一步变差了：";
//        for(int i=0;i<3;i++){
//            cout<<P[i]<<" ";
//        }
//        cout<<endl;
    }
    
    pCurMap->isFirstFusion_globalMutex.unlock();
    
    
    
    
    
    pMainMap->lastKF_index.push(pMainMap->keyFrameList.back()->global_index);
//            位姿更新都留到显示那里
    pMainMap->updateVisualization();
    pCurMap->refine_path_mutex.lock();
    pMainMap->fusion_relative_isUpdate[i]=0;
    pCurMap->refine_path_mutex.unlock();
    //发送数据
    pMainMap->isSendGloablData_multiClient=true;
    
    
    
    pCurMap->updateVisualization();
    pCurMap->isSendGloablData_multiClient=true;
    
    cout<<"测试 偏移对不对"<<pCurMap->t_drift[0]<<" "<<pCurMap->t_drift[1]<<" "<<pCurMap->t_drift[2]<<endl;
    
    
}

//之前的想法是 我这个地图空闲了，那么其它人 都来和我做匹配 所以传过来的也是我这个地图
//然而 可能存在其它人没有新增，重复匹配检索，锁了我这个地图
//现在希望 我这个地图新增了，去和其它人 做匹配
//但是 其他人可能存在正在新增数据 写锁住了，先等待。 后面再写就先放弃，后面再写再尝试
//（空间换时间，弄一个旧的备份 新的锁住了，直接和旧的匹配 空间消耗大）
//传过来的是 我这个地图新增了
//第三篇论文
void PoseGraphGlobal::loopClosureRun_global_15_all(int clientId_main){
    //-------------找到主地图，即调用该方法的地图-------------------------

//    当时的新增地图
    readWriteLock.readLock();
    map<int,PoseGraph*>::iterator iter_map = PoseGraphGloabl_map.find(clientId_main);
    if(iter_map==PoseGraphGloabl_map.end())
    {
        readWriteLock.readUnLock();
        assert(false);//找不到地图是不应该的
        return ;
    }
    PoseGraph* poseGraph_main=iter_map->second;

//    readWriteLock.readUnLock();
//    ----------拿到地图的关键帧---------------------
    poseGraph_main->mMutexkeyFrameList.lock();
    list<KeyFrame*> keyFrameList_main=poseGraph_main->keyFrameList;
    poseGraph_main->mMutexkeyFrameList.unlock();
    
   
    //实验用 记录是不是最后的结束部分了
    bool isEnd=true;
     
     //---------------拿其它所有地图和主地图去做比较-------------------------

//    readWriteLock.readLock();
    for(auto iter_end=PoseGraphGloabl_map.end(), iter_start=PoseGraphGloabl_map.begin();iter_start!=iter_end ;){
        --iter_end;
        if(iter_map==iter_end){
            continue;
        }        
        //-------------遍历的其它地图
        PoseGraph* poseGraph_other=iter_end->second;
        int clientId_other=iter_end->first;
        //-------------其它地图和调用该方法的地图ID 应该不一样才对
        if(clientId_other!=clientId_main){
            //---------实验用 判断程序结束没
            if(poseGraph_other->isEnd==false){
                isEnd=false;
            }
            poseGraph_other->mMutexkeyFrameList.lock();
            list<KeyFrame*> keyFrameList_other=poseGraph_other->keyFrameList;
            poseGraph_other->mMutexkeyFrameList.unlock();
            //---------因为是做回环，所以其它地图里面要有关键帧
            if(keyFrameList_other.size()>0){
                //-----拿主地图里面，最新的关键帧和其它地图做匹配
                KeyFrame* iter_kf_main=poseGraph_main->getLastKeyframe();
                if(iter_kf_main->check_global_loop[clientId_other]==false && iter_kf_main->is_des_end){
                    iter_kf_main->check_global_loop[clientId_other]=true;
                    isEnd=false;
                    //---------去DBOW里面做检索
                    bool loop_succ=false;
                    int old_index=-1;//这个后续要记录住的 我暂时还没记录 记录了
                    vector<cv::Point2f> cur_pts;
                    vector<cv::Point2f> old_pts;
                    int min_startDetect_id=0;
                    //这里修改一下，返回的序号 ！= kf id
                    poseGraph_other->isAddKF2Database_mutex.lock();
                    loop_succ = startLoopClosure_2(iter_kf_main->keypoints, iter_kf_main->descriptors,  old_pts, cur_pts, old_index,min_startDetect_id,iter_kf_main->global_index, clientId_other, poseGraph_other->demo_global_in_poseGraph, clientId_main);//返回的应该是其它地图的哪一个帧
                    old_index=poseGraph_other->treeId_kf[old_index];
                    assert(old_index!=-1);
                    poseGraph_other->isAddKF2Database_mutex.unlock();
                    //---------检测成功
                    if(loop_succ)
                     {
                         //检索到老帧 其它地图的
                         list<KeyFrame*>::iterator cur_kf_iter=poseGraph_other->getKeyframe_iter(old_index);
                          if(cur_kf_iter==poseGraph_other->keyFrameList.end()){
                              assert(false);
                          }
                          KeyFrame* cur_kf=(*cur_kf_iter);
                          if (cur_kf == NULL)
                          {
                              assert(false);//该关键帧不存在于其它地图
                          }
                          
                         
                         //这两个是粗糙的坐标
                         std::vector<cv::Point2f> measurements_cur;//像素坐标
                         std::vector<cv::Point2f> measurements_cur_norm;//图像坐标
   //                      std::vector<int> features_id;
                         //新帧的3D点(新增地图的3d点)  老帧的2D点
                         iter_kf_main->findConnectionWithOldFrame_server_old(cur_kf, measurements_cur, measurements_cur_norm);//找到匹配的特征点
//                         cout<<"measurements_old.size()<22 ="<<measurements_old.size()<<" "<<old_kf->header<<" ,"<<iter_kf_other->header<<endl;
                         if(measurements_cur.size()<16){
                             
                             continue;
                         }
                         
                         Matrix3d R_relative;
                         Vector3d T_relative;
                         bool isSuccess=optiRelativePose_forMainMap2(measurements_cur_norm, iter_kf_main->point_clouds, cur_kf, iter_kf_main, R_relative, T_relative,measurements_cur);
                         if(isSuccess==false)
                             continue;
                         
                         //每个帧自己存一下和别人的相对位姿关系,只检索的帧存储
//                         这个应该加锁 TODO
                         iter_kf_main->readWriteLock_loop.writeLock();
                         iter_kf_main->clientId.push_back(clientId_other);
                         iter_kf_main->kfId.push_back(cur_kf->global_index);
                         iter_kf_main->relativePose.push_back(std::make_pair(R_relative, T_relative));
                         iter_kf_main->readWriteLock_loop.writeUnLock();
                   
                          //由于不再是和主地图 做匹配。所以应该是每个地图都有一个记录 自己和哪些地图融合了
//                         这里感觉得改改 fusion_relative_isUpdate的赋值 后面竟然赋值成关键帧的数量
                          bool isAdd_otherClientId=false;
                          if(poseGraph_main->fusion_relative_isUpdate[clientId_other]!=-2)
                              isAdd_otherClientId=true;
                          

                              
                              //保存信息 这里保存，暂时没用处，后续应该会删除 有用有用 暂时没有用到
//                         cur_kf->clientId_server.push_back(clientId_main);
//                         cur_kf->global_index_server.push_back(iter_kf_main->global_index);
                              
                        //这里可能会 脏数据 这个似乎没有用到
//                          feature_id_cur[clientId_main]=iter_kf_main->features_id;
//                          measurements_norm_main[clientId_main]=measurements_cur_norm;
       
                          //这里表示 该地图第一次与主地图发生融合
                          if(!isAdd_otherClientId){
                              
                              poseGraph_main->fusion_poseGraph_mutex.lock();
                              poseGraph_main->fusion_otherGraph[clientId_other]=poseGraph_other;//记录副地图
                              poseGraph_main->fusion_poseGraph_mutex.unlock();
                              
                              poseGraph_other->fusion_poseGraph_mutex.lock();
                              poseGraph_other->fusion_otherGraph[clientId_main]=poseGraph_main;//记录副地图
                              poseGraph_other->fusion_poseGraph_mutex.unlock();
                              
                          }

                          //加锁
                           poseGraph_other->isFirstFusion_globalMutex.lock();
                          //2号帧在1号地图的位姿 前面算过了 2022.03.30 应该不用 没看到有push
//                                  f_manager_server_main.feature.clear();
          
//                                  暂时注释
                         //主地图，其它地图
//                         这个应该存在 各个小地图里面
//                         q_cur_globalFuse_index[clientId_main].push(std::make_pair(iter_kf_main->global_index, old_index));
//                         isOpposite[clientId_main]=false;
                         
                         
                         poseGraph_main->readWriteLock_fuseGlobalIndex.writeLock();
                         poseGraph_main->q_cur3d_old2d_globalIndex.push(std::make_pair(iter_kf_main->global_index, old_index));
                         poseGraph_main->q_old_clientId.push(clientId_other);
                         poseGraph_main->readWriteLock_fuseGlobalIndex.writeUnLock();

                         
                         isFirstFusion[clientId_main]+=1;
                          poseGraph_other->isFirstFusion_globalMutex.unlock();
                          cout<<"地图融合成功:"<<clientId_main<<endl;
//                          usleep(10);

                          }else{
//                              cout<<"地图融合失败"<<检测不成功<<endl;
                              usleep(10);
                          }
                          
                     
                                 
                }
            }
        }
    
    }
//    poseGraphGlobal_mutex.unlock();
    readWriteLock.readUnLock();
   
 
//    usleep(30);


}


void PoseGraphGlobal::loopClosureRun_global_16_all(int clientId_main){
    //-------------找到主地图，即调用该方法的地图-------------------------

//    当时的新增地图
    readWriteLock.readLock();
    map<int,PoseGraph*>::iterator iter_map = PoseGraphGloabl_map.find(clientId_main);
    if(iter_map==PoseGraphGloabl_map.end())
    {
        readWriteLock.readUnLock();
        assert(false);//找不到地图是不应该的
        return ;
    }
    PoseGraph* poseGraph_main=iter_map->second;

//    readWriteLock.readUnLock();
//    ----------拿到地图的关键帧---------------------
    poseGraph_main->mMutexkeyFrameList.lock();
    list<KeyFrame*> keyFrameList_main=poseGraph_main->keyFrameList;
    poseGraph_main->mMutexkeyFrameList.unlock();
    
   
    //实验用 记录是不是最后的结束部分了
    bool isEnd=true;
     
     //---------------拿其它所有地图和主地图去做比较-------------------------

//    readWriteLock.readLock();
    for(auto iter_end=PoseGraphGloabl_map.end(), iter_start=PoseGraphGloabl_map.begin();iter_start!=iter_end ;){
        --iter_end;
        if(iter_map==iter_end){
            continue;
        }
        //-------------遍历的其它地图
        PoseGraph* poseGraph_other=iter_end->second;
        int clientId_other=iter_end->first;
        //-------------其它地图和调用该方法的地图ID 应该不一样才对
        if(clientId_other!=clientId_main){
            //---------实验用 判断程序结束没
            if(poseGraph_other->isEnd==false){
                isEnd=false;
            }
            poseGraph_other->mMutexkeyFrameList.lock();
            list<KeyFrame*> keyFrameList_other=poseGraph_other->keyFrameList;
            poseGraph_other->mMutexkeyFrameList.unlock();
            //---------因为是做回环，所以其它地图里面要有关键帧
            if(keyFrameList_other.size()>0){
                //-----拿主地图里面，最新的关键帧和其它地图做匹配
                KeyFrame* iter_kf_main=poseGraph_main->getLastKeyframe();
                if(iter_kf_main->check_global_loop[clientId_other]==false && iter_kf_main->is_des_end){
                    iter_kf_main->check_global_loop[clientId_other]=true;
                    isEnd=false;
                    //---------去DBOW里面做检索
                    bool loop_succ=false;
                    int old_index=-1;//这个后续要记录住的 我暂时还没记录 记录了
                    vector<cv::Point2f> cur_pts;
                    vector<cv::Point2f> old_pts;
                    int min_startDetect_id=0;
                    //这里修改一下，返回的序号 ！= kf id
                    int keyPoint_num_main=iter_kf_main->keypoints.size()-iter_kf_main->point_clouds_origin.size();
//                    std::vector<cv::Point2f> cur_pts_3d, old_pts_2d;
                    poseGraph_other->isAddKF2Database_mutex.lock();
                    loop_succ = startLoopClosure_2(iter_kf_main->keypoints, iter_kf_main->descriptors,   cur_pts,old_pts, old_index,min_startDetect_id,iter_kf_main->global_index, clientId_other, poseGraph_other->demo_global_in_poseGraph, clientId_main);//返回的应该是其它地图的哪一个帧
                    old_index=poseGraph_other->treeId_kf[old_index];
                    assert(old_index!=-1);
                    poseGraph_other->isAddKF2Database_mutex.unlock();
                    //---------检测成功
                    if(loop_succ)
                     {
                         //检索到老帧 其它地图的
                         list<KeyFrame*>::iterator cur_kf_iter=poseGraph_other->getKeyframe_iter(old_index);
                          if(cur_kf_iter==poseGraph_other->keyFrameList.end()){
                              assert(false);
                          }
                          KeyFrame* cur_kf=(*cur_kf_iter);
                          if (cur_kf == NULL)
                          {
                              assert(false);//该关键帧不存在于其它地图
                          }
                          
//                         {
//                              std::ofstream outFile;
//                                 outFile.open("/Users/zhangjianhua/Desktop/VINS_MapFusion/VINS_MapFusion/data/pt_dbow/"+
//                                                        to_string(iter_kf_main->global_index)+"&"+to_string(iter_kf_main->header)+"&"+
//                                                        to_string(cur_kf->global_index)+"&"+to_string(cur_kf->header)+"_allPoint.txt");
//                                 outFile.setf(ios::fixed, ios::floatfield);  // 设定为 fixed 模式，以小数点表示浮点数
//                                 outFile.precision(19);
//                                 outFile << cur_pts_3d.size()<<"\n";
//                                 for(int i=0,j=cur_pts_3d.size(); i<j; i++)
//                              {
//                                  cv::Point2f pc=cur_pts_3d[i];
//                                  cv::Point2f po=old_pts_2d[i];
//                                  //写入数据
//                                  outFile << pc.x<<" "<<pc.y<<" "<<po.x<<" "<<po.y<<"\n";
//                              }
//
//                              //关闭文件
//                              outFile.close();
//                         }
                         
                         //这两个是粗糙的坐标
                         std::vector<cv::Point2f> measurements_cur;//像素坐标
                         std::vector<cv::Point2f> measurements_cur_norm;//图像坐标
   //                      std::vector<int> features_id;
                         //新帧的3D点(新增地图的3d点)  老帧的2D点
                         iter_kf_main->findConnectionWithOldFrame_server_old(cur_kf, measurements_cur, measurements_cur_norm);//找到匹配的特征点
//                         cout<<"measurements_cur.size() ="<<measurements_cur.size()<<endl;
                         if(measurements_cur.size()<16){
                             
                             continue;
                         }
                         
                         Matrix3d R_relative;
                         Vector3d T_relative;
                         bool isSuccess=optiRelativePose_forMainMap2(measurements_cur_norm, iter_kf_main->point_clouds, cur_kf, iter_kf_main, R_relative, T_relative,measurements_cur);
                         if(isSuccess==false)
                             continue;
                         
                         //每个帧自己存一下和别人的相对位姿关系,只检索的帧存储
//                         这个应该加锁 TODO
                         iter_kf_main->readWriteLock_loop.writeLock();
                         iter_kf_main->clientId.push_back(clientId_other);
                         iter_kf_main->kfId.push_back(cur_kf->global_index);
                         iter_kf_main->relativePose.push_back(std::make_pair(R_relative, T_relative));
                         iter_kf_main->readWriteLock_loop.writeUnLock();
                   
                          //由于不再是和主地图 做匹配。所以应该是每个地图都有一个记录 自己和哪些地图融合了
//                         这里感觉得改改 fusion_relative_isUpdate的赋值 后面竟然赋值成关键帧的数量
                          bool isAdd_otherClientId=false;
                          if(poseGraph_main->fusion_relative_isUpdate[clientId_other]!=-2)
                              isAdd_otherClientId=true;
                          

                              
                              //保存信息 这里保存，暂时没用处，后续应该会删除 有用有用 暂时没有用到
//                         cur_kf->clientId_server.push_back(clientId_main);
//                         cur_kf->global_index_server.push_back(iter_kf_main->global_index);
                              
                        //这里可能会 脏数据 这个似乎没有用到
//                          feature_id_cur[clientId_main]=iter_kf_main->features_id;
//                          measurements_norm_main[clientId_main]=measurements_cur_norm;
       
                          //这里表示 该地图第一次与主地图发生融合
                          if(!isAdd_otherClientId){
                              
                              poseGraph_main->fusion_poseGraph_mutex.lock();
                              poseGraph_main->fusion_otherGraph[clientId_other]=poseGraph_other;//记录副地图
                              poseGraph_main->fusion_poseGraph_mutex.unlock();
                              
                              poseGraph_other->fusion_poseGraph_mutex.lock();
                              poseGraph_other->fusion_otherGraph[clientId_main]=poseGraph_main;//记录副地图
                              poseGraph_other->fusion_poseGraph_mutex.unlock();
                              
                          }

                          //加锁
                           poseGraph_other->isFirstFusion_globalMutex.lock();
                          //2号帧在1号地图的位姿 前面算过了 2022.03.30 应该不用 没看到有push
//                                  f_manager_server_main.feature.clear();
          
//                                  暂时注释
                         //主地图，其它地图
//                         这个应该存在 各个小地图里面
//                         q_cur_globalFuse_index[clientId_main].push(std::make_pair(iter_kf_main->global_index, old_index));
//                         isOpposite[clientId_main]=false;
                         
                         
                         poseGraph_main->readWriteLock_fuseGlobalIndex.writeLock();
                         poseGraph_main->q_cur3d_old2d_globalIndex.push(std::make_pair(iter_kf_main->global_index, old_index));
                         poseGraph_main->q_old_clientId.push(clientId_other);
                         poseGraph_main->readWriteLock_fuseGlobalIndex.writeUnLock();

                         
                         isFirstFusion[clientId_main]+=1;
                          poseGraph_other->isFirstFusion_globalMutex.unlock();
                          cout<<"地图融合成功:"<<clientId_main<<endl;
//                          usleep(10);

                          }else{
//                              cout<<"地图融合失败"<<检测不成功<<endl;
                              usleep(10);
                          }
                          
                     
                                 
                }
            }
        }
    
    }
//    poseGraphGlobal_mutex.unlock();
    readWriteLock.readUnLock();
   
 
//    usleep(30);


}



void PoseGraphGlobal::loopClosureRun_global_17_all(int clientId_main){
    //-------------找到主地图，即调用该方法的地图-------------------------

//    当时的新增地图
    readWriteLock.readLock();
    map<int,PoseGraph*>::iterator iter_map = PoseGraphGloabl_map.find(clientId_main);
    if(iter_map==PoseGraphGloabl_map.end())
    {
        readWriteLock.readUnLock();
        assert(false);//找不到地图是不应该的
        return ;
    }
    PoseGraph* poseGraph_main=iter_map->second;

//    readWriteLock.readUnLock();
//    ----------拿到地图的关键帧---------------------
    poseGraph_main->mMutexkeyFrameList.lock();
    list<KeyFrame*> keyFrameList_main=poseGraph_main->keyFrameList;
    poseGraph_main->mMutexkeyFrameList.unlock();
    
   
    //实验用 记录是不是最后的结束部分了
    bool isEnd=true;
     
     //---------------拿其它所有地图和主地图去做比较-------------------------

//    readWriteLock.readLock();
    for(auto iter_end=PoseGraphGloabl_map.end(), iter_start=PoseGraphGloabl_map.begin();iter_start!=iter_end ;){
        --iter_end;
        if(iter_map==iter_end){
            continue;
        }
        //-------------遍历的其它地图
        PoseGraph* poseGraph_other=iter_end->second;
        int clientId_other=iter_end->first;
        //-------------其它地图和调用该方法的地图ID 应该不一样才对
        if(clientId_other!=clientId_main){
            //---------实验用 判断程序结束没
            if(poseGraph_other->isEnd==false){
                isEnd=false;
            }
            poseGraph_other->mMutexkeyFrameList.lock();
            list<KeyFrame*> keyFrameList_other=poseGraph_other->keyFrameList;
            poseGraph_other->mMutexkeyFrameList.unlock();
            //---------因为是做回环，所以其它地图里面要有关键帧
            if(keyFrameList_other.size()>0){
                //-----拿主地图里面，最新的关键帧和其它地图做匹配
                KeyFrame* iter_kf_main=poseGraph_main->getLastKeyframe();
                if(iter_kf_main->check_global_loop[clientId_other]==false && iter_kf_main->is_des_end){
                    iter_kf_main->check_global_loop[clientId_other]=true;
                    isEnd=false;
                    //---------去DBOW里面做检索
                    bool loop_succ=false;
                    int old_index=-1;//这个后续要记录住的 我暂时还没记录 记录了
                    vector<cv::Point2f> cur_pts;
                    vector<cv::Point2f> old_pts;
                    int min_startDetect_id=0;
                    //这里修改一下，返回的序号 ！= kf id
                    int keyPoint_num_main=iter_kf_main->keypoints.size()-iter_kf_main->point_clouds_origin.size();
//                    std::vector<cv::Point2f> cur_pts_3d, old_pts_2d;
                    poseGraph_other->isAddKF2Database_mutex.lock();
                    loop_succ = startLoopClosure_2(iter_kf_main->keypoints, iter_kf_main->descriptors,   cur_pts,old_pts, old_index,min_startDetect_id,iter_kf_main->global_index, clientId_other, poseGraph_other->demo_global_in_poseGraph, clientId_main);//返回的应该是其它地图的哪一个帧
                    old_index=poseGraph_other->treeId_kf[old_index];
                    assert(old_index!=-1);
                    poseGraph_other->isAddKF2Database_mutex.unlock();
                    //---------检测成功
                    if(loop_succ)
                     {
                         //检索到老帧 其它地图的
                         list<KeyFrame*>::iterator cur_kf_iter=poseGraph_other->getKeyframe_iter(old_index);
                          if(cur_kf_iter==poseGraph_other->keyFrameList.end()){
                              assert(false);
                          }
                          KeyFrame* cur_kf=(*cur_kf_iter);
                          if (cur_kf == NULL)
                          {
                              assert(false);//该关键帧不存在于其它地图
                          }
                          
//                         {
//                              std::ofstream outFile;
//                                 outFile.open("/Users/zhangjianhua/Desktop/VINS_MapFusion/VINS_MapFusion/data/pt_dbow/"+
//                                                        to_string(iter_kf_main->global_index)+"&"+to_string(iter_kf_main->header)+"&"+
//                                                        to_string(cur_kf->global_index)+"&"+to_string(cur_kf->header)+"_allPoint.txt");
//                                 outFile.setf(ios::fixed, ios::floatfield);  // 设定为 fixed 模式，以小数点表示浮点数
//                                 outFile.precision(19);
//                                 outFile << cur_pts_3d.size()<<"\n";
//                                 for(int i=0,j=cur_pts_3d.size(); i<j; i++)
//                              {
//                                  cv::Point2f pc=cur_pts_3d[i];
//                                  cv::Point2f po=old_pts_2d[i];
//                                  //写入数据
//                                  outFile << pc.x<<" "<<pc.y<<" "<<po.x<<" "<<po.y<<"\n";
//                              }
//
//                              //关闭文件
//                              outFile.close();
//                         }
                         
                         //这两个是粗糙的坐标
                         std::vector<cv::Point2f> measurements_cur;//像素坐标
                         std::vector<cv::Point2f> measurements_cur_norm;//图像坐标
   //                      std::vector<int> features_id;
                         //新帧的3D点(新增地图的3d点)  老帧的2D点
                         iter_kf_main->findConnectionWithOldFrame_server_old(cur_kf, measurements_cur, measurements_cur_norm);//找到匹配的特征点
//                         cout<<"measurements_cur.size() ="<<measurements_cur.size()<<endl;
                         if(measurements_cur.size()<16){
                             
                             continue;
                         }
                         
                         Matrix3d R_relative;
                         Vector3d T_relative;
                         bool isSuccess=optiRelativePose_forMainMap2(measurements_cur_norm, iter_kf_main->point_clouds, cur_kf, iter_kf_main, R_relative, T_relative,measurements_cur);
                         if(isSuccess==false)
                             continue;
                         
//                         用共视帧再构造一个约束项
//                         Matrix3d R_relative_update=R_relative;
//                         Vector3d T_relative_update=T_relative;
//                         bool isCONVERGENCE=findMoreMatch(R_relative_update,T_relative_update,iter_kf_main,cur_kf);
//                         if(isCONVERGENCE){
//                             R_relative=R_relative_update;
//                             T_relative=T_relative_update;
//                         }
                         
                         //每个帧自己存一下和别人的相对位姿关系,只检索的帧存储
//                         这个应该加锁 TODO
                         iter_kf_main->readWriteLock_loop.writeLock();
                         iter_kf_main->clientId.push_back(clientId_other);
                         iter_kf_main->kfId.push_back(cur_kf->global_index);
                         iter_kf_main->relativePose.push_back(std::make_pair(R_relative, T_relative));
                         iter_kf_main->readWriteLock_loop.writeUnLock();
                   
                          //由于不再是和主地图 做匹配。所以应该是每个地图都有一个记录 自己和哪些地图融合了
//                         这里感觉得改改 fusion_relative_isUpdate的赋值 后面竟然赋值成关键帧的数量
                          bool isAdd_otherClientId=false;
                          if(poseGraph_main->fusion_relative_isUpdate[clientId_other]!=-2)
                              isAdd_otherClientId=true;
                          

                              
                              //保存信息 这里保存，暂时没用处，后续应该会删除 有用有用 暂时没有用到
//                         cur_kf->clientId_server.push_back(clientId_main);
//                         cur_kf->global_index_server.push_back(iter_kf_main->global_index);
                              
                        //这里可能会 脏数据 这个似乎没有用到
//                          feature_id_cur[clientId_main]=iter_kf_main->features_id;
//                          measurements_norm_main[clientId_main]=measurements_cur_norm;
       
                          //这里表示 该地图第一次与主地图发生融合
                          if(!isAdd_otherClientId){
                              
                              poseGraph_main->fusion_poseGraph_mutex.lock();
                              poseGraph_main->fusion_otherGraph[clientId_other]=poseGraph_other;//记录副地图
                              poseGraph_main->fusion_poseGraph_mutex.unlock();
                              
                              poseGraph_other->fusion_poseGraph_mutex.lock();
                              poseGraph_other->fusion_otherGraph[clientId_main]=poseGraph_main;//记录副地图
                              poseGraph_other->fusion_poseGraph_mutex.unlock();
                              
                          }

                          //加锁
                           poseGraph_other->isFirstFusion_globalMutex.lock();
                          //2号帧在1号地图的位姿 前面算过了 2022.03.30 应该不用 没看到有push
//                                  f_manager_server_main.feature.clear();
          
//                                  暂时注释
                         //主地图，其它地图
//                         这个应该存在 各个小地图里面
//                         q_cur_globalFuse_index[clientId_main].push(std::make_pair(iter_kf_main->global_index, old_index));
//                         isOpposite[clientId_main]=false;
                         
                         
                         poseGraph_main->readWriteLock_fuseGlobalIndex.writeLock();
                         poseGraph_main->q_cur3d_old2d_globalIndex.push(std::make_pair(iter_kf_main->global_index, old_index));
                         poseGraph_main->q_old_clientId.push(clientId_other);
                         poseGraph_main->readWriteLock_fuseGlobalIndex.writeUnLock();

                         
                         isFirstFusion[clientId_main]+=1;
                          poseGraph_other->isFirstFusion_globalMutex.unlock();
                          cout<<"地图融合成功:"<<clientId_main<<endl;
//                          usleep(10);

                          }else{
//                              cout<<"地图融合失败"<<检测不成功<<endl;
                              usleep(10);
                          }
                          
                     
                                 
                }
            }
        }
    
    }
//    poseGraphGlobal_mutex.unlock();
    readWriteLock.readUnLock();
   
 
//    usleep(30);


}


bool PoseGraphGlobal::findMoreMatch(Matrix3d &R_relative,Vector3d &T_relative,KeyFrame *iter_kf_main,KeyFrame *cur_kf){
    Eigen::Matrix3d curKF_r_flag;
    Eigen::Vector3d curKF_t_flag;
    cur_kf->getOriginPose(curKF_t_flag, curKF_r_flag);

    Matrix3d oldKF_r_flag;
    Vector3d oldKF_t_flag;
    iter_kf_main->getOriginPose(oldKF_t_flag, oldKF_r_flag);

    R_relative=curKF_r_flag.transpose()*R_relative;
    T_relative=curKF_r_flag.transpose()*(T_relative-curKF_t_flag);
    R_relative=oldKF_r_flag*R_relative.transpose();
    T_relative=-R_relative*T_relative+oldKF_t_flag;
    //此时是  iter_kf_main的imu坐标系 到 cur_kf的世界坐标系
    
    Client* client_cur=cur_kf->c;
    Matrix3d ric_curClient=client_cur->ric_client;
    Vector3d tic_curClient=client_cur->tic_client;
    Vector3d euler_angle_ric_main=Utility::R2ypr(ric_curClient);
    const float &fx = client_cur->FOCUS_LENGTH_X_server;
    const float &fy = client_cur->FOCUS_LENGTH_Y_server;
    const float &cx = client_cur->PX_server;
    const float &cy = client_cur->PY_server;
    
    vector<vector<cv::Point2f>> measurements_old_norm_all;
    vector<vector<Eigen::Vector3d>> point_clouds_all;
    std::vector<cv::Point2f> measurements_old_coarse;//像素坐标
    std::vector<cv::Point2f> measurements_old_norm_coarse;//图像坐标
    std::vector<Vector3d> point_3d_cur;
    std::vector<cv::Point2f> measurements_cur;//像素坐标
    
    
    std::vector<KeyFrame*> vpCovKFi_cur = cur_kf->GetBestCovisibilityKeyFrames(5);
    vpCovKFi_cur.push_back(vpCovKFi_cur[0]);
    vpCovKFi_cur[0] = cur_kf;
    
    
//            while(!old_kf->IsOriginUpdate){
//                usleep(50);
//            }
    
//            cout<<"cur_kf id:"<<cur_kf->global_index<<" , " << old_kf->global_index<<endl;
    vector<KeyFrame*> vpCovKFi_old=iter_kf_main->GetBestCovisibilityKeyFrames(5);
//            可能存在和第0帧共视了 第0帧没有共视帧
    if(vpCovKFi_old.size()==0){
        vpCovKFi_old.push_back(iter_kf_main);
    }else{
        vpCovKFi_old.push_back(vpCovKFi_old[0]);//为空
        vpCovKFi_old[0]=iter_kf_main;
    }
    
    
//            list<KeyFrame*> lpCovKFi_old;
//            for(KeyFrame* pkf:vpCovKFi_old){
//                lpCovKFi_old.push_back(pkf);
//            }
    
    vector<Matrix3d> oldR_b_a;
    vector<Vector3d> oldT_b_a;
    
    Matrix3d oldKF_r;
    Vector3d oldKF_t;
    iter_kf_main->getOriginPose(oldKF_t, oldKF_r);
    
    
    int temp_index=0;
    //先算出来 在当前帧误差下，世界坐标系 到 侯选帧的共视帧的位姿关系
    for(KeyFrame* pkFi_old: vpCovKFi_old){
        if(temp_index!=0){
            Matrix3d rwi_old;
            Vector3d twi_old;
            pkFi_old->getOriginPose(twi_old, rwi_old);
            
            Matrix3d r_b_a;
            Vector3d t_b_a;
            r_b_a=oldKF_r.transpose()* rwi_old;
            t_b_a=oldKF_r.transpose()*(twi_old-oldKF_t);
            oldR_b_a.push_back(r_b_a);
            oldT_b_a.push_back(t_b_a);
        }else{
            oldR_b_a.push_back(Matrix3d::Identity());
            oldT_b_a.push_back(Vector3d::Zero());
            temp_index++;//放这里就只要执行一次
        }
    }
    
    int similarNum=0;
    temp_index=0;
    vector<Matrix3d> old_r;
    vector<Vector3d> old_t;
    vector<int> vpkf_index;
    
    for(KeyFrame* pkf_old:vpCovKFi_old){
        Matrix3d r_w_imuOld=R_relative*oldR_b_a[temp_index];
        Vector3d t_w_imuOld=R_relative*oldT_b_a[temp_index] +T_relative;
        Matrix3d r_w_camOld=r_w_imuOld*ric_curClient;
        Vector3d t_w_camOld=r_w_imuOld*tic_curClient+t_w_imuOld;
        Matrix3d r_camOld_w=r_w_camOld.transpose();
        old_r.push_back(r_camOld_w);
        old_t.push_back(-r_camOld_w*t_w_camOld);
        temp_index++;
        
    }
    
    vector<vector<int>> feature_id_old_all;
    vector<double> header_old_all;
//            vector<vector<Eigen::Vector3d>> point_clouds_all;
    vector<int> feature_id_old;
    
    {
        //当前帧的共视帧 与 侯选帧的2级共视帧的匹配，通过重投影找
        
        point_clouds_all.clear();
        measurements_old_norm_all.clear();
        vpkf_index.clear();
        header_old_all.clear();
        point_3d_cur.clear();
        feature_id_old_all.clear();
        
        
//                cout<<"当前帧的共视帧：";
        
//                cout<<endl<<endl;
        for(KeyFrame* pKFi : vpCovKFi_cur){
//                    cout<<pKFi->global_index<<" ,";
            //因为第一帧是当前帧 所以跳过 这里待会改，记录前面的值
//                    if(pKFi==cur_kf ){
//                        point_clouds_all.push_back(point_3d_cur_real);
//                        measurements_old_norm_all.push_back(measurements_old_norm_real);
//                        vpkf_index.push_back(0);
////                        old_kf->isuse=1;
////                        temp_index++;
//                        continue;
//                    }
            //描述符得全有
            if(!pKFi->is_des_end){
                continue;
            }
            
            vector<Eigen::Vector3d> point_clouds_origin_cur= pKFi->point_clouds_origin;
            std::vector<cv::Point2f> measurements_origin_cur=pKFi->measurements_origin;
            vector<cv::KeyPoint> keypoints_cur=pKFi->keypoints;
            vector<int > feature_id_origin_cur=pKFi->features_id_origin;
            int nPoints = point_clouds_origin_cur.size();
            int point2D_len_cur=keypoints_cur.size()-point_clouds_origin_cur.size();
           
//                int num=0;//记录匹配点的数量
            temp_index=0;//记录遍历到哪个帧了
            //这里应该遍历候选帧的共视帧 ，只要共视点数量超过一定阈值 22
            for(KeyFrame* pkFi_old: vpCovKFi_old)
            {
                
//                        if(pKFi==cur_kf && pkFi_old==old_kf){
//                            point_clouds_all.push_back(point_3d_cur_real);
//                            measurements_old_norm_all.push_back(measurements_old_norm_real);
//                            vpkf_index.push_back(0);
//                            temp_index++;
//                            continue;
//                        }
                //描述符得全有
                if(!pkFi_old->is_des_end){
                    temp_index++;
                    continue;
                }
                
                measurements_old_coarse.clear();
                measurements_old_norm_coarse.clear();
                point_3d_cur.clear();
                measurements_cur.clear();
                feature_id_old.clear();
            
                vector<cv::KeyPoint> keypoints_old=pkFi_old->keypoints;
                vector<int > feature_id_origin_old=pkFi_old->features_id_origin;
                int nPoints_old = feature_id_origin_old.size();
                int point2D_len_old=keypoints_old.size()-nPoints_old;

                //这个得到的是到imu坐标系的位姿
                Matrix3d r_camOld_w=old_r[temp_index];
                Vector3d t_camOld_w=old_t[temp_index];
                
                for(int i=0;i<nPoints;i++){
                    Vector3d point_main=point_clouds_origin_cur[i];
                    //把主地图下 世界坐标系的点 转到小地图上一帧的图像坐标系上
                    Vector3d p3D_c2=r_camOld_w*point_main+t_camOld_w;
                    //深度必须为正
                    if(p3D_c2[2]<0.0 || p3D_c2[2]>30.0){
//                            cout<<"深度不为正"<<endl;
                        continue;
                    }
                    // 投影到图像上
                    double x = p3D_c2[0];
                    double y = p3D_c2[1];
                    double z = p3D_c2[2];
                    //这里可能得加一个畸变校正 应该可以不用去校正 把他投影在一个没有畸变的图像上
                    double u=fx*x/z+cx;
                    double v=fy*y/z+cy;
                  
                    
                    if(!pkFi_old->isInImage((float)u, (float)v)){
//                            cout<<"投影点不在图像内"<<endl;
                        continue;
                    }
                    
                    const vector<int> vIndices=pkFi_old->GetFeaturesInArea_1((float)u, (float)v, 20);
                    //这里可以改为30个像素里面找不到 再扩大到50个像素 暂时未做
                    if(vIndices.empty()){
//                            cout<<"半径为50个像素 找不到点"<<endl;
                        continue;
                    }
                    //des和keypoints长度不一样
                    //找在这个半径内最相似的 这里可能有些问题 因为3D点的描述子 个人感觉有问题
                    BRIEF::bitset point_main_des=pKFi->descriptors[point2D_len_cur+i];
                    int bestDist = 256;
                    int bestIndex = -1;
                    for(vector<int>::const_iterator vit=vIndices.begin(), vit_end=vIndices.end(); vit!=vit_end; vit++)
                    {
    //                    cout<<"*vit"<<*vit<<endl;发现 keypoints数量不等于des数量
                        int dis = pkFi_old->HammingDis(point_main_des, pkFi_old->descriptors[*vit]);
                        if(dis < bestDist)
                        {
                            bestDist = dis;
                            bestIndex = *vit;
                        }
                    }
                    
                    if(bestDist<70){
//                                cout<<"最终选择的半径范围："<<u-keypoints_old[bestIndex].pt.x<<" ,"<<v-keypoints_old[bestIndex].pt.y<<endl;
                        point_3d_cur.push_back(point_main);
                        measurements_old_coarse.push_back(keypoints_old[bestIndex].pt);
                        measurements_cur.push_back(measurements_origin_cur[i]);
                        
                        if(bestIndex<point2D_len_old){
//                                    feature_id_old.push_back(-1);//后续加上去
                            
                            feature_id_old.push_back(feature_id_origin_cur[i]);
                            
                        }else{
//                                    int index=bestIndex-point2D_len_old;
//                                    feature_id_old.push_back(feature_id_origin_old[index]);
                            
                            feature_id_old.push_back(-1);
                        }
                    }
                                
                }
                
//                        cout<<"50个像素内,找到的点数："<<point_3d_cur.size()<<endl;
                if(measurements_cur.size()>=22){
                    pKFi->rejectWithF_server_mapFuse2(measurements_cur, measurements_old_coarse,point_3d_cur,feature_id_old);
//                            cout<<"f矩阵拒绝后的点数："<<measurements_old_coarse.size()<<endl;
                    if(measurements_old_coarse.size()>=16){
                    
                        cv::Point2f norm_pt;
                        int pCount=measurements_old_coarse.size();
                        for(int aa=0;aa<pCount;aa++){
                            norm_pt.x = (measurements_old_coarse[aa].x -  client_cur->PX_server)/ client_cur->FOCUS_LENGTH_X_server;
                            norm_pt.y = (measurements_old_coarse[aa].y -  client_cur->PY_server)/ client_cur->FOCUS_LENGTH_Y_server;
                            measurements_old_coarse[aa]=norm_pt;
                            
                        }
                        
                        point_clouds_all.push_back(point_3d_cur);
                        measurements_old_norm_all.push_back(measurements_old_coarse);
                        
                        header_old_all.push_back(pkFi_old->header);
                        feature_id_old_all.push_back(feature_id_old);
//                            num+=point_3d_cur.size();
//                            real_vpCovKFi_cur.push_back(pkFi_old);
                        vpkf_index.push_back(temp_index);
                        similarNum++;
//                                pkFi_old->isuse=1;
//                                cout<<"两帧匹配上："<<pKFi->global_index<<" ,"<<pkFi_old->global_index<<", "<<measurements_old_coarse.size()<<". "<<endl;
//                                break;
                    }
                    
                }
                
                temp_index++;
//                    ends=clock();
//                    cout<<"为一个帧投影一次 找匹配，花费的时间："<<ends-start<<endl;
            }
        }
    }
    
//            for(KeyFrame* pkFi_old: vpCovKFi_old)
//            {
//                pkFi_old->isuse=0;
//            }

    if(similarNum>=3){
        int optiKf_num=vpkf_index.size()+2;
        //构造优化问题
        double t_array[optiKf_num][3];//平移数组，其中存放每个关键帧的平移向量
        Quaterniond q_array[optiKf_num];
        double euler_array[optiKf_num][3];

        ceres::Problem problem;
        ceres::Solver::Options options;
        //options.linear_solver_type = ceres::DENSE_NORMAL_CHOLESKY;
        options.linear_solver_type = ceres::DENSE_SCHUR;
        //options.minimizer_progress_to_stdout = true;
        options.max_num_iterations = 20;
        ceres::Solver::Summary summary;
        ceres::LossFunction *loss_function;
        loss_function = new ceres::HuberLoss(1.0);
//            ceres::LossFunction *loss_function_feature;
//            loss_function_feature = new ceres::CauchyLoss(1.0);
        //AngleLocalParameterization类的主要作用是指定yaw角优化变量的迭代更新，重载了括号运算
        ceres::LocalParameterization* angle_local_parameterization = AngleLocalParameterization::Create();

        
        Matrix3d curKF_r;
        Vector3d curKF_t;
        cur_kf->getOriginPose(curKF_t, curKF_r);
        
        
        Matrix3d tmp_r_old;
        Vector3d tmp_t_old;
        t_array[0][0] = T_relative(0);
        t_array[0][1] = T_relative(1);
        t_array[0][2] = T_relative(2);
        //将矩阵转换为向量
        Eigen::Vector3d euler_angle_old = Utility::R2ypr(R_relative);
        
//                t_array[0][0] = curKF_t(0);
//                t_array[0][1] = curKF_t(1);
//                t_array[0][2] = curKF_t(2);
//                //将矩阵转换为向量
//                Vector3d euler_angle_old = Utility::R2ypr(curKF_r);
        euler_array[0][0] = euler_angle_old.x();
        euler_array[0][1] = euler_angle_old.y();
        euler_array[0][2] = euler_angle_old.z();
        problem.AddParameterBlock(euler_array[0], 3);
        problem.AddParameterBlock(t_array[0], 3);

        
        //再加一个根据当前帧与侯选帧之间的匹配关系，构造最开始的那个3d点 到候选帧的误差
        map<int,int> resample;
        
        temp_index=0;
        int residual_totalSize=0;
        for(int len=vpkf_index.size(); temp_index<len; temp_index++ ){
            
            int kf_index=temp_index+1;
            Matrix3d relative_r_b_a;
            Vector3d relative_t_b_a;
            relative_r_b_a=oldR_b_a[vpkf_index[temp_index]];
            relative_t_b_a=oldT_b_a[vpkf_index[temp_index]];
            Vector3d relative_r_b_a_euler=Utility::R2ypr(relative_r_b_a);
            
            map<int,int>::iterator iter;
            iter = resample.find(vpkf_index[temp_index]);
            if(iter != resample.end())
            {
                kf_index=resample[vpkf_index[temp_index]];
            }
            else
            {
                resample[vpkf_index[temp_index]]=kf_index;

                t_array[kf_index][0] = relative_t_b_a(0);
                t_array[kf_index][1] = relative_t_b_a(1);
                t_array[kf_index][2] = relative_t_b_a(2);
                euler_array[kf_index][0] = relative_r_b_a_euler.x();
                euler_array[kf_index][1] = relative_r_b_a_euler.y();
                euler_array[kf_index][2] = relative_r_b_a_euler.z();
                problem.AddParameterBlock(euler_array[kf_index], 1, angle_local_parameterization);
                problem.AddParameterBlock(t_array[kf_index], 3);
                
//                        if(vpkf_index[temp_index]==0){
//                            problem.SetParameterBlockConstant(euler_array[kf_index]);
//                            problem.SetParameterBlockConstant(t_array[kf_index]);
//                        }
               
                ceres::CostFunction* cost_function = FourSixDOFError::Create( relative_t_b_a(0),relative_t_b_a(1),relative_t_b_a(2),relative_r_b_a_euler(0),1);
                problem.AddResidualBlock(cost_function, loss_function, euler_array[kf_index],t_array[kf_index]);
                
            }

            vector<Vector3d> point_single=point_clouds_all[temp_index];
            vector<cv::Point2f> measure_single=measurements_old_norm_all[temp_index];
            for(int a=0,b=point_single.size();a<b;a++){

                //找到主地图那个点 所在帧的位姿
                Vector3d pts_i = point_single[a];

                //相机平面坐标
                cv::Point2f pt=measure_single[a];

                ceres::CostFunction* cost_function = FourSixDOFWeightError_reprojection_3::Create( pts_i.x(), pts_i.y(), pts_i.z(),pt.x, pt.y, tic_curClient[0], tic_curClient[1], tic_curClient[2], euler_angle_ric_main.x(), euler_angle_ric_main.y(), euler_angle_ric_main.z() ,relative_r_b_a_euler(1),relative_r_b_a_euler(2),100.0);
                problem.AddResidualBlock(cost_function, loss_function, euler_array[0],t_array[0], euler_array[kf_index],t_array[kf_index]);
                
                residual_totalSize++;
                
             }
        }
        
        
        ceres::Solve(options, &problem, &summary);
        std::cout <<"地图之间 精确相对位姿："<< summary.BriefReport() << "\n";

        if(summary.termination_type==ceres::CONVERGENCE){
            return true;
        }

    }
    return false;
}


//这里的思想还是和主地图进行融合，后面改一下
//第三篇论文
void  PoseGraphGlobal::MergeLocal_18(){
    while(true){

//        poseGraphGlobal_mutex.lock();
        readWriteLock.readLock();
        int len = PoseGraphGloabl_map.size();
        if(PoseGraphGloabl_map.size()>1){
//            poseGraphGlobal_mutex.unlock();
            readWriteLock.readUnLock();
            for(int client_id=0;client_id<len;client_id++){//这里的i其实代表的就是 ClientId
    //            poseGraphGlobal_mutex.lock();
                readWriteLock.readLock();
                map<int,PoseGraph*>::iterator iter_map = PoseGraphGloabl_map.find(client_id);
                if(iter_map==PoseGraphGloabl_map.end()){
    //                poseGraphGlobal_mutex.unlock();
                    readWriteLock.readUnLock();
                    continue;
                }
                
                //第一步---------------------得到两个地图和两个匹配帧------------------------------------------------
                PoseGraph* pCurrentMap= iter_map->second;//新的地图 小的地图
    //            poseGraphGlobal_mutex.unlock();
                readWriteLock.readUnLock();
                
                pCurrentMap->isFirstFusion_globalMutex.lock();
                if(isFirstFusion[client_id]==0)//这里就是下面是否进行操作的激活条件
                {
                    pCurrentMap->isFirstFusion_globalMutex.unlock();
                    continue;
                }
                
                //得到另一个匹配的其它地图 2d点
                pCurrentMap->readWriteLock_fuseGlobalIndex.writeLock();
                int clientId_other=pCurrentMap->q_old_clientId.front();
                pCurrentMap->q_old_clientId.pop();
                //得到两个匹配的关键帧 前面是自己的 后面是别人的
                int mainKF_global_index=pCurrentMap->q_cur3d_old2d_globalIndex.front().first;//3d
                int otherKF_global_index= pCurrentMap->q_cur3d_old2d_globalIndex.front().second;
                pCurrentMap->q_cur3d_old2d_globalIndex.pop();
                pCurrentMap->readWriteLock_fuseGlobalIndex.writeUnLock();
    
                pCurrentMap->isFirstFusion_globalMutex.unlock();
                
                readWriteLock.readLock();
                PoseGraph* pMergeMap=PoseGraphGloabl_map[clientId_other];//老的地图 主地图 精度更高
                readWriteLock.readUnLock();
                
    //            -------找到两个相应的关键帧-----start-------------------
                KeyFrame* pCurKF= pCurrentMap->getLastKeyframe_index(mainKF_global_index);
                KeyFrame* pMergeKF_other= pMergeMap->getKeyframe2(otherKF_global_index);
    //            -------找到两个相应的关键帧-----end-------------------
                realMergeLocal_20(pCurKF,pMergeKF_other, pCurrentMap, pMergeMap,1);//1
               
            }
        }else{
//            poseGraphGlobal_mutex.unlock();
            readWriteLock.readUnLock();
//            usleep(2000);
        }
//        usleep(30);
    }
}

//第三篇论文
void PoseGraphGlobal::realMergeLocal_18(KeyFrame* kf_3d, KeyFrame* kf_2d, PoseGraph* pg_3d, PoseGraph* pg_2d,int noMain){
    TS(realMergeLocal_19_if);
    int kf_3d_id=kf_3d->global_index;
    int kf_2d_id=kf_2d->global_index;
    int agent_2d_id=pg_2d->c->getId();
    cout<<kf_3d_id<<" , "<<kf_2d_id<<" , "<<agent_2d_id<<endl;
    //第二步-------------------------根据前面求得的粗糙的相对位姿求得准确的相对位姿--------重投影找匹配点---------------------------
    vector<vector<cv::Point2f>> measurements_old_norm_all;
    vector<vector<Eigen::Vector3d>> point_clouds_all;
    std::vector<cv::Point2f> measurements_old_coarse;//像素坐标
    std::vector<cv::Point2f> measurements_old_norm_coarse;//图像坐标
    std::vector<Vector3d> point_3d_cur;
    std::vector<cv::Point2f> measurements_cur;//像素坐标
    
    //这里就是假设所有的都是正的
    vector<KeyFrame*> vpCovKFi_old=kf_2d->GetBestCovisibilityKeyFrames(5);
    vpCovKFi_old.push_back(vpCovKFi_old[0]);
    vpCovKFi_old[0]=kf_2d;
    Matrix3d oldKF_r;
    Vector3d oldKF_t;
    kf_2d->getOriginPose(oldKF_t, oldKF_r);
        
    
        
    vector<Matrix3d> oldR_b_a;
    vector<Vector3d> oldT_b_a;
    int temp_index=0;
    //先算出来 在当前帧误差下，世界坐标系 到 侯选帧的共视帧的位姿关系
    for(KeyFrame* pkFi_old: vpCovKFi_old){
        if(temp_index!=0){
            Matrix3d rwi_old;
            Vector3d twi_old;
            pkFi_old->getOriginPose(twi_old, rwi_old);
            
            Matrix3d r_b_a;
            Vector3d t_b_a;
            r_b_a=oldKF_r.transpose()* rwi_old;
            t_b_a=oldKF_r.transpose()*(twi_old-oldKF_t);
            oldR_b_a.push_back(r_b_a);
            oldT_b_a.push_back(t_b_a);
        }else{
            oldR_b_a.push_back(Matrix3d::Identity());
            oldT_b_a.push_back(Vector3d::Zero());
            temp_index++;//放这里就只要执行一次
        }
    }
   
    int similarNum=0;
    temp_index=0;
    vector<Matrix3d> old_r;
    vector<Vector3d> old_t;
    vector<int> vpkf_index;
    
    
    Matrix3d R_relative;
    Vector3d T_relative;
   
    vector<int> clientId=kf_3d->clientId;
    vector<int> kfId=kf_3d->kfId;
    vector<std::pair<Matrix3d , Vector3d >  > relativePose=kf_3d->relativePose;
    int client_matchId=kf_2d->c->id, kf2d_global_index=kf_2d->global_index;//这里表示主地图的意思，后面肯定要改
    for(int i=0, len=clientId.size();i<len;i++){
        if(clientId[i]==client_matchId && kfId[i]==kf2d_global_index){
            R_relative=relativePose[i].first;
            T_relative=relativePose[i].second;
        }
    }
   
    
    Client* client_cur=kf_2d->c;
    Matrix3d ric_curClient=client_cur->ric_client;
    Vector3d tic_curClient=client_cur->tic_client;
    Vector3d euler_angle_ric_main=Utility::R2ypr(ric_curClient);
    const float &fx = client_cur->FOCUS_LENGTH_X_server;
    const float &fy = client_cur->FOCUS_LENGTH_Y_server;
    const float &cx = client_cur->PX_server;
    const float &cy = client_cur->PY_server;
    
   
        
    for(KeyFrame* pkf_old:vpCovKFi_old){
        Matrix3d r_w_imuOld=R_relative*oldR_b_a[temp_index];
        Vector3d t_w_imuOld=R_relative*oldT_b_a[temp_index] +T_relative;
        Matrix3d r_w_camOld=r_w_imuOld*ric_curClient;
        Vector3d t_w_camOld=r_w_imuOld*tic_curClient+t_w_imuOld;
        Matrix3d r_camOld_w=r_w_camOld.transpose();
        old_r.push_back(r_camOld_w);
        old_t.push_back(-r_camOld_w*t_w_camOld);
        temp_index++;
        
    }
    
    while(!kf_3d->IsOriginUpdate){
        usleep(50);
    }
    std::vector<KeyFrame*> vpCovKFi_cur = kf_3d->GetBestCovisibilityKeyFrames(5);
    vpCovKFi_cur.push_back(vpCovKFi_cur[0]);
    vpCovKFi_cur[0] = kf_3d;
    
    
    {
        //当前帧的共视帧 与 侯选帧的2级共视帧的匹配，通过重投影找
        
        point_clouds_all.clear();
        measurements_old_norm_all.clear();
        vpkf_index.clear();
        for(KeyFrame* pKFi : vpCovKFi_cur){

            //描述符得全有
            if(!pKFi->is_des_end){
                continue;
            }
            
            vector<Eigen::Vector3d> point_clouds_origin_cur= pKFi->point_clouds_origin;
            std::vector<cv::Point2f> measurements_origin_cur=pKFi->measurements_origin;
            vector<cv::KeyPoint> keypoints_cur=pKFi->keypoints;
            int nPoints = point_clouds_origin_cur.size();
            int point2D_len_cur=keypoints_cur.size()-point_clouds_origin_cur.size();
           
//                int num=0;//记录匹配点的数量
            temp_index=0;//记录遍历到哪个帧了
            //这里应该遍历候选帧的共视帧 ，只要共视点数量超过一定阈值 22
            for(KeyFrame* pkFi_old: vpCovKFi_old)
            {
                

                //描述符得全有
                if(!pkFi_old->is_des_end){
                    temp_index++;
                    continue;
                }
                
                measurements_old_coarse.clear();
                measurements_old_norm_coarse.clear();
                point_3d_cur.clear();
                measurements_cur.clear();
            
                vector<cv::KeyPoint> keypoints_old=pkFi_old->keypoints;

                //这个得到的是到imu坐标系的位姿
                Matrix3d r_camOld_w=old_r[temp_index];
                Vector3d t_camOld_w=old_t[temp_index];
                
                for(int i=0;i<nPoints;i++){
                    Vector3d point_main=point_clouds_origin_cur[i];
                    //把主地图下 世界坐标系的点 转到小地图上一帧的图像坐标系上
                    Vector3d p3D_c2=r_camOld_w*point_main+t_camOld_w;
                    //深度必须为正
                    if(p3D_c2[2]<0.0 || p3D_c2[2]>30.0){
//                            cout<<"深度不为正"<<endl;
                        continue;
                    }
                    // 投影到图像上
                    double x = p3D_c2[0];
                    double y = p3D_c2[1];
                    double z = p3D_c2[2];
                    //这里可能得加一个畸变校正 应该可以不用去校正 把他投影在一个没有畸变的图像上
                    double u=fx*x/z+cx;
                    double v=fy*y/z+cy;
                  
                    
                    if(!pkFi_old->isInImage((float)u, (float)v)){
//                            cout<<"投影点不在图像内"<<endl;
                        continue;
                    }
                    
                    const vector<int> vIndices=pkFi_old->GetFeaturesInArea_1((float)u, (float)v, 20);
                    //这里可以改为30个像素里面找不到 再扩大到50个像素 暂时未做
                    if(vIndices.empty()){
//                            cout<<"半径为20个像素 找不到点"<<endl;
                        continue;
                    }
                    //des和keypoints长度不一样
                    //找在这个半径内最相似的 这里可能有些问题 因为3D点的描述子 个人感觉有问题
                    BRIEF::bitset point_main_des=pKFi->descriptors[point2D_len_cur+i];
                    int bestDist = 256;
                    int bestIndex = -1;
                    for(vector<int>::const_iterator vit=vIndices.begin(), vit_end=vIndices.end(); vit!=vit_end; vit++)
                    {
    //                    cout<<"*vit"<<*vit<<endl;发现 keypoints数量不等于des数量
                        int dis = pkFi_old->HammingDis(point_main_des, pkFi_old->descriptors[*vit]);
                        if(dis < bestDist)
                        {
                            bestDist = dis;
                            bestIndex = *vit;
                        }
                    }
                    
                    if(bestDist<70){
//                                cout<<"最终选择的半径范围："<<u-keypoints_old[bestIndex].pt.x<<" ,"<<v-keypoints_old[bestIndex].pt.y<<endl;
                        point_3d_cur.push_back(point_main);
                        measurements_old_coarse.push_back(keypoints_old[bestIndex].pt);
                        measurements_cur.push_back(measurements_origin_cur[i]);
                        
                    }
                                
                }
                
//                        cout<<"50个像素内,找到的点数："<<measurements_cur.size()<<endl;
                if(measurements_cur.size()>=22){
                    pKFi->rejectWithF_server_mapFuse(measurements_cur, measurements_old_coarse,point_3d_cur);
//                            cout<<"f矩阵拒绝后的点数："<<measurements_cur.size()<<", "<<pKFi->global_index<<" ,"<<pkFi_old->global_index<<endl;
                    if(measurements_old_coarse.size()>16){
                    
                        cv::Point2f norm_pt;
                        int pCount=measurements_old_coarse.size();
                        for(int aa=0;aa<pCount;aa++){
                            norm_pt.x = (measurements_old_coarse[aa].x -  client_cur->PX_server)/ client_cur->FOCUS_LENGTH_X_server;
                            norm_pt.y = (measurements_old_coarse[aa].y -  client_cur->PY_server)/ client_cur->FOCUS_LENGTH_Y_server;
                            measurements_old_coarse[aa]=norm_pt;
                            
                        }
                        
                        point_clouds_all.push_back(point_3d_cur);
                        measurements_old_norm_all.push_back(measurements_old_coarse);

                        vpkf_index.push_back(temp_index);
                        similarNum++;
                        

                    }
                    
                }
                
                temp_index++;
            }
        }
    }

   
    
    PoseGraph* pCurrentMap;
    int client_id_3d,client_id_2d,otherKF_global_index,curKF_global_index;
//    if(noMain==1){
        pCurrentMap=pg_3d;
        client_id_3d=kf_3d->c->id;
        client_id_2d=kf_2d->c->id;
        otherKF_global_index=kf_2d->global_index;
        curKF_global_index=kf_3d->global_index;
//    }
//    else{
//        pCurrentMap=pg_2d;
//        client_id_3d=kf_2d->c->id;
//        client_id_2d=kf_2d->c->id;
//        mainKF_global_index=kf_3d->global_index;
//        curKF_global_index=kf_2d->global_index;
//    }
    
        if(similarNum>=2){
            int optiKf_num=vpkf_index.size()+2;
            //构造优化问题
            double t_array[optiKf_num][3];//平移数组，其中存放每个关键帧的平移向量
            Quaterniond q_array[optiKf_num];
            double euler_array[optiKf_num][3];

            ceres::Problem problem;
            ceres::Solver::Options options;
            //options.linear_solver_type = ceres::DENSE_NORMAL_CHOLESKY;
            options.linear_solver_type = ceres::DENSE_SCHUR;
            //options.minimizer_progress_to_stdout = true;
            options.max_num_iterations = 20;
            ceres::Solver::Summary summary;
            ceres::LossFunction *loss_function;
            loss_function = new ceres::HuberLoss(1.0);
            //AngleLocalParameterization类的主要作用是指定yaw角优化变量的迭代更新，重载了括号运算
            ceres::LocalParameterization* angle_local_parameterization = AngleLocalParameterization::Create();

            
            Matrix3d curKF_r;
            Vector3d curKF_t;
            kf_3d->getOriginPose(curKF_t, curKF_r);
            
            
            Matrix3d tmp_r_old;
            Vector3d tmp_t_old;
            t_array[0][0] = curKF_t(0);
            t_array[0][1] = curKF_t(1);
            t_array[0][2] = curKF_t(2);
            //将矩阵转换为向量
            Vector3d euler_angle_old = Utility::R2ypr(curKF_r);
            euler_array[0][0] = euler_angle_old.x();
            euler_array[0][1] = euler_angle_old.y();
            euler_array[0][2] = euler_angle_old.z();
            problem.AddParameterBlock(euler_array[0], 3);
            problem.AddParameterBlock(t_array[0], 3);

            
            //再加一个根据当前帧与侯选帧之间的匹配关系，构造最开始的那个3d点 到候选帧的误差
            map<int,int> resample;
            
            temp_index=0;
            for(int len=vpkf_index.size(); temp_index<len; temp_index++ ){
                
                int kf_index=temp_index+1;
                Matrix3d relative_r_b_a;
                Vector3d relative_t_b_a;
                relative_r_b_a=oldR_b_a[vpkf_index[temp_index]];
                relative_t_b_a=oldT_b_a[vpkf_index[temp_index]];
                Vector3d relative_r_b_a_euler=Utility::R2ypr(relative_r_b_a);
                
                
                map<int,int>::iterator iter;
                iter = resample.find(vpkf_index[temp_index]);
                if(iter != resample.end())
                {
                    kf_index=resample[vpkf_index[temp_index]];
                }
                else
                {
                    resample[vpkf_index[temp_index]]=kf_index;

                    t_array[kf_index][0] = relative_t_b_a(0);
                    t_array[kf_index][1] = relative_t_b_a(1);
                    t_array[kf_index][2] = relative_t_b_a(2);
                    euler_array[kf_index][0] = relative_r_b_a_euler.x();
                    euler_array[kf_index][1] = relative_r_b_a_euler.y();
                    euler_array[kf_index][2] = relative_r_b_a_euler.z();
                    problem.AddParameterBlock(euler_array[kf_index], 1, angle_local_parameterization);
                    problem.AddParameterBlock(t_array[kf_index], 3);
                   
                    ceres::CostFunction* cost_function = FourSixDOFError::Create( relative_t_b_a(0),relative_t_b_a(1),relative_t_b_a(2),relative_r_b_a_euler(0),1);
                    problem.AddResidualBlock(cost_function, loss_function, euler_array[kf_index],t_array[kf_index]);
                    
                }
              

                vector<Vector3d> point_single=point_clouds_all[temp_index];
                vector<cv::Point2f> measure_single=measurements_old_norm_all[temp_index];
                for(int a=0,b=point_single.size();a<b;a++){

                    //找到主地图那个点 所在帧的位姿
                    Vector3d pts_i = point_single[a];

                    //相机平面坐标
                    cv::Point2f pt=measure_single[a];

                    ceres::CostFunction* cost_function = FourSixDOFWeightError_reprojection_3::Create( pts_i.x(), pts_i.y(), pts_i.z(),pt.x, pt.y, tic_curClient[0], tic_curClient[1], tic_curClient[2], euler_angle_ric_main.x(), euler_angle_ric_main.y(), euler_angle_ric_main.z() ,relative_r_b_a_euler(1),relative_r_b_a_euler(2),100.0);
                    problem.AddResidualBlock(cost_function, loss_function, euler_array[0],t_array[0], euler_array[kf_index],t_array[kf_index]);
                    
                 }
            }
            
         
            ceres::Solve(options, &problem, &summary);
            std::cout <<"全局-精确相对位姿："<<kf_3d->c->id<<" , "<< summary.BriefReport() << "\n";

            if(summary.termination_type!=ceres::CONVERGENCE){
                pCurrentMap->isFirstFusion_globalMutex.lock();
                isFirstFusion[client_id_3d]-=1;
                pCurrentMap->isFirstFusion_globalMutex.unlock();
                return;}
            
            
            
            Matrix3d Rs_i ;
            Vector3d Ps_i ;//当前帧
            kf_3d->getOriginPose(Ps_i, Rs_i);
            



            Vector3d q;
            q<<euler_array[0][0],euler_array[0][1],euler_array[0][2];
            Matrix3d Rs_loop = Utility::ypr2R(q);
            Vector3d Ps_loop = Vector3d( t_array[0][0],  t_array[0][1],  t_array[0][2]);

//求得的是3d到2d的关系
            Vector3d relative_t = Rs_loop.transpose() * (Ps_i - Ps_loop);
//                Matrix3d relative_q = Rs_loop.transpose() * Rs_i;
            double relative_yaw = Utility::normalizeAngle(Utility::R2ypr(Rs_i).x() - Utility::R2ypr(Rs_loop).x());
            double relative_pitch = Utility::normalizeAngle(Utility::R2ypr(Rs_i).y() - Utility::R2ypr(Rs_loop).y());
            double relative_roll = Utility::normalizeAngle(Utility::R2ypr(Rs_i).z() - Utility::R2ypr(Rs_loop).z());
//            Quaterniond rela_q=Quaterniond(relative_q);
            
            Quaterniond rs_loop_q=Quaterniond(Rs_loop),rs_i_q=Quaterniond(Rs_i);
            Quaterniond rela_q=rs_loop_q.inverse()*rs_i_q;
//测试
//            Quaterniond tmp_q,tmp_i;
//            tmp_q=Rs_loop;
//            tmp_i=Rs_i;
//            double w_q_i[4],i_q_w[4],t_w_ij[3],t_i_ij[3];
//            w_q_i[0]=tmp_q.w();
//            w_q_i[1]=tmp_q.x();
//            w_q_i[2]=tmp_q.y();
//            w_q_i[3]=tmp_q.z();
//            QuaternionInverse(w_q_i, i_q_w);
//            t_w_ij[0]=Ps_i[0] - Ps_loop[0];
//            t_w_ij[1]=Ps_i[1] - Ps_loop[1];
//            t_w_ij[2]=Ps_i[2] - Ps_loop[2];
//            ceres::QuaternionRotatePoint(i_q_w, t_w_ij, t_i_ij);
////            cout<<"relative_t"<<relative_t.x()<<" , "<<relative_t.y()<<" , "<<relative_t.z()<<endl;
////            cout<<"t_i_ij="<<t_i_ij[0]<<" , "<<t_i_ij[1]<<" , "<<t_i_ij[2]<<endl;
//
//            double w_q_j[4],q_i_j[4];
//            w_q_j[0]=tmp_i.w();
//            w_q_j[1]=tmp_i.x();
//            w_q_j[2]=tmp_i.y();
//            w_q_j[3]=tmp_i.z();
//            ceres::QuaternionProduct(i_q_w, w_q_j, q_i_j);
////            cout<<"rela_q"<<rela_q.w()<<" , "<<rela_q.x()<<" , "<<rela_q.y()<<" , "<<rela_q.z()<<endl;
////            cout<<"q_i_j"<<q_i_j[0]<<" , "<<q_i_j[1]<<" , "<<q_i_j[2]<<" , "<<q_i_j[3]<<endl;
//
//            if(fabs(rela_q.x()-q_i_j[1])>0.000001 || fabs(rela_q.y()-q_i_j[2])>0.000001 ||fabs(rela_q.z()-q_i_j[3])>0.000001 ){
////                cout<<"rela_q"<<rela_q.w()<<" , "<<rela_q.x()<<" , "<<rela_q.y()<<" , "<<rela_q.z()<<endl;
////                cout<<"q_i_j"<<q_i_j[0]<<" , "<<q_i_j[1]<<" , "<<q_i_j[2]<<" , "<<q_i_j[3]<<endl;
//                cout<<"数据不规范"<<endl;
//                pCurrentMap->isFirstFusion_globalMutex.lock();
//
//                isFirstFusion[client_id_3d]-=1;
//                pCurrentMap->isFirstFusion_globalMutex.unlock();
//                return;
//            }
            //实验记录
//            std::ofstream outFile;
//            //打开文件
//            outFile.open("/Users/zhangjianhua/Desktop/hh/VINS_MapFusion/VINS_MapFusion/data/"+
//                             to_string(kf_3d->global_index)+"&"+to_string(kf_3d->header)+"&"+to_string(kf_2d->global_index)+"&"+to_string(kf_2d->header)+".txt");
//            outFile.setf(ios::fixed, ios::floatfield);  // 设定为 fixed 模式，以小数点表示浮点数
//            outFile.precision(19);
//                //写入数据
////                outFile <<"测试是否存在误匹配，当前client.id:\n"<<kf_3d->c->id<<"\n当作帧的header:\n"<<kf_3d->header<<"\n当作帧的global_index:\n"<<kf_3d->global_index<<"\n2d帧的client.id:\n"<<kf_2d->c->id <<"\n2d帧的header:\n"<<kf_2d->header<<"\n2d帧的global_index:\n"<<kf_2d->global_index  <<"\n3d-2d的r:\n"<<rela_q<<"\n3d-2d的t\n"<<relative_t;
//            outFile <<kf_3d->c->id<<"\n"<<kf_3d->header<<"\n"<<kf_3d->global_index<<"\n"<<kf_2d->c->id <<"\n"<<kf_2d->header<<"\n"<<kf_2d->global_index  <<"\n"<<rela_q.x()<<"\n"<<rela_q.y()<<"\n"<<rela_q.z()<<"\n"<<rela_q.w()<<"\n"<<relative_t[0]<<"\n"<<relative_t[1]<<"\n"<<relative_t[2];
//                //关闭文件
//            outFile.close();
            Eigen::Matrix<double, 8, 1> connected_info;
            connected_info <<relative_t.x(), relative_t.y(), relative_t.z(),
            rela_q.w(), rela_q.x(), rela_q.y(), rela_q.z(),
            relative_yaw;
//            for(int i=0, len=clientId.size();i<len;i++){
//                if(clientId[i]==client_matchId && kfId[i]==kf2d_global_index){
                    kf_3d->relative_global_loop_info_multiClient.push_back(connected_info);
//                }
//            }
            
//            实验 开始
//            cout<<"回环："<<pg_2d->c->getId()<<" ,"<<pg_3d->c->getId()<<endl;
            bool isFuse=pg_3d->fuseClientId[pg_2d->c->getId()];
//            cout<<"isFuse= "<<isFuse<<" , "<<pg_2d->c->getId()<<endl;
            if(!isFuse){
                cout<<"回环："<<pg_2d->c->getId()<<" , "<<pg_3d->c->getId()<<endl;
                cout<<"回环kfid："<<kf_2d->global_index<<" , "<<kf_3d->global_index<<endl;
//                是第一次融合
                pg_3d->fuseClientId[pg_2d->c->getId()]=true;
                Matrix3d r_w2_j;
                Vector3d t_w2_j;
                kf_2d->getOriginPose(t_w2_j, r_w2_j);
                pg_3d->fromI2OtherClient_r[pg_2d->c->getId()]=r_w2_j*Rs_loop.transpose();
                pg_3d->fromI2OtherClient_t[pg_2d->c->getId()]=-pg_3d->fromI2OtherClient_r[pg_2d->c->getId()]*Ps_loop+t_w2_j;
                
//                cout<<"赋值1："<<pg_2d->c->getId()<<" , " <<pg_3d->fromI2OtherClient_t[pg_2d->c->getId()] <<" , "<<pg_3d->fromI2OtherClient_r[pg_2d->c->getId()] <<endl;
            }
            isFuse=pg_2d->fuseClientId[pg_3d->c->getId()];
//            cout<<isFuse<<endl;
            if(!isFuse){
//                是第一次融合
                pg_2d->fuseClientId[pg_3d->c->getId()]=true;
                Matrix3d r_w1_j;
                Vector3d t_w1_j;
                kf_3d->getOriginPose(t_w1_j, r_w1_j);
                pg_2d->fromI2OtherClient_r[pg_3d->c->getId()]=Rs_loop* r_w1_j.transpose();
                pg_2d->fromI2OtherClient_t[pg_3d->c->getId()]=-pg_2d->fromI2OtherClient_r[pg_3d->c->getId()]*t_w1_j+ Ps_loop;
//                cout<<"赋值2："<<pg_3d->c->getId()<<" , " <<pg_2d->fromI2OtherClient_t[pg_3d->c->getId()] <<" , "<<pg_2d->fromI2OtherClient_r[pg_3d->c->getId()] <<endl;
            }
//实验 end
            
            
        
        
//            这个是触发全局优化 之前是设置的其它地图，默认是和主地图优化
//            现在 设置成3d地图
//            加一个读写锁 只这里一次赋值 用来判断 是否和其它地图发生了融合 最终做什么样的优化
        pCurrentMap->readWriteLock_is_fusion_mutex.writeLock();
        pCurrentMap->is_fusion=1;
        pCurrentMap->readWriteLock_is_fusion_mutex.writeUnLock();
            
        pCurrentMap->isFirstFusion_globalMutex.lock();
       //找到了
        isFirstFusion[client_id_3d]-=1;
        //思考一下赋值 加锁
        int latest_index_cur_test=latest_globalLoop_index[client_id_3d];
        latest_index_cur_test=latest_index_cur_test>curKF_global_index?latest_index_cur_test:curKF_global_index;
        latest_globalLoop_index[client_id_3d]=latest_index_cur_test;
        if(earliest_globalLoop_index[client_id_3d]==-1 || earliest_globalLoop_index[client_id_3d]>curKF_global_index){
            earliest_globalLoop_index[client_id_3d]=curKF_global_index;
        }
        pCurrentMap->isFirstFusion_globalMutex.unlock();
            
        pg_2d->isFirstFusion_globalMutex.lock();
        //思考一下赋值 加锁
        int latest_index_other_test=latest_globalLoop_index[client_id_2d];
        latest_index_other_test=latest_index_other_test>otherKF_global_index?latest_index_other_test:otherKF_global_index;
        latest_globalLoop_index[client_id_2d]=latest_index_other_test;//目前唯一赋值的地方
        //记录主地图和其它地图最早的融合位置
        if(earliest_globalLoop_index[client_id_2d]==-1 || earliest_globalLoop_index[client_id_2d]>otherKF_global_index){
            earliest_globalLoop_index[client_id_2d]=otherKF_global_index;
        }
        pg_2d->isFirstFusion_globalMutex.unlock();
            
        kf_3d->update_globalLoopConnection(relative_t, rela_q, relative_yaw);
        kf_3d->global_relative_pitch=relative_pitch;
        kf_3d->global_relative_roll=relative_roll;
        kf_3d->detect_globalLoop(kf_2d->global_index);
        kf_2d->is_detected_globalLoop(kf_3d->global_index);
                
        if( ! uf.isConnected(client_id_3d, client_id_2d)){
            uf.connect(client_id_3d, client_id_2d);
        }
        
        pCurrentMap->start_global_fuse_opti_mutex.lock();
        pCurrentMap->start_global_fuse_opti=1;
        pCurrentMap->start_global_fuse_opti_mutex.unlock();

            
//            子地图实验 拿到和其它地图最相似的一帧，找对应的子地图进行融合-----------------------
//            global_featureMap->allocateSubMap_multi2(kf_3d, kf_2d);
            
//                    ------实验 记录能和哪些帧匹配 id header 是哪个地图的------
//        std::ofstream outFile;
//        outFile.setf(ios::fixed, ios::floatfield);  // 设定为 fixed 模式，以小数点表示浮点数
//        outFile.precision(16);  // 设置精度 2
//        //打开文件
//        outFile.open("/Users/zhangjianhua/Desktop/VINS_MapFusion/VINS_MapFusion/data/loop_old/"+ to_string(kf_3d->c->getId())+"&"+
//                     to_string(kf_3d->global_index)+"&"+to_string(kf_3d->header)+"&"+to_string(kf_2d->c->getId())+"&"+to_string(kf_2d->global_index)+"&"+to_string(kf_2d->header)+".txt");
//                //写入数据
//        outFile << kf_3d->c->getId()<<" "<<kf_3d->global_index<<" "<<kf_3d->header<<"\n" <<kf_2d->c->getId()<<" "<<kf_2d->global_index<<" "<<kf_2d->header;
//
//        outFile<<"\n";
//        //关闭文件
//        outFile.close();
//                    ------实验 子地图 记录能和哪些帧匹配 id header------
            
            std::ofstream outFile;
            outFile.setf(ios::fixed, ios::floatfield);  // 设定为 fixed 模式，以小数点表示浮点数
            outFile.precision(16);  // 设置精度
            outFile.open("/Users/zhangjianhua/Desktop/VINS_MapFusion/VINS_MapFusion/data/loop_subMap/"+ to_string(kf_3d->c->getId())+"&"+
                         to_string(kf_3d->global_index)+"&"+to_string(kf_2d->c->getId())+"&"+to_string(kf_2d->global_index)+".txt");
                    //写入数据
            outFile << kf_3d->c->getId()<<" "<<kf_3d->global_index<<" "<<kf_3d->header<<"\n" <<kf_2d->c->getId()<<" "<<kf_2d->global_index<<" "<<kf_2d->header;

            outFile<<"\n";
            //关闭文件
            outFile.close();
//                    ------实验 end 子地图 记录能和哪些帧匹配 id header------
    }
    else{
        cout<<"全局匹配帧数不够="<<similarNum<<endl;
        pCurrentMap->isFirstFusion_globalMutex.lock();

        isFirstFusion[client_id_3d]-=1;
        pCurrentMap->isFirstFusion_globalMutex.unlock();
    }
    
    TE(realMergeLocal_19_if);
}

//复制的18 尝试改进
void PoseGraphGlobal::realMergeLocal_20(KeyFrame* kf_3d, KeyFrame* kf_2d, PoseGraph* pg_3d, PoseGraph* pg_2d,int noMain){
    TS(realMergeLocal_19_if);
    int kf_3d_id=kf_3d->global_index;
    int kf_2d_id=kf_2d->global_index;
    int agent_2d_id=pg_2d->c->getId();
    cout<<kf_3d_id<<" , "<<kf_2d_id<<" , "<<agent_2d_id<<endl;
    //第二步-------------------------根据前面求得的粗糙的相对位姿求得准确的相对位姿--------重投影找匹配点---------------------------
    vector<vector<cv::Point2f>> measurements_old_norm_all;
    vector<vector<Eigen::Vector3d>> point_clouds_all;
    std::vector<cv::Point2f> measurements_old_coarse;//像素坐标
    std::vector<cv::Point2f> measurements_old_norm_coarse;//图像坐标
    std::vector<Vector3d> point_3d_cur;
    std::vector<cv::Point2f> measurements_cur;//像素坐标
    
    //这里就是假设所有的都是正的
    vector<KeyFrame*> vpCovKFi_old=kf_2d->GetBestCovisibilityKeyFrames(5);
    vpCovKFi_old.push_back(vpCovKFi_old[0]);
    vpCovKFi_old[0]=kf_2d;
    Matrix3d oldKF_r;
    Vector3d oldKF_t;
    kf_2d->getOriginPose(oldKF_t, oldKF_r);
        
    
        
    vector<Matrix3d> oldR_b_a;
    vector<Vector3d> oldT_b_a;
    int temp_index=0;
    //先算出来 在当前帧误差下，世界坐标系 到 侯选帧的共视帧的位姿关系
    for(KeyFrame* pkFi_old: vpCovKFi_old){
        if(temp_index!=0){
            Matrix3d rwi_old;
            Vector3d twi_old;
            pkFi_old->getOriginPose(twi_old, rwi_old);
            
            Matrix3d r_b_a;
            Vector3d t_b_a;
            r_b_a=oldKF_r.transpose()* rwi_old;
            t_b_a=oldKF_r.transpose()*(twi_old-oldKF_t);
            oldR_b_a.push_back(r_b_a);
            oldT_b_a.push_back(t_b_a);
        }else{
            oldR_b_a.push_back(Matrix3d::Identity());
            oldT_b_a.push_back(Vector3d::Zero());
            temp_index++;//放这里就只要执行一次
        }
    }
    
    int similarNum=0;
    temp_index=0;
    vector<Matrix3d> old_r;
    vector<Vector3d> old_t;
    vector<int> vpkf_index;
    
    
    Matrix3d R_relative;
    Vector3d T_relative;
   
    vector<int> clientId=kf_3d->clientId;
    vector<int> kfId=kf_3d->kfId;
    vector<std::pair<Matrix3d , Vector3d >  > relativePose=kf_3d->relativePose;
    int client_matchId=kf_2d->c->id, kf2d_global_index=kf_2d->global_index;//这里表示主地图的意思，后面肯定要改
    for(int i=0, len=clientId.size();i<len;i++){
        if(clientId[i]==client_matchId && kfId[i]==kf2d_global_index){
            R_relative=relativePose[i].first;
            T_relative=relativePose[i].second;
        }
    }
   
    
    Client* client_cur=kf_2d->c;
    Matrix3d ric_curClient=client_cur->ric_client;
    Vector3d tic_curClient=client_cur->tic_client;
    Vector3d euler_angle_ric_main=Utility::R2ypr(ric_curClient);
    const float &fx = client_cur->FOCUS_LENGTH_X_server;
    const float &fy = client_cur->FOCUS_LENGTH_Y_server;
    const float &cx = client_cur->PX_server;
    const float &cy = client_cur->PY_server;
    
    
        
    for(KeyFrame* pkf_old:vpCovKFi_old){
        Matrix3d r_w_imuOld=R_relative*oldR_b_a[temp_index];
        Vector3d t_w_imuOld=R_relative*oldT_b_a[temp_index] +T_relative;
        Matrix3d r_w_camOld=r_w_imuOld*ric_curClient;
        Vector3d t_w_camOld=r_w_imuOld*tic_curClient+t_w_imuOld;
        Matrix3d r_camOld_w=r_w_camOld.transpose();
        old_r.push_back(r_camOld_w);
        old_t.push_back(-r_camOld_w*t_w_camOld);
        temp_index++;
        
    }
    
    while(!kf_3d->IsOriginUpdate){
        usleep(50);
    }
    std::vector<KeyFrame*> vpCovKFi_cur = kf_3d->GetBestCovisibilityKeyFrames(5);
    vpCovKFi_cur.push_back(vpCovKFi_cur[0]);
    vpCovKFi_cur[0] = kf_3d;
    
    
    {
        //当前帧的共视帧 与 侯选帧的2级共视帧的匹配，通过重投影找
        
        point_clouds_all.clear();
        measurements_old_norm_all.clear();
        vpkf_index.clear();
        for(KeyFrame* pKFi : vpCovKFi_cur){

            //描述符得全有
            if(!pKFi->is_des_end){
                continue;
            }
            
            vector<Eigen::Vector3d> point_clouds_origin_cur= pKFi->point_clouds_origin;
            std::vector<cv::Point2f> measurements_origin_cur=pKFi->measurements_origin;
            vector<cv::KeyPoint> keypoints_cur=pKFi->keypoints;
            int nPoints = point_clouds_origin_cur.size();
            int point2D_len_cur=keypoints_cur.size()-point_clouds_origin_cur.size();
           
//                int num=0;//记录匹配点的数量
            temp_index=0;//记录遍历到哪个帧了
            //这里应该遍历候选帧的共视帧 ，只要共视点数量超过一定阈值 22
            for(KeyFrame* pkFi_old: vpCovKFi_old)
            {
                

                //描述符得全有
                if(!pkFi_old->is_des_end){
                    temp_index++;
                    continue;
                }
                
                measurements_old_coarse.clear();
                measurements_old_norm_coarse.clear();
                point_3d_cur.clear();
                measurements_cur.clear();
            
                vector<cv::KeyPoint> keypoints_old=pkFi_old->keypoints;

                //这个得到的是到imu坐标系的位姿
                Matrix3d r_camOld_w=old_r[temp_index];
                Vector3d t_camOld_w=old_t[temp_index];
                
                for(int i=0;i<nPoints;i++){
                    Vector3d point_main=point_clouds_origin_cur[i];
                    //把主地图下 世界坐标系的点 转到小地图上一帧的图像坐标系上
                    Vector3d p3D_c2=r_camOld_w*point_main+t_camOld_w;
                    //深度必须为正
                    if(p3D_c2[2]<0.0 || p3D_c2[2]>30.0){
//                            cout<<"深度不为正"<<endl;
                        continue;
                    }
                    // 投影到图像上
                    double x = p3D_c2[0];
                    double y = p3D_c2[1];
                    double z = p3D_c2[2];
                    //这里可能得加一个畸变校正 应该可以不用去校正 把他投影在一个没有畸变的图像上
                    double u=fx*x/z+cx;
                    double v=fy*y/z+cy;
                  
                    
                    if(!pkFi_old->isInImage((float)u, (float)v)){
//                            cout<<"投影点不在图像内"<<endl;
                        continue;
                    }
                    
                    const vector<int> vIndices=pkFi_old->GetFeaturesInArea_1((float)u, (float)v, 20);
                    //这里可以改为30个像素里面找不到 再扩大到50个像素 暂时未做
                    if(vIndices.empty()){
//                            cout<<"半径为20个像素 找不到点"<<endl;
                        continue;
                    }
                    //des和keypoints长度不一样
                    //找在这个半径内最相似的 这里可能有些问题 因为3D点的描述子 个人感觉有问题
                    BRIEF::bitset point_main_des=pKFi->descriptors[point2D_len_cur+i];
                    int bestDist = 256;
                    int bestIndex = -1;
                    for(vector<int>::const_iterator vit=vIndices.begin(), vit_end=vIndices.end(); vit!=vit_end; vit++)
                    {
    //                    cout<<"*vit"<<*vit<<endl;发现 keypoints数量不等于des数量
                        int dis = pkFi_old->HammingDis(point_main_des, pkFi_old->descriptors[*vit]);
                        if(dis < bestDist)
                        {
                            bestDist = dis;
                            bestIndex = *vit;
                        }
                    }
                    
                    if(bestDist<70){
//                                cout<<"最终选择的半径范围："<<u-keypoints_old[bestIndex].pt.x<<" ,"<<v-keypoints_old[bestIndex].pt.y<<endl;
                        point_3d_cur.push_back(point_main);
                        measurements_old_coarse.push_back(keypoints_old[bestIndex].pt);
                        measurements_cur.push_back(measurements_origin_cur[i]);
                        
                    }
                                
                }
                
//                        cout<<"50个像素内,找到的点数："<<measurements_cur.size()<<endl;
                if(measurements_cur.size()>=22){
                    pKFi->rejectWithF_server_mapFuse(measurements_cur, measurements_old_coarse,point_3d_cur);
//                            cout<<"f矩阵拒绝后的点数："<<measurements_cur.size()<<", "<<pKFi->global_index<<" ,"<<pkFi_old->global_index<<endl;
                    if(measurements_old_coarse.size()>16){
                    
                        cv::Point2f norm_pt;
                        int pCount=measurements_old_coarse.size();
                        for(int aa=0;aa<pCount;aa++){
                            norm_pt.x = (measurements_old_coarse[aa].x -  client_cur->PX_server)/ client_cur->FOCUS_LENGTH_X_server;
                            norm_pt.y = (measurements_old_coarse[aa].y -  client_cur->PY_server)/ client_cur->FOCUS_LENGTH_Y_server;
                            measurements_old_coarse[aa]=norm_pt;
                            
                        }
                        
                        point_clouds_all.push_back(point_3d_cur);
                        measurements_old_norm_all.push_back(measurements_old_coarse);

                        vpkf_index.push_back(temp_index);
                        similarNum++;
                        

                    }
                    
                }
                
                temp_index++;
            }
        }
    }

    PoseGraph* pCurrentMap;
    int client_id_3d,client_id_2d,otherKF_global_index,curKF_global_index;
//    if(noMain==1){
        pCurrentMap=pg_3d;
        client_id_3d=kf_3d->c->id;
        client_id_2d=kf_2d->c->id;
        otherKF_global_index=kf_2d->global_index;
        curKF_global_index=kf_3d->global_index;
//    }
//    else{
//        pCurrentMap=pg_2d;
//        client_id_3d=kf_2d->c->id;
//        client_id_2d=kf_2d->c->id;
//        mainKF_global_index=kf_3d->global_index;
//        curKF_global_index=kf_2d->global_index;
//    }
    
        if(similarNum>=2){
            int optiKf_num=vpkf_index.size()+2;
            //构造优化问题
            double t_array[optiKf_num][3];//平移数组，其中存放每个关键帧的平移向量
            Quaterniond q_array[optiKf_num];
            double euler_array[optiKf_num][3];

            ceres::Problem problem;
            ceres::Solver::Options options;
            //options.linear_solver_type = ceres::DENSE_NORMAL_CHOLESKY;
            options.linear_solver_type = ceres::DENSE_SCHUR;
//            options.trust_region_strategy_type = ceres::DOGLEG;
            //options.minimizer_progress_to_stdout = true;
            options.max_num_iterations = 20;
            ceres::Solver::Summary summary;
            ceres::LossFunction *loss_function;
            loss_function = new ceres::HuberLoss(1.0);
            //AngleLocalParameterization类的主要作用是指定yaw角优化变量的迭代更新，重载了括号运算
            ceres::LocalParameterization* angle_local_parameterization = AngleLocalParameterization::Create();

            
            std::vector<ceres::ResidualBlockId> residual_block_ids;
            ceres::ResidualBlockId              block_id;
            
            Matrix3d curKF_r;
            Vector3d curKF_t;
            kf_3d->getOriginPose(curKF_t, curKF_r);
            
            
            Matrix3d tmp_r_old;
            Vector3d tmp_t_old;
            t_array[0][0] = curKF_t(0);
            t_array[0][1] = curKF_t(1);
            t_array[0][2] = curKF_t(2);
            //将矩阵转换为向量
            Vector3d euler_angle_old = Utility::R2ypr(curKF_r);
            euler_array[0][0] = euler_angle_old.x();
            euler_array[0][1] = euler_angle_old.y();
            euler_array[0][2] = euler_angle_old.z();
            problem.AddParameterBlock(euler_array[0], 3);
            problem.AddParameterBlock(t_array[0], 3);

            
            //再加一个根据当前帧与侯选帧之间的匹配关系，构造最开始的那个3d点 到候选帧的误差
            map<int,int> resample;
            
            temp_index=0;
            for(int len=vpkf_index.size(); temp_index<len; temp_index++ ){
                
                int kf_index=temp_index+1;
                Matrix3d relative_r_b_a;
                Vector3d relative_t_b_a;
                relative_r_b_a=oldR_b_a[vpkf_index[temp_index]];
                relative_t_b_a=oldT_b_a[vpkf_index[temp_index]];
                Vector3d relative_r_b_a_euler=Utility::R2ypr(relative_r_b_a);
                
                
                map<int,int>::iterator iter;
                iter = resample.find(vpkf_index[temp_index]);
                if(iter != resample.end())
                {
                    kf_index=resample[vpkf_index[temp_index]];
                }
                else
                {
                    resample[vpkf_index[temp_index]]=kf_index;

                    t_array[kf_index][0] = relative_t_b_a(0);
                    t_array[kf_index][1] = relative_t_b_a(1);
                    t_array[kf_index][2] = relative_t_b_a(2);
                    euler_array[kf_index][0] = relative_r_b_a_euler.x();
                    euler_array[kf_index][1] = relative_r_b_a_euler.y();
                    euler_array[kf_index][2] = relative_r_b_a_euler.z();
                    problem.AddParameterBlock(euler_array[kf_index], 1, angle_local_parameterization);
                    problem.AddParameterBlock(t_array[kf_index], 3);
                    
                    
                    problem.SetParameterBlockConstant(euler_array[kf_index]);
                    problem.SetParameterBlockConstant(t_array[kf_index]);
                   
//                    ceres::CostFunction* cost_function = FourSixDOFError::Create( relative_t_b_a(0),relative_t_b_a(1),relative_t_b_a(2),relative_r_b_a_euler(0),1.0);
//                    problem.AddResidualBlock(cost_function, loss_function, euler_array[kf_index],t_array[kf_index]);
                    
                }
              

                vector<Vector3d> point_single=point_clouds_all[temp_index];
                vector<cv::Point2f> measure_single=measurements_old_norm_all[temp_index];
                for(int a=0,b=point_single.size();a<b;a++){

                    //找到主地图那个点 所在帧的位姿
                    Vector3d pts_i = point_single[a];

                    //相机平面坐标
                    cv::Point2f pt=measure_single[a];

                    ceres::CostFunction* cost_function = FourSixDOFWeightError_reprojection_3::Create( pts_i.x(), pts_i.y(), pts_i.z(),pt.x, pt.y, tic_curClient[0], tic_curClient[1], tic_curClient[2], euler_angle_ric_main.x(), euler_angle_ric_main.y(), euler_angle_ric_main.z() ,relative_r_b_a_euler(1),relative_r_b_a_euler(2),100.0);
                    block_id =  problem.AddResidualBlock(cost_function, loss_function, euler_array[0],t_array[0], euler_array[kf_index],t_array[kf_index]);
                    residual_block_ids.push_back( block_id );
                    
                 }
            }
            std::vector< ceres::ResidualBlockId > residual_block_ids_temp;
            residual_block_ids_temp.reserve( residual_block_ids.size() );
            
            
//            vector<double> hh;
            for ( size_t ii = 0; ii < 1; ii++ )
            {
                options.max_num_iterations = 2;
//                    options.minimizer_progress_to_stdout = false;
//                    options.check_gradients = false;
//                    options.gradient_check_relative_precision = 1e-10;
                //options.function_tolerance = 1e-100; // default 1e-6


//                    set_ceres_solver_bound( problem, t_array );
                ceres::Solve( options, &problem, &summary );
//                    std::cout <<"算一个粗糙的相对位姿1："<< summary.BriefReport() << "\n";

                residual_block_ids_temp.clear();
                ceres::Problem::EvaluateOptions eval_options;
                eval_options.residual_blocks = residual_block_ids;
                double              total_cost = 0.0;
                std::vector<double> residuals;
                problem.Evaluate( eval_options, &total_cost, &residuals, nullptr, nullptr );

                double m_inliner_ratio_threshold = compute_inlier_residual_threshold( residuals, 0.80  );
                double m_inlier_threshold = std::max( 2.0, m_inliner_ratio_threshold );
//                    cout<<"m_inlier_threshold="<<m_inlier_threshold<<endl;
//                    cout << "Inlier threshold is: " << m_inlier_final_threshold << endl;
                for ( unsigned int i = 0; i < residual_block_ids.size(); i++ )
                {
//                    hh.push_back(fabs( residuals[ 2 * i + 0 ] ) + fabs( residuals[ 2 * i + 1 ] ));
//                        cout<<"测试误差："<<fabs( residuals[ 2 * i + 0 ] ) + fabs( residuals[ 2 * i + 1 ] )<<endl;
                    if ( ( fabs( residuals[ 2 * i + 0 ] ) + fabs( residuals[ 2 * i + 1 ] ) ) > m_inlier_threshold ) // std::min( 1.0, 10 * avr_cost )
                    {
                        //screen_out << "Remove outliers, drop id = " << (void *)residual_block_ids[ i ] <<endl;
                        problem.RemoveResidualBlock( residual_block_ids[ i ] );
//                        point_all.push_back(i);
                    }
                    else
                    {
                        residual_block_ids_temp.push_back( residual_block_ids[ i ] );
                    }
                }
                residual_block_ids = residual_block_ids_temp;
            }
            
            
//            ceres::Solve(options, &problem, &summary);
//            std::cout <<"全局-精确相对位姿："<<kf_3d->c->id<<" , "<< summary.BriefReport() << "\n";

            options.linear_solver_type = ceres::DENSE_SCHUR;//DENSE_QR DENSE_SCHUR
            options.max_num_iterations = 20;
            ceres::Solve( options, &problem, &summary );
            
            if(summary.termination_type!=ceres::CONVERGENCE){
                pCurrentMap->isFirstFusion_globalMutex.lock();
                isFirstFusion[client_id_3d]-=1;
                pCurrentMap->isFirstFusion_globalMutex.unlock();
                return;}
            
            
            
            Matrix3d Rs_i ;
            Vector3d Ps_i ;//当前帧
            kf_3d->getOriginPose(Ps_i, Rs_i);
            



            Vector3d q;
            q<<euler_array[0][0],euler_array[0][1],euler_array[0][2];
            Matrix3d Rs_loop = Utility::ypr2R(q);
            Vector3d Ps_loop = Vector3d( t_array[0][0],  t_array[0][1],  t_array[0][2]);

//求得的是3d到2d的关系
            Vector3d relative_t = Rs_loop.transpose() * (Ps_i - Ps_loop);
//                Matrix3d relative_q = Rs_loop.transpose() * Rs_i;
            double relative_yaw = Utility::normalizeAngle(Utility::R2ypr(Rs_i).x() - Utility::R2ypr(Rs_loop).x());
            double relative_pitch = Utility::normalizeAngle(Utility::R2ypr(Rs_i).y() - Utility::R2ypr(Rs_loop).y());
            double relative_roll = Utility::normalizeAngle(Utility::R2ypr(Rs_i).z() - Utility::R2ypr(Rs_loop).z());
//            Quaterniond rela_q=Quaterniond(relative_q);
            
            Quaterniond rs_loop_q=Quaterniond(Rs_loop),rs_i_q=Quaterniond(Rs_i);
            Quaterniond rela_q=rs_loop_q.inverse()*rs_i_q;
//测试
//            Quaterniond tmp_q,tmp_i;
//            tmp_q=Rs_loop;
//            tmp_i=Rs_i;
//            double w_q_i[4],i_q_w[4],t_w_ij[3],t_i_ij[3];
//            w_q_i[0]=tmp_q.w();
//            w_q_i[1]=tmp_q.x();
//            w_q_i[2]=tmp_q.y();
//            w_q_i[3]=tmp_q.z();
//            QuaternionInverse(w_q_i, i_q_w);
//            t_w_ij[0]=Ps_i[0] - Ps_loop[0];
//            t_w_ij[1]=Ps_i[1] - Ps_loop[1];
//            t_w_ij[2]=Ps_i[2] - Ps_loop[2];
//            ceres::QuaternionRotatePoint(i_q_w, t_w_ij, t_i_ij);
////            cout<<"relative_t"<<relative_t.x()<<" , "<<relative_t.y()<<" , "<<relative_t.z()<<endl;
////            cout<<"t_i_ij="<<t_i_ij[0]<<" , "<<t_i_ij[1]<<" , "<<t_i_ij[2]<<endl;
//
//            double w_q_j[4],q_i_j[4];
//            w_q_j[0]=tmp_i.w();
//            w_q_j[1]=tmp_i.x();
//            w_q_j[2]=tmp_i.y();
//            w_q_j[3]=tmp_i.z();
//            ceres::QuaternionProduct(i_q_w, w_q_j, q_i_j);
////            cout<<"rela_q"<<rela_q.w()<<" , "<<rela_q.x()<<" , "<<rela_q.y()<<" , "<<rela_q.z()<<endl;
////            cout<<"q_i_j"<<q_i_j[0]<<" , "<<q_i_j[1]<<" , "<<q_i_j[2]<<" , "<<q_i_j[3]<<endl;
//
//            if(fabs(rela_q.x()-q_i_j[1])>0.000001 || fabs(rela_q.y()-q_i_j[2])>0.000001 ||fabs(rela_q.z()-q_i_j[3])>0.000001 ){
////                cout<<"rela_q"<<rela_q.w()<<" , "<<rela_q.x()<<" , "<<rela_q.y()<<" , "<<rela_q.z()<<endl;
////                cout<<"q_i_j"<<q_i_j[0]<<" , "<<q_i_j[1]<<" , "<<q_i_j[2]<<" , "<<q_i_j[3]<<endl;
//                cout<<"数据不规范"<<endl;
//                pCurrentMap->isFirstFusion_globalMutex.lock();
//
//                isFirstFusion[client_id_3d]-=1;
//                pCurrentMap->isFirstFusion_globalMutex.unlock();
//                return;
//            }
            //实验记录
//            std::ofstream outFile;
//            //打开文件
//            outFile.open("/Users/zhangjianhua/Desktop/hh/VINS_MapFusion/VINS_MapFusion/data/"+
//                             to_string(kf_3d->global_index)+"&"+to_string(kf_3d->header)+"&"+to_string(kf_2d->global_index)+"&"+to_string(kf_2d->header)+".txt");
//            outFile.setf(ios::fixed, ios::floatfield);  // 设定为 fixed 模式，以小数点表示浮点数
//            outFile.precision(19);
//                //写入数据
////                outFile <<"测试是否存在误匹配，当前client.id:\n"<<kf_3d->c->id<<"\n当作帧的header:\n"<<kf_3d->header<<"\n当作帧的global_index:\n"<<kf_3d->global_index<<"\n2d帧的client.id:\n"<<kf_2d->c->id <<"\n2d帧的header:\n"<<kf_2d->header<<"\n2d帧的global_index:\n"<<kf_2d->global_index  <<"\n3d-2d的r:\n"<<rela_q<<"\n3d-2d的t\n"<<relative_t;
//            outFile <<kf_3d->c->id<<"\n"<<kf_3d->header<<"\n"<<kf_3d->global_index<<"\n"<<kf_2d->c->id <<"\n"<<kf_2d->header<<"\n"<<kf_2d->global_index  <<"\n"<<rela_q.x()<<"\n"<<rela_q.y()<<"\n"<<rela_q.z()<<"\n"<<rela_q.w()<<"\n"<<relative_t[0]<<"\n"<<relative_t[1]<<"\n"<<relative_t[2];
//                //关闭文件
//            outFile.close();
            Eigen::Matrix<double, 8, 1> connected_info;
            connected_info <<relative_t.x(), relative_t.y(), relative_t.z(),
            rela_q.w(), rela_q.x(), rela_q.y(), rela_q.z(),
            relative_yaw;
//            for(int i=0, len=clientId.size();i<len;i++){
//                if(clientId[i]==client_matchId && kfId[i]==kf2d_global_index){
                    kf_3d->relative_global_loop_info_multiClient.push_back(connected_info);
//                }
//            }
            
//            实验 开始
//            cout<<"回环："<<pg_2d->c->getId()<<" ,"<<pg_3d->c->getId()<<endl;
            bool isFuse=pg_3d->fuseClientId[pg_2d->c->getId()];
//            cout<<"isFuse= "<<isFuse<<" , "<<pg_2d->c->getId()<<endl;
            if(!isFuse){
                cout<<"回环："<<pg_2d->c->getId()<<" , "<<pg_3d->c->getId()<<endl;
                cout<<"回环kfid："<<kf_2d->global_index<<" , "<<kf_3d->global_index<<endl;
//                是第一次融合
                pg_3d->fuseClientId[pg_2d->c->getId()]=true;
                Matrix3d r_w2_j;
                Vector3d t_w2_j;
                kf_2d->getOriginPose(t_w2_j, r_w2_j);
                pg_3d->fromI2OtherClient_r[pg_2d->c->getId()]=r_w2_j*Rs_loop.transpose();
                pg_3d->fromI2OtherClient_t[pg_2d->c->getId()]=-pg_3d->fromI2OtherClient_r[pg_2d->c->getId()]*Ps_loop+t_w2_j;
                
//                cout<<"赋值1："<<pg_2d->c->getId()<<" , " <<pg_3d->fromI2OtherClient_t[pg_2d->c->getId()] <<" , "<<pg_3d->fromI2OtherClient_r[pg_2d->c->getId()] <<endl;
            }
            isFuse=pg_2d->fuseClientId[pg_3d->c->getId()];
//            cout<<isFuse<<endl;
            if(!isFuse){
//                是第一次融合
                pg_2d->fuseClientId[pg_3d->c->getId()]=true;
                Matrix3d r_w1_j;
                Vector3d t_w1_j;
                kf_3d->getOriginPose(t_w1_j, r_w1_j);
                pg_2d->fromI2OtherClient_r[pg_3d->c->getId()]=Rs_loop* r_w1_j.transpose();
                pg_2d->fromI2OtherClient_t[pg_3d->c->getId()]=-pg_2d->fromI2OtherClient_r[pg_3d->c->getId()]*t_w1_j+ Ps_loop;
//                cout<<"赋值2："<<pg_3d->c->getId()<<" , " <<pg_2d->fromI2OtherClient_t[pg_3d->c->getId()] <<" , "<<pg_2d->fromI2OtherClient_r[pg_3d->c->getId()] <<endl;
            }
//实验 end
            
            
        
        
//            这个是触发全局优化 之前是设置的其它地图，默认是和主地图优化
//            现在 设置成3d地图
//            加一个读写锁 只这里一次赋值 用来判断 是否和其它地图发生了融合 最终做什么样的优化
        pCurrentMap->readWriteLock_is_fusion_mutex.writeLock();
        pCurrentMap->is_fusion=1;
        pCurrentMap->readWriteLock_is_fusion_mutex.writeUnLock();
            
        pCurrentMap->isFirstFusion_globalMutex.lock();
       //找到了
        isFirstFusion[client_id_3d]-=1;
        //思考一下赋值 加锁
        int latest_index_cur_test=latest_globalLoop_index[client_id_3d];
        latest_index_cur_test=latest_index_cur_test>curKF_global_index?latest_index_cur_test:curKF_global_index;
        latest_globalLoop_index[client_id_3d]=latest_index_cur_test;
        if(earliest_globalLoop_index[client_id_3d]==-1 || earliest_globalLoop_index[client_id_3d]>curKF_global_index){
            earliest_globalLoop_index[client_id_3d]=curKF_global_index;
        }
        pCurrentMap->isFirstFusion_globalMutex.unlock();
            
        pg_2d->isFirstFusion_globalMutex.lock();
        //思考一下赋值 加锁
        int latest_index_other_test=latest_globalLoop_index[client_id_2d];
        latest_index_other_test=latest_index_other_test>otherKF_global_index?latest_index_other_test:otherKF_global_index;
        latest_globalLoop_index[client_id_2d]=latest_index_other_test;//目前唯一赋值的地方
        //记录主地图和其它地图最早的融合位置
        if(earliest_globalLoop_index[client_id_2d]==-1 || earliest_globalLoop_index[client_id_2d]>otherKF_global_index){
            earliest_globalLoop_index[client_id_2d]=otherKF_global_index;
        }
        pg_2d->isFirstFusion_globalMutex.unlock();
            
        kf_3d->update_globalLoopConnection(relative_t, rela_q, relative_yaw);
        kf_3d->global_relative_pitch=relative_pitch;
        kf_3d->global_relative_roll=relative_roll;
        kf_3d->detect_globalLoop(kf_2d->global_index);
        kf_2d->is_detected_globalLoop(kf_3d->global_index);
                
        if( ! uf.isConnected(client_id_3d, client_id_2d)){
            uf.connect(client_id_3d, client_id_2d);
        }
        
        pCurrentMap->start_global_fuse_opti_mutex.lock();
        pCurrentMap->start_global_fuse_opti=1;
        pCurrentMap->start_global_fuse_opti_mutex.unlock();

            
//            子地图实验 拿到和其它地图最相似的一帧，找对应的子地图进行融合-----------------------
//            global_featureMap->allocateSubMap_multi2(kf_3d, kf_2d);
            
//                    ------实验 记录能和哪些帧匹配 id header 是哪个地图的------
//        std::ofstream outFile;
//        outFile.setf(ios::fixed, ios::floatfield);  // 设定为 fixed 模式，以小数点表示浮点数
//        outFile.precision(16);  // 设置精度 2
//        //打开文件
//        outFile.open("/Users/zhangjianhua/Desktop/VINS_MapFusion/VINS_MapFusion/data/loop_old/"+ to_string(kf_3d->c->getId())+"&"+
//                     to_string(kf_3d->global_index)+"&"+to_string(kf_3d->header)+"&"+to_string(kf_2d->c->getId())+"&"+to_string(kf_2d->global_index)+"&"+to_string(kf_2d->header)+".txt");
//                //写入数据
//        outFile << kf_3d->c->getId()<<" "<<kf_3d->global_index<<" "<<kf_3d->header<<"\n" <<kf_2d->c->getId()<<" "<<kf_2d->global_index<<" "<<kf_2d->header;
//
//        outFile<<"\n";
//        //关闭文件
//        outFile.close();
//                    ------实验 子地图 记录能和哪些帧匹配 id header------
            
            std::ofstream outFile;
            outFile.setf(ios::fixed, ios::floatfield);  // 设定为 fixed 模式，以小数点表示浮点数
            outFile.precision(16);  // 设置精度
            outFile.open("/Users/zhangjianhua/Desktop/VINS_MapFusion/VINS_MapFusion/data/loop_subMap/"+ to_string(kf_3d->c->getId())+"&"+
                         to_string(kf_3d->global_index)+"&"+to_string(kf_2d->c->getId())+"&"+to_string(kf_2d->global_index)+".txt");
                    //写入数据
            outFile << kf_3d->c->getId()<<" "<<kf_3d->global_index<<" "<<kf_3d->header<<"\n" <<kf_2d->c->getId()<<" "<<kf_2d->global_index<<" "<<kf_2d->header;

            outFile<<"\n";
            //关闭文件
            outFile.close();
//                    ------实验 end 子地图 记录能和哪些帧匹配 id header------
    }
    else{
        cout<<"全局匹配帧数不够="<<similarNum<<endl;
        pCurrentMap->isFirstFusion_globalMutex.lock();

        isFirstFusion[client_id_3d]-=1;
        pCurrentMap->isFirstFusion_globalMutex.unlock();
    }
    
    TE(realMergeLocal_19_if);
}


//耗时 所以合并相隔很近的回环帧 合并局部窗口 更耗时了（找之前的耗时，点多了 ceres优化耗时 这个是大头）
void PoseGraphGlobal::realMergeLocal_19(KeyFrame* kf_3d, KeyFrame* kf_2d, PoseGraph* pg_3d, PoseGraph* pg_2d,int noMain){
    TS(realMergeLocal_19_if);
    int kf_3d_id=kf_3d->global_index;
    int kf_2d_id=kf_2d->global_index;
    int agent_2d_id=pg_2d->c->getId();
//    判断附件5帧内 是否发生过回环
    int diff_threshold=5;

    cout<<kf_3d_id<<" , "<<kf_2d_id<<" , "<<agent_2d_id<<endl;
    
    pg_3d->globalLoop_mutex.lock();
    vector<int> curGlobalLoopKf_id_3d=pg_3d->curGlobalLoopKf_id;
    vector<int> oldGlobalLoopKf_id_2d=pg_3d->oldGlobalLoopKf_id;
    vector<int> oldAgent_id_forLoopKf=pg_3d->oldAgent_id_forLoopKf;
    vector<vector<int> > vpkf_index_save=pg_3d->vpkf_index;
//    vector<vector<Matrix3d> > oldR_b_a_save=pg_3d->oldR_b_a;
//    vector<vector<Vector3d> > oldT_b_a_save=pg_3d->oldT_b_a;
    vector<vector<vector<cv::Point2f>>> measurements_old_norm_all_save=pg_3d->measurements_old_norm_all;
    vector<vector<vector<Eigen::Vector3d>>> point_clouds_all_save=pg_3d->point_clouds_all;
    vector< vector<KeyFrame*> > vpCovKFi_cur_3d_save=pg_3d->vpCovKFi_cur_3d;
    vector< vector<KeyFrame*> > vpCovKFi_old_2d_save=pg_3d->vpCovKFi_old_2d;
    pg_3d->globalLoop_mutex.unlock();
    cout<<"过往回环数量："<<curGlobalLoopKf_id_3d.size()<<endl;
    
    
    int real_len_oldLoop=0;
    for(int i=0,j=curGlobalLoopKf_id_3d.size();i<j;i++){
//        cout<<"save:"<<curGlobalLoopKf_id_3d[i]<<" , "<<oldGlobalLoopKf_id_2d[i]<<" , "<<oldAgent_id_forLoopKf[i]<<endl;
        if(agent_2d_id==oldAgent_id_forLoopKf[i]){
            
            int cur_diff=kf_3d_id-curGlobalLoopKf_id_3d[i];
            int old_diff=kf_2d_id-oldGlobalLoopKf_id_2d[i];
//            cout<<cur_diff<<" , "<<old_diff<<endl;
            if(cur_diff<=diff_threshold && old_diff<=diff_threshold){
                
                int delte_num=i-real_len_oldLoop;
                if(delte_num!=0){
                    curGlobalLoopKf_id_3d[real_len_oldLoop]=curGlobalLoopKf_id_3d[i];
                    oldGlobalLoopKf_id_2d[real_len_oldLoop]=oldGlobalLoopKf_id_2d[i];
                    oldAgent_id_forLoopKf[real_len_oldLoop]=oldAgent_id_forLoopKf[i];
                    
                    vpkf_index_save[real_len_oldLoop]=vpkf_index_save[i];
                    measurements_old_norm_all_save[real_len_oldLoop]=measurements_old_norm_all_save[i];
                    point_clouds_all_save[real_len_oldLoop]=point_clouds_all_save[i];
//                    oldR_b_a_save[real_len_oldLoop]=oldR_b_a_save[i];
//                    oldT_b_a_save[real_len_oldLoop]=oldT_b_a_save[i];
                    
                    vpCovKFi_cur_3d_save[real_len_oldLoop]=vpCovKFi_cur_3d_save[i];
                    vpCovKFi_old_2d_save[real_len_oldLoop]=vpCovKFi_old_2d_save[i];
                }
                real_len_oldLoop++;
            }
            
        }
    }
    {
        curGlobalLoopKf_id_3d.resize(real_len_oldLoop);
        oldGlobalLoopKf_id_2d.resize(real_len_oldLoop);
        oldAgent_id_forLoopKf.resize(real_len_oldLoop);
        
        vpkf_index_save.resize(real_len_oldLoop);
        measurements_old_norm_all_save.resize(real_len_oldLoop);
        point_clouds_all_save.resize(real_len_oldLoop);
//        oldR_b_a_save.resize(real_len_oldLoop);
//        oldT_b_a_save.resize(real_len_oldLoop);
       
        vpCovKFi_cur_3d_save.resize(real_len_oldLoop);
        vpCovKFi_old_2d_save.resize(real_len_oldLoop);
    }
    
  
    
    if(real_len_oldLoop>0){
//        利用先前找到的回环 把已知的匹配关系都罗列出来 然后遍历共视帧找当前的匹配关系
        cout<<"利用之前的数据了"<<endl;
        TS(testtesttest);
        //第二步-------------------------根据前面求得的粗糙的相对位姿求得准确的相对位姿--------重投影找匹配点---------------------------
        vector<vector<cv::Point2f>> measurements_old_norm_all;
        vector<vector<Eigen::Vector3d>> point_clouds_all;
        std::vector<cv::Point2f> measurements_old_coarse;//像素坐标
        std::vector<cv::Point2f> measurements_old_norm_coarse;//图像坐标
        std::vector<Vector3d> point_3d_cur;
        std::vector<cv::Point2f> measurements_cur;//像素坐标
        
        vector<vector<cv::Point2f>> measurements_old_norm_all_save;
        vector<vector<Eigen::Vector3d>> point_clouds_all_save;
        
        //这里就是假设所有的都是正的
        vector<KeyFrame*> vpCovKFi_old=kf_2d->GetBestCovisibilityKeyFrames(5);
        vpCovKFi_old.push_back(vpCovKFi_old[0]);
        vpCovKFi_old[0]=kf_2d;
        bool old_isSave=true;
//        去掉已经找到匹配关系的共视帧
        int real_len_covKFi_old=0;
        for(int a=0,b=vpCovKFi_old.size();a<b;a++){
            bool isFind=false;
            for(int i=0,j=vpCovKFi_old_2d_save.size();i<j;i++){
                
                for(auto iter_save=vpCovKFi_old_2d_save[i].begin(),iter_save_end=vpCovKFi_old_2d_save[i].end();iter_save!=iter_save_end;iter_save++){
                    if((vpCovKFi_old[a])==(*iter_save)){
                        isFind=true;
                        break;
                    }
                }
                if(isFind){
                    break;
                }
            }
            if(isFind==false){
                if(real_len_covKFi_old!=a){
                    vpCovKFi_old[real_len_covKFi_old]=vpCovKFi_old[a];
                }
                real_len_covKFi_old++;
                if(a==0){
                    old_isSave=false;
                }
            }
        }
        vpCovKFi_old.resize(real_len_covKFi_old);
//            计算老帧之间的相对位姿
        Matrix3d oldKF_r;
        Vector3d oldKF_t;
        kf_2d->getOriginPose(oldKF_t, oldKF_r);
        vector<Matrix3d> oldR_b_a;
        vector<Vector3d> oldT_b_a;
        int temp_index=0;
        //先算出来 在当前帧误差下，世界坐标系 到 侯选帧的共视帧的位姿关系
        for(KeyFrame* pkFi_old: vpCovKFi_old){
            if(temp_index!=0 || old_isSave){
                Matrix3d rwi_old;
                Vector3d twi_old;
                pkFi_old->getOriginPose(twi_old, rwi_old);
                
                Matrix3d r_b_a;
                Vector3d t_b_a;
                r_b_a=oldKF_r.transpose()* rwi_old;
                t_b_a=oldKF_r.transpose()*(twi_old-oldKF_t);
                oldR_b_a.push_back(r_b_a);
                oldT_b_a.push_back(t_b_a);
            }else{
                oldR_b_a.push_back(Matrix3d::Identity());
                oldT_b_a.push_back(Vector3d::Zero());
                temp_index++;//放这里就只要执行一次
            }
        }
        vector<Matrix3d> oldR_b_a_save;
        vector<Vector3d> oldT_b_a_save;
        for(int a=0,b=vpCovKFi_old_2d_save.size();a<b;a++){
            for(KeyFrame* pkFi_old: vpCovKFi_old_2d_save[a])
            {
                if(old_isSave){
                    if(pkFi_old==kf_2d){
                        oldR_b_a_save.push_back(Matrix3d::Identity());
                        oldT_b_a_save.push_back(Vector3d::Zero());
                        continue;
                    }
                }
                Matrix3d rwi_old;
                Vector3d twi_old;
                pkFi_old->getOriginPose(twi_old, rwi_old);
                
                Matrix3d r_b_a;
                Vector3d t_b_a;
                r_b_a=oldKF_r.transpose()* rwi_old;
                t_b_a=oldKF_r.transpose()*(twi_old-oldKF_t);
                oldR_b_a_save.push_back(r_b_a);
                oldT_b_a_save.push_back(t_b_a);
            }
        }
        
//        得到回环帧之间的相对位姿
        Matrix3d R_relative;
        Vector3d T_relative;
        vector<int> clientId=kf_3d->clientId;
        vector<int> kfId=kf_3d->kfId;
        vector<std::pair<Matrix3d , Vector3d >  > relativePose=kf_3d->relativePose;
        int client_matchId=kf_2d->c->id, kf2d_global_index=kf_2d->global_index;//这里表示主地图的意思，后面肯定要改
        for(int i=0, len=clientId.size();i<len;i++){
            if(clientId[i]==client_matchId && kfId[i]==kf2d_global_index){
                R_relative=relativePose[i].first;
                T_relative=relativePose[i].second;
            }
        }
       
        
        Client* client_cur=kf_2d->c;
        Matrix3d ric_curClient=client_cur->ric_client;
        Vector3d tic_curClient=client_cur->tic_client;
        Vector3d euler_angle_ric_main=Utility::R2ypr(ric_curClient);
        const float &fx = client_cur->FOCUS_LENGTH_X_server;
        const float &fy = client_cur->FOCUS_LENGTH_Y_server;
        const float &cx = client_cur->PX_server;
        const float &cy = client_cur->PY_server;
        
        
        int similarNum=0;
        
        vector<Matrix3d> old_r;
        vector<Vector3d> old_t;
        vector<int> vpkf_index;
        for(int i=0,j=vpCovKFi_old.size();i<j;i++){
            Matrix3d r_w_imuOld=R_relative*oldR_b_a[i];
            Vector3d t_w_imuOld=R_relative*oldT_b_a[i] +T_relative;
            Matrix3d r_w_camOld=r_w_imuOld*ric_curClient;
            Vector3d t_w_camOld=r_w_imuOld*tic_curClient+t_w_imuOld;
            Matrix3d r_camOld_w=r_w_camOld.transpose();
            old_r.push_back(r_camOld_w);
            old_t.push_back(-r_camOld_w*t_w_camOld);
        }
        vector<Matrix3d> old_r_save;
        vector<Vector3d> old_t_save;
        vector<int> vpkf_index_save;
        for(int a=0,b=vpCovKFi_old_2d_save.size();a<b;a++){
            for(int i=0,j=vpCovKFi_old_2d_save[a].size();i<j;i++){
                Matrix3d r_w_imuOld=R_relative*oldR_b_a_save[i];
                Vector3d t_w_imuOld=R_relative*oldT_b_a_save[i] +T_relative;
                Matrix3d r_w_camOld=r_w_imuOld*ric_curClient;
                Vector3d t_w_camOld=r_w_imuOld*tic_curClient+t_w_imuOld;
                Matrix3d r_camOld_w=r_w_camOld.transpose();
                old_r_save.push_back(r_camOld_w);
                old_t_save.push_back(-r_camOld_w*t_w_camOld);
            }
        }
        
        while(!kf_3d->IsOriginUpdate){
            usleep(50);
        }
        std::vector<KeyFrame*> vpCovKFi_cur = kf_3d->GetBestCovisibilityKeyFrames(5);
        real_len_covKFi_old=0;
        for(int a=0,b=vpCovKFi_cur.size();a<b;a++){
            bool isFind=false;
            for(int i=0,j=vpCovKFi_cur_3d_save.size();i<j;i++){
                
                for(auto iter_save=vpCovKFi_cur_3d_save[i].begin(),iter_save_end=vpCovKFi_cur_3d_save[i].end();iter_save!=iter_save_end;iter_save++){
                    if((vpCovKFi_cur[a])==(*iter_save)){
                        isFind=true;
                        break;
                    }
                }
                if(isFind){
                    break;
                }
            }
            if(isFind==false){
                if(real_len_covKFi_old!=a){
                    vpCovKFi_cur[real_len_covKFi_old]=vpCovKFi_cur[a];
                }
                real_len_covKFi_old++;
            }
        }
        vpCovKFi_cur.resize(real_len_covKFi_old);
        vpCovKFi_cur.push_back(vpCovKFi_cur[0]);
        vpCovKFi_cur[0] = kf_3d;
        
        
        {
            //当前帧的共视帧 与 侯选帧的2级共视帧的匹配，通过重投影找
            
            point_clouds_all.clear();
            measurements_old_norm_all.clear();
            vpkf_index.clear();
            
            measurements_old_norm_all_save.clear();
            point_clouds_all_save.clear();
            vpkf_index_save.clear();
            for(KeyFrame* pKFi : vpCovKFi_cur){

                //描述符得全有
                if(!pKFi->is_des_end){
                    continue;
                }
                
                vector<Eigen::Vector3d> point_clouds_origin_cur= pKFi->point_clouds_origin;
                std::vector<cv::Point2f> measurements_origin_cur=pKFi->measurements_origin;
                vector<cv::KeyPoint> keypoints_cur=pKFi->keypoints;
                int nPoints = point_clouds_origin_cur.size();
                int point2D_len_cur=keypoints_cur.size()-point_clouds_origin_cur.size();
               
    //                int num=0;//记录匹配点的数量
                temp_index=0;//记录遍历到哪个帧了
                //这里应该遍历候选帧的共视帧 ，只要共视点数量超过一定阈值 22
                for(KeyFrame* pkFi_old: vpCovKFi_old)
                {
                    

                    //描述符得全有
                    if(!pkFi_old->is_des_end){
                        temp_index++;
                        continue;
                    }
                    
                    measurements_old_coarse.clear();
                    measurements_old_norm_coarse.clear();
                    point_3d_cur.clear();
                    measurements_cur.clear();
                
                    vector<cv::KeyPoint> keypoints_old=pkFi_old->keypoints;

                    //这个得到的是到imu坐标系的位姿
                    Matrix3d r_camOld_w=old_r[temp_index];
                    Vector3d t_camOld_w=old_t[temp_index];
                    
                    for(int i=0;i<nPoints;i++){
                        Vector3d point_main=point_clouds_origin_cur[i];
                        //把主地图下 世界坐标系的点 转到小地图上一帧的图像坐标系上
                        Vector3d p3D_c2=r_camOld_w*point_main+t_camOld_w;
                        //深度必须为正
                        if(p3D_c2[2]<0.0 || p3D_c2[2]>30.0){
    //                            cout<<"深度不为正"<<endl;
                            continue;
                        }
                        // 投影到图像上
                        double x = p3D_c2[0];
                        double y = p3D_c2[1];
                        double z = p3D_c2[2];
                        //这里可能得加一个畸变校正 应该可以不用去校正 把他投影在一个没有畸变的图像上
                        double u=fx*x/z+cx;
                        double v=fy*y/z+cy;
                      
                        
                        if(!pkFi_old->isInImage((float)u, (float)v)){
    //                            cout<<"投影点不在图像内"<<endl;
                            continue;
                        }
                        
                        const vector<int> vIndices=pkFi_old->GetFeaturesInArea_1((float)u, (float)v, 20);
                        //这里可以改为30个像素里面找不到 再扩大到50个像素 暂时未做
                        if(vIndices.empty()){
    //                            cout<<"半径为20个像素 找不到点"<<endl;
                            continue;
                        }
                        //des和keypoints长度不一样
                        //找在这个半径内最相似的 这里可能有些问题 因为3D点的描述子 个人感觉有问题
                        BRIEF::bitset point_main_des=pKFi->descriptors[point2D_len_cur+i];
                        int bestDist = 256;
                        int bestIndex = -1;
                        for(vector<int>::const_iterator vit=vIndices.begin(), vit_end=vIndices.end(); vit!=vit_end; vit++)
                        {
        //                    cout<<"*vit"<<*vit<<endl;发现 keypoints数量不等于des数量
                            int dis = pkFi_old->HammingDis(point_main_des, pkFi_old->descriptors[*vit]);
                            if(dis < bestDist)
                            {
                                bestDist = dis;
                                bestIndex = *vit;
                            }
                        }
                        
                        if(bestDist<70){
    //                                cout<<"最终选择的半径范围："<<u-keypoints_old[bestIndex].pt.x<<" ,"<<v-keypoints_old[bestIndex].pt.y<<endl;
                            point_3d_cur.push_back(point_main);
                            measurements_old_coarse.push_back(keypoints_old[bestIndex].pt);
                            measurements_cur.push_back(measurements_origin_cur[i]);
                            
                        }
                                    
                    }
                    
    //                        cout<<"50个像素内,找到的点数："<<measurements_cur.size()<<endl;
                    if(measurements_cur.size()>=22){
                        pKFi->rejectWithF_server_mapFuse(measurements_cur, measurements_old_coarse,point_3d_cur);
    //                            cout<<"f矩阵拒绝后的点数："<<measurements_cur.size()<<", "<<pKFi->global_index<<" ,"<<pkFi_old->global_index<<endl;
                        if(measurements_old_coarse.size()>16){
                        
                            cv::Point2f norm_pt;
                            int pCount=measurements_old_coarse.size();
                            for(int aa=0;aa<pCount;aa++){
                                norm_pt.x = (measurements_old_coarse[aa].x -  client_cur->PX_server)/ client_cur->FOCUS_LENGTH_X_server;
                                norm_pt.y = (measurements_old_coarse[aa].y -  client_cur->PY_server)/ client_cur->FOCUS_LENGTH_Y_server;
                                measurements_old_coarse[aa]=norm_pt;
                                
                            }
                            
                            point_clouds_all.push_back(point_3d_cur);
                            measurements_old_norm_all.push_back(measurements_old_coarse);

                            vpkf_index.push_back(temp_index);
                            similarNum++;
                            

                        }
                        
                    }
                    
                    temp_index++;
                }
                
//                老的也要找一次匹配
                temp_index=0;
                for(int a=0,b=vpCovKFi_old_2d_save.size();a<b;a++){
                    for(KeyFrame* pkFi_old: vpCovKFi_old_2d_save[a])
                    {
                                            //描述符得全有
                        if(!pkFi_old->is_des_end){
                            temp_index++;
                            continue;
                        }
                        
                        measurements_old_coarse.clear();
                        measurements_old_norm_coarse.clear();
                        point_3d_cur.clear();
                        measurements_cur.clear();
                    
                        vector<cv::KeyPoint> keypoints_old=pkFi_old->keypoints;

                        //这个得到的是到imu坐标系的位姿
                        Matrix3d r_camOld_w=old_r_save[temp_index];
                        Vector3d t_camOld_w=old_t_save[temp_index];
                        
                        for(int i=0;i<nPoints;i++){
                            Vector3d point_main=point_clouds_origin_cur[i];
                            //把主地图下 世界坐标系的点 转到小地图上一帧的图像坐标系上
                            Vector3d p3D_c2=r_camOld_w*point_main+t_camOld_w;
                            //深度必须为正
                            if(p3D_c2[2]<0.0 || p3D_c2[2]>30.0){
        //                            cout<<"深度不为正"<<endl;
                                continue;
                            }
                            // 投影到图像上
                            double x = p3D_c2[0];
                            double y = p3D_c2[1];
                            double z = p3D_c2[2];
                            //这里可能得加一个畸变校正 应该可以不用去校正 把他投影在一个没有畸变的图像上
                            double u=fx*x/z+cx;
                            double v=fy*y/z+cy;
                          
                            
                            if(!pkFi_old->isInImage((float)u, (float)v)){
        //                            cout<<"投影点不在图像内"<<endl;
                                continue;
                            }
                            
                            const vector<int> vIndices=pkFi_old->GetFeaturesInArea_1((float)u, (float)v, 20);
                            //这里可以改为30个像素里面找不到 再扩大到50个像素 暂时未做
                            if(vIndices.empty()){
        //                            cout<<"半径为20个像素 找不到点"<<endl;
                                continue;
                            }
                            //des和keypoints长度不一样
                            //找在这个半径内最相似的 这里可能有些问题 因为3D点的描述子 个人感觉有问题
                            BRIEF::bitset point_main_des=pKFi->descriptors[point2D_len_cur+i];
                            int bestDist = 256;
                            int bestIndex = -1;
                            for(vector<int>::const_iterator vit=vIndices.begin(), vit_end=vIndices.end(); vit!=vit_end; vit++)
                            {
            //                    cout<<"*vit"<<*vit<<endl;发现 keypoints数量不等于des数量
                                int dis = pkFi_old->HammingDis(point_main_des, pkFi_old->descriptors[*vit]);
                                if(dis < bestDist)
                                {
                                    bestDist = dis;
                                    bestIndex = *vit;
                                }
                            }
                            
                            if(bestDist<70){
        //                                cout<<"最终选择的半径范围："<<u-keypoints_old[bestIndex].pt.x<<" ,"<<v-keypoints_old[bestIndex].pt.y<<endl;
                                point_3d_cur.push_back(point_main);
                                measurements_old_coarse.push_back(keypoints_old[bestIndex].pt);
                                measurements_cur.push_back(measurements_origin_cur[i]);
                                
                            }
                                        
                        }
                        
        //                        cout<<"50个像素内,找到的点数："<<measurements_cur.size()<<endl;
                        if(measurements_cur.size()>=22){
                            pKFi->rejectWithF_server_mapFuse(measurements_cur, measurements_old_coarse,point_3d_cur);
        //                            cout<<"f矩阵拒绝后的点数："<<measurements_cur.size()<<", "<<pKFi->global_index<<" ,"<<pkFi_old->global_index<<endl;
                            if(measurements_old_coarse.size()>16){
                            
                                cv::Point2f norm_pt;
                                int pCount=measurements_old_coarse.size();
                                for(int aa=0;aa<pCount;aa++){
                                    norm_pt.x = (measurements_old_coarse[aa].x -  client_cur->PX_server)/ client_cur->FOCUS_LENGTH_X_server;
                                    norm_pt.y = (measurements_old_coarse[aa].y -  client_cur->PY_server)/ client_cur->FOCUS_LENGTH_Y_server;
                                    measurements_old_coarse[aa]=norm_pt;
                                    
                                }
                                
                                point_clouds_all_save.push_back(point_3d_cur);
                                measurements_old_norm_all_save.push_back(measurements_old_coarse);

                                vpkf_index_save.push_back(temp_index);
                                similarNum++;
                            }
                            
                        }
                        
                        temp_index++;
                    }
                }
            }
            
            for(int a=0,b=vpCovKFi_cur_3d_save.size();a<b;a++){
                for(KeyFrame* pKFi : vpCovKFi_cur_3d_save[a]){
                    //描述符得全有
                    if(!pKFi->is_des_end){
                        continue;
                    }
                    
                    vector<Eigen::Vector3d> point_clouds_origin_cur= pKFi->point_clouds_origin;
                    std::vector<cv::Point2f> measurements_origin_cur=pKFi->measurements_origin;
                    vector<cv::KeyPoint> keypoints_cur=pKFi->keypoints;
                    int nPoints = point_clouds_origin_cur.size();
                    int point2D_len_cur=keypoints_cur.size()-point_clouds_origin_cur.size();
                   
        //                int num=0;//记录匹配点的数量
                    temp_index=0;//记录遍历到哪个帧了
                    //这里应该遍历候选帧的共视帧 ，只要共视点数量超过一定阈值 22
                    for(KeyFrame* pkFi_old: vpCovKFi_old)
                    {
                        

                        //描述符得全有
                        if(!pkFi_old->is_des_end){
                            temp_index++;
                            continue;
                        }
                        
                        measurements_old_coarse.clear();
                        measurements_old_norm_coarse.clear();
                        point_3d_cur.clear();
                        measurements_cur.clear();
                    
                        vector<cv::KeyPoint> keypoints_old=pkFi_old->keypoints;

                        //这个得到的是到imu坐标系的位姿
                        Matrix3d r_camOld_w=old_r[temp_index];
                        Vector3d t_camOld_w=old_t[temp_index];
                        
                        for(int i=0;i<nPoints;i++){
                            Vector3d point_main=point_clouds_origin_cur[i];
                            //把主地图下 世界坐标系的点 转到小地图上一帧的图像坐标系上
                            Vector3d p3D_c2=r_camOld_w*point_main+t_camOld_w;
                            //深度必须为正
                            if(p3D_c2[2]<0.0 || p3D_c2[2]>30.0){
        //                            cout<<"深度不为正"<<endl;
                                continue;
                            }
                            // 投影到图像上
                            double x = p3D_c2[0];
                            double y = p3D_c2[1];
                            double z = p3D_c2[2];
                            //这里可能得加一个畸变校正 应该可以不用去校正 把他投影在一个没有畸变的图像上
                            double u=fx*x/z+cx;
                            double v=fy*y/z+cy;
                          
                            
                            if(!pkFi_old->isInImage((float)u, (float)v)){
        //                            cout<<"投影点不在图像内"<<endl;
                                continue;
                            }
                            
                            const vector<int> vIndices=pkFi_old->GetFeaturesInArea_1((float)u, (float)v, 20);
                            //这里可以改为30个像素里面找不到 再扩大到50个像素 暂时未做
                            if(vIndices.empty()){
        //                            cout<<"半径为20个像素 找不到点"<<endl;
                                continue;
                            }
                            //des和keypoints长度不一样
                            //找在这个半径内最相似的 这里可能有些问题 因为3D点的描述子 个人感觉有问题
                            BRIEF::bitset point_main_des=pKFi->descriptors[point2D_len_cur+i];
                            int bestDist = 256;
                            int bestIndex = -1;
                            for(vector<int>::const_iterator vit=vIndices.begin(), vit_end=vIndices.end(); vit!=vit_end; vit++)
                            {
            //                    cout<<"*vit"<<*vit<<endl;发现 keypoints数量不等于des数量
                                int dis = pkFi_old->HammingDis(point_main_des, pkFi_old->descriptors[*vit]);
                                if(dis < bestDist)
                                {
                                    bestDist = dis;
                                    bestIndex = *vit;
                                }
                            }
                            
                            if(bestDist<70){
        //                                cout<<"最终选择的半径范围："<<u-keypoints_old[bestIndex].pt.x<<" ,"<<v-keypoints_old[bestIndex].pt.y<<endl;
                                point_3d_cur.push_back(point_main);
                                measurements_old_coarse.push_back(keypoints_old[bestIndex].pt);
                                measurements_cur.push_back(measurements_origin_cur[i]);
                                
                            }
                                        
                        }
                        
        //                        cout<<"50个像素内,找到的点数："<<measurements_cur.size()<<endl;
                        if(measurements_cur.size()>=22){
                            pKFi->rejectWithF_server_mapFuse(measurements_cur, measurements_old_coarse,point_3d_cur);
        //                            cout<<"f矩阵拒绝后的点数："<<measurements_cur.size()<<", "<<pKFi->global_index<<" ,"<<pkFi_old->global_index<<endl;
                            if(measurements_old_coarse.size()>16){
                            
                                cv::Point2f norm_pt;
                                int pCount=measurements_old_coarse.size();
                                for(int aa=0;aa<pCount;aa++){
                                    norm_pt.x = (measurements_old_coarse[aa].x -  client_cur->PX_server)/ client_cur->FOCUS_LENGTH_X_server;
                                    norm_pt.y = (measurements_old_coarse[aa].y -  client_cur->PY_server)/ client_cur->FOCUS_LENGTH_Y_server;
                                    measurements_old_coarse[aa]=norm_pt;
                                    
                                }
                                
                                point_clouds_all.push_back(point_3d_cur);
                                measurements_old_norm_all.push_back(measurements_old_coarse);

                                vpkf_index.push_back(temp_index);
                                similarNum++;
                                

                            }
                            
                        }
                        
                        temp_index++;
                    }
                }
            }
        }

        PoseGraph* pCurrentMap;
        int client_id_3d,client_id_2d,otherKF_global_index,curKF_global_index;
  
        pCurrentMap=pg_3d;
        client_id_3d=kf_3d->c->id;
        client_id_2d=kf_2d->c->id;
        otherKF_global_index=kf_2d->global_index;
        curKF_global_index=kf_3d->global_index;
  
        
        if(similarNum>=2){
            int optiKf_num=vpkf_index.size()+vpkf_index_save.size()+2;//为什么是+2 而不是加1
            cout<<"optiKf_num_save="<< point_clouds_all_save.size()<<endl;
            cout<<"optiKf_num_save="<< point_clouds_all.size()+point_clouds_all_save.size()<<endl;
            
            TS(cere_optitesttesttest);
            //构造优化问题
            double t_array[optiKf_num][3];//平移数组，其中存放每个关键帧的平移向量
            Quaterniond q_array[optiKf_num];
            double euler_array[optiKf_num][3];

            ceres::Problem problem;
            ceres::Solver::Options options;
            //options.linear_solver_type = ceres::DENSE_NORMAL_CHOLESKY;
            options.linear_solver_type = ceres::DENSE_SCHUR;
            //options.minimizer_progress_to_stdout = true;
            options.max_num_iterations = 20;
            ceres::Solver::Summary summary;
            ceres::LossFunction *loss_function;
            loss_function = new ceres::HuberLoss(1.0);
            //AngleLocalParameterization类的主要作用是指定yaw角优化变量的迭代更新，重载了括号运算
            ceres::LocalParameterization* angle_local_parameterization = AngleLocalParameterization::Create();

            
            Matrix3d curKF_r;
            Vector3d curKF_t;
            kf_3d->getOriginPose(curKF_t, curKF_r);
            
            
            Matrix3d tmp_r_old;
            Vector3d tmp_t_old;
            t_array[0][0] = curKF_t(0);
            t_array[0][1] = curKF_t(1);
            t_array[0][2] = curKF_t(2);
            //将矩阵转换为向量
            Vector3d euler_angle_old = Utility::R2ypr(curKF_r);
            euler_array[0][0] = euler_angle_old.x();
            euler_array[0][1] = euler_angle_old.y();
            euler_array[0][2] = euler_angle_old.z();
            problem.AddParameterBlock(euler_array[0], 3);
            problem.AddParameterBlock(t_array[0], 3);

            
            //再加一个根据当前帧与侯选帧之间的匹配关系，构造最开始的那个3d点 到候选帧的误差
            map<int,int> resample;
            temp_index=0;
            for(int len=vpkf_index.size(); temp_index<len; temp_index++ ){
                
                int kf_index=temp_index+1;
                Matrix3d relative_r_b_a;
                Vector3d relative_t_b_a;
                relative_r_b_a=oldR_b_a[vpkf_index[temp_index]];
                relative_t_b_a=oldT_b_a[vpkf_index[temp_index]];
                Vector3d relative_r_b_a_euler=Utility::R2ypr(relative_r_b_a);
                
                
                map<int,int>::iterator iter;
                iter = resample.find(vpkf_index[temp_index]);
                if(iter != resample.end())
                {
                    kf_index=resample[vpkf_index[temp_index]];
                }
                else
                {
                    resample[vpkf_index[temp_index]]=kf_index;

                    t_array[kf_index][0] = relative_t_b_a(0);
                    t_array[kf_index][1] = relative_t_b_a(1);
                    t_array[kf_index][2] = relative_t_b_a(2);
                    euler_array[kf_index][0] = relative_r_b_a_euler.x();
                    euler_array[kf_index][1] = relative_r_b_a_euler.y();
                    euler_array[kf_index][2] = relative_r_b_a_euler.z();
                    problem.AddParameterBlock(euler_array[kf_index], 1, angle_local_parameterization);
                    problem.AddParameterBlock(t_array[kf_index], 3);
                   
                    ceres::CostFunction* cost_function = FourSixDOFError::Create( relative_t_b_a(0),relative_t_b_a(1),relative_t_b_a(2),relative_r_b_a_euler(0),1);
                    problem.AddResidualBlock(cost_function, loss_function, euler_array[kf_index],t_array[kf_index]);
                    
                }
              

                vector<Vector3d> point_single=point_clouds_all[temp_index];
                vector<cv::Point2f> measure_single=measurements_old_norm_all[temp_index];
                for(int a=0,b=point_single.size();a<b;a++){

                    //找到主地图那个点 所在帧的位姿
                    Vector3d pts_i = point_single[a];

                    //相机平面坐标
                    cv::Point2f pt=measure_single[a];

                    ceres::CostFunction* cost_function = FourSixDOFWeightError_reprojection_3::Create( pts_i.x(), pts_i.y(), pts_i.z(),pt.x, pt.y, tic_curClient[0], tic_curClient[1], tic_curClient[2], euler_angle_ric_main.x(), euler_angle_ric_main.y(), euler_angle_ric_main.z() ,relative_r_b_a_euler(1),relative_r_b_a_euler(2),100.0);
                    problem.AddResidualBlock(cost_function, loss_function, euler_array[0],t_array[0], euler_array[kf_index],t_array[kf_index]);
                    
                 }
            }
            
            
            resample.clear();
            int temp_index_save=0;
            for(int len=vpkf_index_save.size(); temp_index_save<len; temp_index_save++ ){
                
                int kf_index=temp_index+1;
                Matrix3d relative_r_b_a;
                Vector3d relative_t_b_a;
                relative_r_b_a=oldR_b_a_save[vpkf_index_save[temp_index_save]];
                relative_t_b_a=oldT_b_a_save[vpkf_index_save[temp_index_save]];
                Vector3d relative_r_b_a_euler=Utility::R2ypr(relative_r_b_a);
                
                
                map<int,int>::iterator iter;
                iter = resample.find(vpkf_index_save[temp_index_save]);
                if(iter != resample.end())
                {
                    kf_index=resample[vpkf_index_save[temp_index_save]];
                }
                else
                {
                    resample[vpkf_index_save[temp_index_save]]=kf_index;

                    t_array[kf_index][0] = relative_t_b_a(0);
                    t_array[kf_index][1] = relative_t_b_a(1);
                    t_array[kf_index][2] = relative_t_b_a(2);
                    euler_array[kf_index][0] = relative_r_b_a_euler.x();
                    euler_array[kf_index][1] = relative_r_b_a_euler.y();
                    euler_array[kf_index][2] = relative_r_b_a_euler.z();
                    problem.AddParameterBlock(euler_array[kf_index], 1, angle_local_parameterization);
                    problem.AddParameterBlock(t_array[kf_index], 3);
                   
                    ceres::CostFunction* cost_function = FourSixDOFError::Create( relative_t_b_a(0),relative_t_b_a(1),relative_t_b_a(2),relative_r_b_a_euler(0),1);
                    problem.AddResidualBlock(cost_function, loss_function, euler_array[kf_index],t_array[kf_index]);
                    
                }
              

                vector<Vector3d> point_single=point_clouds_all_save[temp_index_save];
                vector<cv::Point2f> measure_single=measurements_old_norm_all_save[temp_index_save];
                for(int a=0,b=point_single.size();a<b;a++){

                    //找到主地图那个点 所在帧的位姿
                    Vector3d pts_i = point_single[a];

                    //相机平面坐标
                    cv::Point2f pt=measure_single[a];

                    ceres::CostFunction* cost_function = FourSixDOFWeightError_reprojection_3::Create( pts_i.x(), pts_i.y(), pts_i.z(),pt.x, pt.y, tic_curClient[0], tic_curClient[1], tic_curClient[2], euler_angle_ric_main.x(), euler_angle_ric_main.y(), euler_angle_ric_main.z() ,relative_r_b_a_euler(1),relative_r_b_a_euler(2),100.0);
                    problem.AddResidualBlock(cost_function, loss_function, euler_array[0],t_array[0], euler_array[kf_index],t_array[kf_index]);
                    
                 }
            }
            
            
            
            ceres::Solve(options, &problem, &summary);
            std::cout <<"全局-精确相对位姿："<<kf_3d->c->id<<" , "<< summary.BriefReport() << "\n";

            if(summary.termination_type!=ceres::CONVERGENCE){
                pCurrentMap->isFirstFusion_globalMutex.lock();
                isFirstFusion[client_id_3d]-=1;
                pCurrentMap->isFirstFusion_globalMutex.unlock();
                return;}
            TE(cere_optitesttesttest);
            TE(testtesttest);
//            保存数据
            pg_3d->globalLoop_mutex.lock();
            pg_3d->vpkf_index.push_back(vpkf_index);
            pg_3d->measurements_old_norm_all.push_back(measurements_old_norm_all);
            pg_3d->point_clouds_all.push_back(point_clouds_all);
            pg_3d->vpCovKFi_old_2d.push_back(vpCovKFi_old);
            pg_3d->vpCovKFi_cur_3d.push_back(vpCovKFi_cur);
            pg_3d->curGlobalLoopKf_id.push_back(kf_3d_id);
            pg_3d->oldGlobalLoopKf_id.push_back(kf_2d_id);
            pg_3d->oldAgent_id_forLoopKf.push_back(agent_2d_id);
            pg_3d->globalLoop_mutex.unlock();
            
            Matrix3d Rs_i ;
            Vector3d Ps_i ;//当前帧
            kf_3d->getOriginPose(Ps_i, Rs_i);
            



            Vector3d q;
            q<<euler_array[0][0],euler_array[0][1],euler_array[0][2];
            Matrix3d Rs_loop = Utility::ypr2R(q);
            Vector3d Ps_loop = Vector3d( t_array[0][0],  t_array[0][1],  t_array[0][2]);

//求得的是3d到2d的关系
            Vector3d relative_t = Rs_loop.transpose() * (Ps_i - Ps_loop);
//                Matrix3d relative_q = Rs_loop.transpose() * Rs_i;
            double relative_yaw = Utility::normalizeAngle(Utility::R2ypr(Rs_i).x() - Utility::R2ypr(Rs_loop).x());
            double relative_pitch = Utility::normalizeAngle(Utility::R2ypr(Rs_i).y() - Utility::R2ypr(Rs_loop).y());
            double relative_roll = Utility::normalizeAngle(Utility::R2ypr(Rs_i).z() - Utility::R2ypr(Rs_loop).z());
//            Quaterniond rela_q=Quaterniond(relative_q);
            
            Quaterniond rs_loop_q=Quaterniond(Rs_loop),rs_i_q=Quaterniond(Rs_i);
            Quaterniond rela_q=rs_loop_q.inverse()*rs_i_q;

            //实验记录
//            std::ofstream outFile;
//            //打开文件
//            outFile.open("/Users/zhangjianhua/Desktop/hh/VINS_MapFusion/VINS_MapFusion/data/"+
//                             to_string(kf_3d->global_index)+"&"+to_string(kf_3d->header)+"&"+to_string(kf_2d->global_index)+"&"+to_string(kf_2d->header)+".txt");
//            outFile.setf(ios::fixed, ios::floatfield);  // 设定为 fixed 模式，以小数点表示浮点数
//            outFile.precision(19);
//                //写入数据
////                outFile <<"测试是否存在误匹配，当前client.id:\n"<<kf_3d->c->id<<"\n当作帧的header:\n"<<kf_3d->header<<"\n当作帧的global_index:\n"<<kf_3d->global_index<<"\n2d帧的client.id:\n"<<kf_2d->c->id <<"\n2d帧的header:\n"<<kf_2d->header<<"\n2d帧的global_index:\n"<<kf_2d->global_index  <<"\n3d-2d的r:\n"<<rela_q<<"\n3d-2d的t\n"<<relative_t;
//            outFile <<kf_3d->c->id<<"\n"<<kf_3d->header<<"\n"<<kf_3d->global_index<<"\n"<<kf_2d->c->id <<"\n"<<kf_2d->header<<"\n"<<kf_2d->global_index  <<"\n"<<rela_q.x()<<"\n"<<rela_q.y()<<"\n"<<rela_q.z()<<"\n"<<rela_q.w()<<"\n"<<relative_t[0]<<"\n"<<relative_t[1]<<"\n"<<relative_t[2];
//                //关闭文件
//            outFile.close();
            Eigen::Matrix<double, 8, 1> connected_info;
            connected_info <<relative_t.x(), relative_t.y(), relative_t.z(),
            rela_q.w(), rela_q.x(), rela_q.y(), rela_q.z(),
            relative_yaw;
//            for(int i=0, len=clientId.size();i<len;i++){
//                if(clientId[i]==client_matchId && kfId[i]==kf2d_global_index){
                    kf_3d->relative_global_loop_info_multiClient.push_back(connected_info);
//                }
//            }
            
//            实验 开始
//            cout<<"回环："<<pg_2d->c->getId()<<" ,"<<pg_3d->c->getId()<<endl;
            bool isFuse=pg_3d->fuseClientId[pg_2d->c->getId()];
//            cout<<"isFuse= "<<isFuse<<" , "<<pg_2d->c->getId()<<endl;
            if(!isFuse){
                cout<<"回环："<<pg_2d->c->getId()<<" , "<<pg_3d->c->getId()<<endl;
                cout<<"回环kfid："<<kf_2d->global_index<<" , "<<kf_3d->global_index<<endl;
//                是第一次融合
                pg_3d->fuseClientId[pg_2d->c->getId()]=true;
                Matrix3d r_w2_j;
                Vector3d t_w2_j;
                kf_2d->getOriginPose(t_w2_j, r_w2_j);
                pg_3d->fromI2OtherClient_r[pg_2d->c->getId()]=r_w2_j*Rs_loop.transpose();
                pg_3d->fromI2OtherClient_t[pg_2d->c->getId()]=-pg_3d->fromI2OtherClient_r[pg_2d->c->getId()]*Ps_loop+t_w2_j;
                
//                cout<<"赋值1："<<pg_2d->c->getId()<<" , " <<pg_3d->fromI2OtherClient_t[pg_2d->c->getId()] <<" , "<<pg_3d->fromI2OtherClient_r[pg_2d->c->getId()] <<endl;
            }
            isFuse=pg_2d->fuseClientId[pg_3d->c->getId()];
//            cout<<isFuse<<endl;
            if(!isFuse){
//                是第一次融合
                pg_2d->fuseClientId[pg_3d->c->getId()]=true;
                Matrix3d r_w1_j;
                Vector3d t_w1_j;
                kf_3d->getOriginPose(t_w1_j, r_w1_j);
                pg_2d->fromI2OtherClient_r[pg_3d->c->getId()]=Rs_loop* r_w1_j.transpose();
                pg_2d->fromI2OtherClient_t[pg_3d->c->getId()]=-pg_2d->fromI2OtherClient_r[pg_3d->c->getId()]*t_w1_j+ Ps_loop;
//                cout<<"赋值2："<<pg_3d->c->getId()<<" , " <<pg_2d->fromI2OtherClient_t[pg_3d->c->getId()] <<" , "<<pg_2d->fromI2OtherClient_r[pg_3d->c->getId()] <<endl;
            }
//实验 end
            
            
        
        
//            这个是触发全局优化 之前是设置的其它地图，默认是和主地图优化
//            现在 设置成3d地图
//            加一个读写锁 只这里一次赋值 用来判断 是否和其它地图发生了融合 最终做什么样的优化
        pCurrentMap->readWriteLock_is_fusion_mutex.writeLock();
        pCurrentMap->is_fusion=1;
        pCurrentMap->readWriteLock_is_fusion_mutex.writeUnLock();
            
        pCurrentMap->isFirstFusion_globalMutex.lock();
       //找到了
        isFirstFusion[client_id_3d]-=1;
        //思考一下赋值 加锁
        int latest_index_cur_test=latest_globalLoop_index[client_id_3d];
        latest_index_cur_test=latest_index_cur_test>curKF_global_index?latest_index_cur_test:curKF_global_index;
        latest_globalLoop_index[client_id_3d]=latest_index_cur_test;
        if(earliest_globalLoop_index[client_id_3d]==-1 || earliest_globalLoop_index[client_id_3d]>curKF_global_index){
            earliest_globalLoop_index[client_id_3d]=curKF_global_index;
        }
        pCurrentMap->isFirstFusion_globalMutex.unlock();
            
        pg_2d->isFirstFusion_globalMutex.lock();
        //思考一下赋值 加锁
        int latest_index_other_test=latest_globalLoop_index[client_id_2d];
        latest_index_other_test=latest_index_other_test>otherKF_global_index?latest_index_other_test:otherKF_global_index;
        latest_globalLoop_index[client_id_2d]=latest_index_other_test;//目前唯一赋值的地方
        //记录主地图和其它地图最早的融合位置
        if(earliest_globalLoop_index[client_id_2d]==-1 || earliest_globalLoop_index[client_id_2d]>otherKF_global_index){
            earliest_globalLoop_index[client_id_2d]=otherKF_global_index;
        }
        pg_2d->isFirstFusion_globalMutex.unlock();
            
        kf_3d->update_globalLoopConnection(relative_t, rela_q, relative_yaw);
        kf_3d->global_relative_pitch=relative_pitch;
        kf_3d->global_relative_roll=relative_roll;
        kf_3d->detect_globalLoop(kf_2d->global_index);
        kf_2d->is_detected_globalLoop(kf_3d->global_index);
                
        if( ! uf.isConnected(client_id_3d, client_id_2d)){
            uf.connect(client_id_3d, client_id_2d);
        }
        
        pCurrentMap->start_global_fuse_opti_mutex.lock();
        pCurrentMap->start_global_fuse_opti=1;
        pCurrentMap->start_global_fuse_opti_mutex.unlock();

            
//            子地图实验 拿到和其它地图最相似的一帧，找对应的子地图进行融合-----------------------
//            global_featureMap->allocateSubMap_multi(kf_3d, kf_2d);
            
//                    ------实验 记录能和哪些帧匹配 id header 是哪个地图的------
//        std::ofstream outFile;
//        outFile.setf(ios::fixed, ios::floatfield);  // 设定为 fixed 模式，以小数点表示浮点数
//        outFile.precision(16);  // 设置精度 2
//        //打开文件
//        outFile.open("/Users/zhangjianhua/Desktop/VINS_MapFusion/VINS_MapFusion/data/loop_old/"+ to_string(kf_3d->c->getId())+"&"+
//                     to_string(kf_3d->global_index)+"&"+to_string(kf_3d->header)+"&"+to_string(kf_2d->c->getId())+"&"+to_string(kf_2d->global_index)+"&"+to_string(kf_2d->header)+".txt");
//                //写入数据
//        outFile << kf_3d->c->getId()<<" "<<kf_3d->global_index<<" "<<kf_3d->header<<"\n" <<kf_2d->c->getId()<<" "<<kf_2d->global_index<<" "<<kf_2d->header;
//
//        outFile<<"\n";
//        //关闭文件
//        outFile.close();
//                    ------实验 子地图 记录能和哪些帧匹配 id header------
            
            std::ofstream outFile;
            outFile.setf(ios::fixed, ios::floatfield);  // 设定为 fixed 模式，以小数点表示浮点数
            outFile.precision(16);  // 设置精度
            outFile.open("/Users/zhangjianhua/Desktop/VINS_MapFusion/VINS_MapFusion/data/loop_subMap/"+ to_string(kf_3d->c->getId())+"&"+
                         to_string(kf_3d->global_index)+"&"+to_string(kf_2d->c->getId())+"&"+to_string(kf_2d->global_index)+".txt");
                    //写入数据
            outFile << kf_3d->c->getId()<<" "<<kf_3d->global_index<<" "<<kf_3d->header<<"\n" <<kf_2d->c->getId()<<" "<<kf_2d->global_index<<" "<<kf_2d->header;

            outFile<<"\n";
            //关闭文件
            outFile.close();
//                    ------实验 end 子地图 记录能和哪些帧匹配 id header------
    }
        else{
            cout<<"全局匹配帧数不够="<<similarNum<<endl;
            pCurrentMap->isFirstFusion_globalMutex.lock();

            isFirstFusion[client_id_3d]-=1;
            pCurrentMap->isFirstFusion_globalMutex.unlock();
        }
        
        
        
        
        
        {
            TS(testtesttesthh);
            //第二步-------------------------根据前面求得的粗糙的相对位姿求得准确的相对位姿--------重投影找匹配点---------------------------
            vector<vector<cv::Point2f>> measurements_old_norm_all;
            vector<vector<Eigen::Vector3d>> point_clouds_all;
            std::vector<cv::Point2f> measurements_old_coarse;//像素坐标
            std::vector<cv::Point2f> measurements_old_norm_coarse;//图像坐标
            std::vector<Vector3d> point_3d_cur;
            std::vector<cv::Point2f> measurements_cur;//像素坐标
            
            //这里就是假设所有的都是正的
            vector<KeyFrame*> vpCovKFi_old=kf_2d->GetBestCovisibilityKeyFrames(5);
            vpCovKFi_old.push_back(vpCovKFi_old[0]);
            vpCovKFi_old[0]=kf_2d;
            Matrix3d oldKF_r;
            Vector3d oldKF_t;
            kf_2d->getOriginPose(oldKF_t, oldKF_r);
                
            
                
            vector<Matrix3d> oldR_b_a;
            vector<Vector3d> oldT_b_a;
            int temp_index=0;
            //先算出来 在当前帧误差下，世界坐标系 到 侯选帧的共视帧的位姿关系
            for(KeyFrame* pkFi_old: vpCovKFi_old){
                if(temp_index!=0){
                    Matrix3d rwi_old;
                    Vector3d twi_old;
                    pkFi_old->getOriginPose(twi_old, rwi_old);
                    
                    Matrix3d r_b_a;
                    Vector3d t_b_a;
                    r_b_a=oldKF_r.transpose()* rwi_old;
                    t_b_a=oldKF_r.transpose()*(twi_old-oldKF_t);
                    oldR_b_a.push_back(r_b_a);
                    oldT_b_a.push_back(t_b_a);
                }else{
                    oldR_b_a.push_back(Matrix3d::Identity());
                    oldT_b_a.push_back(Vector3d::Zero());
                    temp_index++;//放这里就只要执行一次
                }
            }
            
            int similarNum=0;
            temp_index=0;
            vector<Matrix3d> old_r;
            vector<Vector3d> old_t;
            vector<int> vpkf_index;
            
            
            Matrix3d R_relative;
            Vector3d T_relative;
           
            vector<int> clientId=kf_3d->clientId;
            vector<int> kfId=kf_3d->kfId;
            vector<std::pair<Matrix3d , Vector3d >  > relativePose=kf_3d->relativePose;
            int client_matchId=kf_2d->c->id, kf2d_global_index=kf_2d->global_index;//这里表示主地图的意思，后面肯定要改
            for(int i=0, len=clientId.size();i<len;i++){
                if(clientId[i]==client_matchId && kfId[i]==kf2d_global_index){
                    R_relative=relativePose[i].first;
                    T_relative=relativePose[i].second;
                }
            }
           
            
            Client* client_cur=kf_2d->c;
            Matrix3d ric_curClient=client_cur->ric_client;
            Vector3d tic_curClient=client_cur->tic_client;
            Vector3d euler_angle_ric_main=Utility::R2ypr(ric_curClient);
            const float &fx = client_cur->FOCUS_LENGTH_X_server;
            const float &fy = client_cur->FOCUS_LENGTH_Y_server;
            const float &cx = client_cur->PX_server;
            const float &cy = client_cur->PY_server;
            
            
                
            for(KeyFrame* pkf_old:vpCovKFi_old){
                Matrix3d r_w_imuOld=R_relative*oldR_b_a[temp_index];
                Vector3d t_w_imuOld=R_relative*oldT_b_a[temp_index] +T_relative;
                Matrix3d r_w_camOld=r_w_imuOld*ric_curClient;
                Vector3d t_w_camOld=r_w_imuOld*tic_curClient+t_w_imuOld;
                Matrix3d r_camOld_w=r_w_camOld.transpose();
                old_r.push_back(r_camOld_w);
                old_t.push_back(-r_camOld_w*t_w_camOld);
                temp_index++;
                
            }
            
            while(!kf_3d->IsOriginUpdate){
                usleep(50);
            }
            std::vector<KeyFrame*> vpCovKFi_cur = kf_3d->GetBestCovisibilityKeyFrames(5);
            vpCovKFi_cur.push_back(vpCovKFi_cur[0]);
            vpCovKFi_cur[0] = kf_3d;
            
            
            {
                //当前帧的共视帧 与 侯选帧的2级共视帧的匹配，通过重投影找
                
                point_clouds_all.clear();
                measurements_old_norm_all.clear();
                vpkf_index.clear();
                for(KeyFrame* pKFi : vpCovKFi_cur){

                    //描述符得全有
                    if(!pKFi->is_des_end){
                        continue;
                    }
                    
                    vector<Eigen::Vector3d> point_clouds_origin_cur= pKFi->point_clouds_origin;
                    std::vector<cv::Point2f> measurements_origin_cur=pKFi->measurements_origin;
                    vector<cv::KeyPoint> keypoints_cur=pKFi->keypoints;
                    int nPoints = point_clouds_origin_cur.size();
                    int point2D_len_cur=keypoints_cur.size()-point_clouds_origin_cur.size();
                   
        //                int num=0;//记录匹配点的数量
                    temp_index=0;//记录遍历到哪个帧了
                    //这里应该遍历候选帧的共视帧 ，只要共视点数量超过一定阈值 22
                    for(KeyFrame* pkFi_old: vpCovKFi_old)
                    {
                        

                        //描述符得全有
                        if(!pkFi_old->is_des_end){
                            temp_index++;
                            continue;
                        }
                        
                        measurements_old_coarse.clear();
                        measurements_old_norm_coarse.clear();
                        point_3d_cur.clear();
                        measurements_cur.clear();
                    
                        vector<cv::KeyPoint> keypoints_old=pkFi_old->keypoints;

                        //这个得到的是到imu坐标系的位姿
                        Matrix3d r_camOld_w=old_r[temp_index];
                        Vector3d t_camOld_w=old_t[temp_index];
                        
                        for(int i=0;i<nPoints;i++){
                            Vector3d point_main=point_clouds_origin_cur[i];
                            //把主地图下 世界坐标系的点 转到小地图上一帧的图像坐标系上
                            Vector3d p3D_c2=r_camOld_w*point_main+t_camOld_w;
                            //深度必须为正
                            if(p3D_c2[2]<0.0 || p3D_c2[2]>30.0){
        //                            cout<<"深度不为正"<<endl;
                                continue;
                            }
                            // 投影到图像上
                            double x = p3D_c2[0];
                            double y = p3D_c2[1];
                            double z = p3D_c2[2];
                            //这里可能得加一个畸变校正 应该可以不用去校正 把他投影在一个没有畸变的图像上
                            double u=fx*x/z+cx;
                            double v=fy*y/z+cy;
                          
                            
                            if(!pkFi_old->isInImage((float)u, (float)v)){
        //                            cout<<"投影点不在图像内"<<endl;
                                continue;
                            }
                            
                            const vector<int> vIndices=pkFi_old->GetFeaturesInArea_1((float)u, (float)v, 20);
                            //这里可以改为30个像素里面找不到 再扩大到50个像素 暂时未做
                            if(vIndices.empty()){
        //                            cout<<"半径为20个像素 找不到点"<<endl;
                                continue;
                            }
                            //des和keypoints长度不一样
                            //找在这个半径内最相似的 这里可能有些问题 因为3D点的描述子 个人感觉有问题
                            BRIEF::bitset point_main_des=pKFi->descriptors[point2D_len_cur+i];
                            int bestDist = 256;
                            int bestIndex = -1;
                            for(vector<int>::const_iterator vit=vIndices.begin(), vit_end=vIndices.end(); vit!=vit_end; vit++)
                            {
            //                    cout<<"*vit"<<*vit<<endl;发现 keypoints数量不等于des数量
                                int dis = pkFi_old->HammingDis(point_main_des, pkFi_old->descriptors[*vit]);
                                if(dis < bestDist)
                                {
                                    bestDist = dis;
                                    bestIndex = *vit;
                                }
                            }
                            
                            if(bestDist<70){
        //                                cout<<"最终选择的半径范围："<<u-keypoints_old[bestIndex].pt.x<<" ,"<<v-keypoints_old[bestIndex].pt.y<<endl;
                                point_3d_cur.push_back(point_main);
                                measurements_old_coarse.push_back(keypoints_old[bestIndex].pt);
                                measurements_cur.push_back(measurements_origin_cur[i]);
                                
                            }
                                        
                        }
                        
        //                        cout<<"50个像素内,找到的点数："<<measurements_cur.size()<<endl;
                        if(measurements_cur.size()>=22){
                            pKFi->rejectWithF_server_mapFuse(measurements_cur, measurements_old_coarse,point_3d_cur);
        //                            cout<<"f矩阵拒绝后的点数："<<measurements_cur.size()<<", "<<pKFi->global_index<<" ,"<<pkFi_old->global_index<<endl;
                            if(measurements_old_coarse.size()>16){
                            
                                cv::Point2f norm_pt;
                                int pCount=measurements_old_coarse.size();
                                for(int aa=0;aa<pCount;aa++){
                                    norm_pt.x = (measurements_old_coarse[aa].x -  client_cur->PX_server)/ client_cur->FOCUS_LENGTH_X_server;
                                    norm_pt.y = (measurements_old_coarse[aa].y -  client_cur->PY_server)/ client_cur->FOCUS_LENGTH_Y_server;
                                    measurements_old_coarse[aa]=norm_pt;
                                    
                                }
                                
                                point_clouds_all.push_back(point_3d_cur);
                                measurements_old_norm_all.push_back(measurements_old_coarse);

                                vpkf_index.push_back(temp_index);
                                similarNum++;
                                

                            }
                            
                        }
                        
                        temp_index++;
                    }
                }
            }

            PoseGraph* pCurrentMap;
            int client_id_3d,client_id_2d,otherKF_global_index,curKF_global_index;
        //    if(noMain==1){
                pCurrentMap=pg_3d;
                client_id_3d=kf_3d->c->id;
                client_id_2d=kf_2d->c->id;
                otherKF_global_index=kf_2d->global_index;
                curKF_global_index=kf_3d->global_index;
        //    }
        //    else{
        //        pCurrentMap=pg_2d;
        //        client_id_3d=kf_2d->c->id;
        //        client_id_2d=kf_2d->c->id;
        //        mainKF_global_index=kf_3d->global_index;
        //        curKF_global_index=kf_2d->global_index;
        //    }
            
                if(similarNum>=2){
                    int optiKf_num=vpkf_index.size()+2;
                    cout<<"optiKf_num="<< point_clouds_all.size()<<endl;
                    TS(cere_optitesttesttesthh);
                    //构造优化问题
                    double t_array[optiKf_num][3];//平移数组，其中存放每个关键帧的平移向量
                    Quaterniond q_array[optiKf_num];
                    double euler_array[optiKf_num][3];

                    ceres::Problem problem;
                    ceres::Solver::Options options;
                    //options.linear_solver_type = ceres::DENSE_NORMAL_CHOLESKY;
                    options.linear_solver_type = ceres::DENSE_SCHUR;
                    //options.minimizer_progress_to_stdout = true;
                    options.max_num_iterations = 20;
                    ceres::Solver::Summary summary;
                    ceres::LossFunction *loss_function;
                    loss_function = new ceres::HuberLoss(1.0);
                    //AngleLocalParameterization类的主要作用是指定yaw角优化变量的迭代更新，重载了括号运算
                    ceres::LocalParameterization* angle_local_parameterization = AngleLocalParameterization::Create();

                    
                    Matrix3d curKF_r;
                    Vector3d curKF_t;
                    kf_3d->getOriginPose(curKF_t, curKF_r);
                    
                    
                    Matrix3d tmp_r_old;
                    Vector3d tmp_t_old;
                    t_array[0][0] = curKF_t(0);
                    t_array[0][1] = curKF_t(1);
                    t_array[0][2] = curKF_t(2);
                    //将矩阵转换为向量
                    Vector3d euler_angle_old = Utility::R2ypr(curKF_r);
                    euler_array[0][0] = euler_angle_old.x();
                    euler_array[0][1] = euler_angle_old.y();
                    euler_array[0][2] = euler_angle_old.z();
                    problem.AddParameterBlock(euler_array[0], 3);
                    problem.AddParameterBlock(t_array[0], 3);

                    
                    //再加一个根据当前帧与侯选帧之间的匹配关系，构造最开始的那个3d点 到候选帧的误差
                    map<int,int> resample;
                    
                    temp_index=0;
                    for(int len=vpkf_index.size(); temp_index<len; temp_index++ ){
                        
                        int kf_index=temp_index+1;
                        Matrix3d relative_r_b_a;
                        Vector3d relative_t_b_a;
                        relative_r_b_a=oldR_b_a[vpkf_index[temp_index]];
                        relative_t_b_a=oldT_b_a[vpkf_index[temp_index]];
                        Vector3d relative_r_b_a_euler=Utility::R2ypr(relative_r_b_a);
                        
                        
                        map<int,int>::iterator iter;
                        iter = resample.find(vpkf_index[temp_index]);
                        if(iter != resample.end())
                        {
                            kf_index=resample[vpkf_index[temp_index]];
                        }
                        else
                        {
                            resample[vpkf_index[temp_index]]=kf_index;

                            t_array[kf_index][0] = relative_t_b_a(0);
                            t_array[kf_index][1] = relative_t_b_a(1);
                            t_array[kf_index][2] = relative_t_b_a(2);
                            euler_array[kf_index][0] = relative_r_b_a_euler.x();
                            euler_array[kf_index][1] = relative_r_b_a_euler.y();
                            euler_array[kf_index][2] = relative_r_b_a_euler.z();
                            problem.AddParameterBlock(euler_array[kf_index], 1, angle_local_parameterization);
                            problem.AddParameterBlock(t_array[kf_index], 3);
                           
                            ceres::CostFunction* cost_function = FourSixDOFError::Create( relative_t_b_a(0),relative_t_b_a(1),relative_t_b_a(2),relative_r_b_a_euler(0),1);
                            problem.AddResidualBlock(cost_function, loss_function, euler_array[kf_index],t_array[kf_index]);
                            
                        }
                      

                        vector<Vector3d> point_single=point_clouds_all[temp_index];
                        vector<cv::Point2f> measure_single=measurements_old_norm_all[temp_index];
                        for(int a=0,b=point_single.size();a<b;a++){

                            //找到主地图那个点 所在帧的位姿
                            Vector3d pts_i = point_single[a];

                            //相机平面坐标
                            cv::Point2f pt=measure_single[a];

                            ceres::CostFunction* cost_function = FourSixDOFWeightError_reprojection_3::Create( pts_i.x(), pts_i.y(), pts_i.z(),pt.x, pt.y, tic_curClient[0], tic_curClient[1], tic_curClient[2], euler_angle_ric_main.x(), euler_angle_ric_main.y(), euler_angle_ric_main.z() ,relative_r_b_a_euler(1),relative_r_b_a_euler(2),100.0);
                            problem.AddResidualBlock(cost_function, loss_function, euler_array[0],t_array[0], euler_array[kf_index],t_array[kf_index]);
                            
                         }
                    }
                    
                    
                    ceres::Solve(options, &problem, &summary);
                    std::cout <<"全局-精确相对位姿："<<kf_3d->c->id<<" , "<< summary.BriefReport() << "\n";

                    if(summary.termination_type!=ceres::CONVERGENCE){
                        pCurrentMap->isFirstFusion_globalMutex.lock();
                        isFirstFusion[client_id_3d]-=1;
                        pCurrentMap->isFirstFusion_globalMutex.unlock();
                        return;}
                    TE(cere_optitesttesttesthh);
                }
            TE(testtesttesthh);
        }
        
    }else{
        
    
    
        //第二步-------------------------根据前面求得的粗糙的相对位姿求得准确的相对位姿--------重投影找匹配点---------------------------
        vector<vector<cv::Point2f>> measurements_old_norm_all;
        vector<vector<Eigen::Vector3d>> point_clouds_all;
        std::vector<cv::Point2f> measurements_old_coarse;//像素坐标
        std::vector<cv::Point2f> measurements_old_norm_coarse;//图像坐标
        std::vector<Vector3d> point_3d_cur;
        std::vector<cv::Point2f> measurements_cur;//像素坐标
        
        //这里就是假设所有的都是正的
        vector<KeyFrame*> vpCovKFi_old=kf_2d->GetBestCovisibilityKeyFrames(5);
        vpCovKFi_old.push_back(vpCovKFi_old[0]);
        vpCovKFi_old[0]=kf_2d;
        Matrix3d oldKF_r;
        Vector3d oldKF_t;
        kf_2d->getOriginPose(oldKF_t, oldKF_r);
            
        
            
        vector<Matrix3d> oldR_b_a;
        vector<Vector3d> oldT_b_a;
        int temp_index=0;
        //先算出来 在当前帧误差下，世界坐标系 到 侯选帧的共视帧的位姿关系
        for(KeyFrame* pkFi_old: vpCovKFi_old){
            if(temp_index!=0){
                Matrix3d rwi_old;
                Vector3d twi_old;
                pkFi_old->getOriginPose(twi_old, rwi_old);
                
                Matrix3d r_b_a;
                Vector3d t_b_a;
                r_b_a=oldKF_r.transpose()* rwi_old;
                t_b_a=oldKF_r.transpose()*(twi_old-oldKF_t);
                oldR_b_a.push_back(r_b_a);
                oldT_b_a.push_back(t_b_a);
            }else{
                oldR_b_a.push_back(Matrix3d::Identity());
                oldT_b_a.push_back(Vector3d::Zero());
                temp_index++;//放这里就只要执行一次
            }
        }
        
        int similarNum=0;
        temp_index=0;
        vector<Matrix3d> old_r;
        vector<Vector3d> old_t;
        vector<int> vpkf_index;
        
        
        Matrix3d R_relative;
        Vector3d T_relative;
       
        vector<int> clientId=kf_3d->clientId;
        vector<int> kfId=kf_3d->kfId;
        vector<std::pair<Matrix3d , Vector3d >  > relativePose=kf_3d->relativePose;
        int client_matchId=kf_2d->c->id, kf2d_global_index=kf_2d->global_index;//这里表示主地图的意思，后面肯定要改
        for(int i=0, len=clientId.size();i<len;i++){
            if(clientId[i]==client_matchId && kfId[i]==kf2d_global_index){
                R_relative=relativePose[i].first;
                T_relative=relativePose[i].second;
            }
        }
       
        
        Client* client_cur=kf_2d->c;
        Matrix3d ric_curClient=client_cur->ric_client;
        Vector3d tic_curClient=client_cur->tic_client;
        Vector3d euler_angle_ric_main=Utility::R2ypr(ric_curClient);
        const float &fx = client_cur->FOCUS_LENGTH_X_server;
        const float &fy = client_cur->FOCUS_LENGTH_Y_server;
        const float &cx = client_cur->PX_server;
        const float &cy = client_cur->PY_server;
        
        
            
        for(KeyFrame* pkf_old:vpCovKFi_old){
            Matrix3d r_w_imuOld=R_relative*oldR_b_a[temp_index];
            Vector3d t_w_imuOld=R_relative*oldT_b_a[temp_index] +T_relative;
            Matrix3d r_w_camOld=r_w_imuOld*ric_curClient;
            Vector3d t_w_camOld=r_w_imuOld*tic_curClient+t_w_imuOld;
            Matrix3d r_camOld_w=r_w_camOld.transpose();
            old_r.push_back(r_camOld_w);
            old_t.push_back(-r_camOld_w*t_w_camOld);
            temp_index++;
            
        }
        
        while(!kf_3d->IsOriginUpdate){
            usleep(50);
        }
        std::vector<KeyFrame*> vpCovKFi_cur = kf_3d->GetBestCovisibilityKeyFrames(5);
        vpCovKFi_cur.push_back(vpCovKFi_cur[0]);
        vpCovKFi_cur[0] = kf_3d;
        
        
        {
            //当前帧的共视帧 与 侯选帧的2级共视帧的匹配，通过重投影找
            
            point_clouds_all.clear();
            measurements_old_norm_all.clear();
            vpkf_index.clear();
            for(KeyFrame* pKFi : vpCovKFi_cur){

                //描述符得全有
                if(!pKFi->is_des_end){
                    continue;
                }
                
                vector<Eigen::Vector3d> point_clouds_origin_cur= pKFi->point_clouds_origin;
                std::vector<cv::Point2f> measurements_origin_cur=pKFi->measurements_origin;
                vector<cv::KeyPoint> keypoints_cur=pKFi->keypoints;
                int nPoints = point_clouds_origin_cur.size();
                int point2D_len_cur=keypoints_cur.size()-point_clouds_origin_cur.size();
               
    //                int num=0;//记录匹配点的数量
                temp_index=0;//记录遍历到哪个帧了
                //这里应该遍历候选帧的共视帧 ，只要共视点数量超过一定阈值 22
                for(KeyFrame* pkFi_old: vpCovKFi_old)
                {
                    

                    //描述符得全有
                    if(!pkFi_old->is_des_end){
                        temp_index++;
                        continue;
                    }
                    
                    measurements_old_coarse.clear();
                    measurements_old_norm_coarse.clear();
                    point_3d_cur.clear();
                    measurements_cur.clear();
                
                    vector<cv::KeyPoint> keypoints_old=pkFi_old->keypoints;

                    //这个得到的是到imu坐标系的位姿
                    Matrix3d r_camOld_w=old_r[temp_index];
                    Vector3d t_camOld_w=old_t[temp_index];
                    
                    for(int i=0;i<nPoints;i++){
                        Vector3d point_main=point_clouds_origin_cur[i];
                        //把主地图下 世界坐标系的点 转到小地图上一帧的图像坐标系上
                        Vector3d p3D_c2=r_camOld_w*point_main+t_camOld_w;
                        //深度必须为正
                        if(p3D_c2[2]<0.0 || p3D_c2[2]>30.0){
    //                            cout<<"深度不为正"<<endl;
                            continue;
                        }
                        // 投影到图像上
                        double x = p3D_c2[0];
                        double y = p3D_c2[1];
                        double z = p3D_c2[2];
                        //这里可能得加一个畸变校正 应该可以不用去校正 把他投影在一个没有畸变的图像上
                        double u=fx*x/z+cx;
                        double v=fy*y/z+cy;
                      
                        
                        if(!pkFi_old->isInImage((float)u, (float)v)){
    //                            cout<<"投影点不在图像内"<<endl;
                            continue;
                        }
                        
                        const vector<int> vIndices=pkFi_old->GetFeaturesInArea_1((float)u, (float)v, 20);
                        //这里可以改为30个像素里面找不到 再扩大到50个像素 暂时未做
                        if(vIndices.empty()){
    //                            cout<<"半径为20个像素 找不到点"<<endl;
                            continue;
                        }
                        //des和keypoints长度不一样
                        //找在这个半径内最相似的 这里可能有些问题 因为3D点的描述子 个人感觉有问题
                        BRIEF::bitset point_main_des=pKFi->descriptors[point2D_len_cur+i];
                        int bestDist = 256;
                        int bestIndex = -1;
                        for(vector<int>::const_iterator vit=vIndices.begin(), vit_end=vIndices.end(); vit!=vit_end; vit++)
                        {
        //                    cout<<"*vit"<<*vit<<endl;发现 keypoints数量不等于des数量
                            int dis = pkFi_old->HammingDis(point_main_des, pkFi_old->descriptors[*vit]);
                            if(dis < bestDist)
                            {
                                bestDist = dis;
                                bestIndex = *vit;
                            }
                        }
                        
                        if(bestDist<70){
    //                                cout<<"最终选择的半径范围："<<u-keypoints_old[bestIndex].pt.x<<" ,"<<v-keypoints_old[bestIndex].pt.y<<endl;
                            point_3d_cur.push_back(point_main);
                            measurements_old_coarse.push_back(keypoints_old[bestIndex].pt);
                            measurements_cur.push_back(measurements_origin_cur[i]);
                            
                        }
                                    
                    }
                    
    //                        cout<<"50个像素内,找到的点数："<<measurements_cur.size()<<endl;
                    if(measurements_cur.size()>=22){
                        pKFi->rejectWithF_server_mapFuse(measurements_cur, measurements_old_coarse,point_3d_cur);
    //                            cout<<"f矩阵拒绝后的点数："<<measurements_cur.size()<<", "<<pKFi->global_index<<" ,"<<pkFi_old->global_index<<endl;
                        if(measurements_old_coarse.size()>16){
                        
                            cv::Point2f norm_pt;
                            int pCount=measurements_old_coarse.size();
                            for(int aa=0;aa<pCount;aa++){
                                norm_pt.x = (measurements_old_coarse[aa].x -  client_cur->PX_server)/ client_cur->FOCUS_LENGTH_X_server;
                                norm_pt.y = (measurements_old_coarse[aa].y -  client_cur->PY_server)/ client_cur->FOCUS_LENGTH_Y_server;
                                measurements_old_coarse[aa]=norm_pt;
                                
                            }
                            
                            point_clouds_all.push_back(point_3d_cur);
                            measurements_old_norm_all.push_back(measurements_old_coarse);

                            vpkf_index.push_back(temp_index);
                            similarNum++;
                            

                        }
                        
                    }
                    
                    temp_index++;
                }
            }
        }

        PoseGraph* pCurrentMap;
        int client_id_3d,client_id_2d,otherKF_global_index,curKF_global_index;
    //    if(noMain==1){
            pCurrentMap=pg_3d;
            client_id_3d=kf_3d->c->id;
            client_id_2d=kf_2d->c->id;
            otherKF_global_index=kf_2d->global_index;
            curKF_global_index=kf_3d->global_index;
    //    }
    //    else{
    //        pCurrentMap=pg_2d;
    //        client_id_3d=kf_2d->c->id;
    //        client_id_2d=kf_2d->c->id;
    //        mainKF_global_index=kf_3d->global_index;
    //        curKF_global_index=kf_2d->global_index;
    //    }
        
            if(similarNum>=2){
                int optiKf_num=vpkf_index.size()+2;
                //构造优化问题
                double t_array[optiKf_num][3];//平移数组，其中存放每个关键帧的平移向量
                Quaterniond q_array[optiKf_num];
                double euler_array[optiKf_num][3];

                ceres::Problem problem;
                ceres::Solver::Options options;
                //options.linear_solver_type = ceres::DENSE_NORMAL_CHOLESKY;
                options.linear_solver_type = ceres::DENSE_SCHUR;
                //options.minimizer_progress_to_stdout = true;
                options.max_num_iterations = 20;
                ceres::Solver::Summary summary;
                ceres::LossFunction *loss_function;
                loss_function = new ceres::HuberLoss(1.0);
                //AngleLocalParameterization类的主要作用是指定yaw角优化变量的迭代更新，重载了括号运算
                ceres::LocalParameterization* angle_local_parameterization = AngleLocalParameterization::Create();

                
                Matrix3d curKF_r;
                Vector3d curKF_t;
                kf_3d->getOriginPose(curKF_t, curKF_r);
                
                
                Matrix3d tmp_r_old;
                Vector3d tmp_t_old;
                t_array[0][0] = curKF_t(0);
                t_array[0][1] = curKF_t(1);
                t_array[0][2] = curKF_t(2);
                //将矩阵转换为向量
                Vector3d euler_angle_old = Utility::R2ypr(curKF_r);
                euler_array[0][0] = euler_angle_old.x();
                euler_array[0][1] = euler_angle_old.y();
                euler_array[0][2] = euler_angle_old.z();
                problem.AddParameterBlock(euler_array[0], 3);
                problem.AddParameterBlock(t_array[0], 3);

                
                //再加一个根据当前帧与侯选帧之间的匹配关系，构造最开始的那个3d点 到候选帧的误差
                map<int,int> resample;
                
                temp_index=0;
                for(int len=vpkf_index.size(); temp_index<len; temp_index++ ){
                    
                    int kf_index=temp_index+1;
                    Matrix3d relative_r_b_a;
                    Vector3d relative_t_b_a;
                    relative_r_b_a=oldR_b_a[vpkf_index[temp_index]];
                    relative_t_b_a=oldT_b_a[vpkf_index[temp_index]];
                    Vector3d relative_r_b_a_euler=Utility::R2ypr(relative_r_b_a);
                    
                    
                    map<int,int>::iterator iter;
                    iter = resample.find(vpkf_index[temp_index]);
                    if(iter != resample.end())
                    {
                        kf_index=resample[vpkf_index[temp_index]];
                    }
                    else
                    {
                        resample[vpkf_index[temp_index]]=kf_index;

                        t_array[kf_index][0] = relative_t_b_a(0);
                        t_array[kf_index][1] = relative_t_b_a(1);
                        t_array[kf_index][2] = relative_t_b_a(2);
                        euler_array[kf_index][0] = relative_r_b_a_euler.x();
                        euler_array[kf_index][1] = relative_r_b_a_euler.y();
                        euler_array[kf_index][2] = relative_r_b_a_euler.z();
                        problem.AddParameterBlock(euler_array[kf_index], 1, angle_local_parameterization);
                        problem.AddParameterBlock(t_array[kf_index], 3);
                       
                        ceres::CostFunction* cost_function = FourSixDOFError::Create( relative_t_b_a(0),relative_t_b_a(1),relative_t_b_a(2),relative_r_b_a_euler(0),1);
                        problem.AddResidualBlock(cost_function, loss_function, euler_array[kf_index],t_array[kf_index]);
                        
                    }
                  

                    vector<Vector3d> point_single=point_clouds_all[temp_index];
                    vector<cv::Point2f> measure_single=measurements_old_norm_all[temp_index];
                    for(int a=0,b=point_single.size();a<b;a++){

                        //找到主地图那个点 所在帧的位姿
                        Vector3d pts_i = point_single[a];

                        //相机平面坐标
                        cv::Point2f pt=measure_single[a];

                        ceres::CostFunction* cost_function = FourSixDOFWeightError_reprojection_3::Create( pts_i.x(), pts_i.y(), pts_i.z(),pt.x, pt.y, tic_curClient[0], tic_curClient[1], tic_curClient[2], euler_angle_ric_main.x(), euler_angle_ric_main.y(), euler_angle_ric_main.z() ,relative_r_b_a_euler(1),relative_r_b_a_euler(2),100.0);
                        problem.AddResidualBlock(cost_function, loss_function, euler_array[0],t_array[0], euler_array[kf_index],t_array[kf_index]);
                        
                     }
                }
                
                
                ceres::Solve(options, &problem, &summary);
                std::cout <<"全局-精确相对位姿："<<kf_3d->c->id<<" , "<< summary.BriefReport() << "\n";

                if(summary.termination_type!=ceres::CONVERGENCE){
                    pCurrentMap->isFirstFusion_globalMutex.lock();
                    isFirstFusion[client_id_3d]-=1;
                    pCurrentMap->isFirstFusion_globalMutex.unlock();
                    return;}
                
                pg_3d->globalLoop_mutex.lock();
                pg_3d->vpkf_index.push_back(vpkf_index);
                pg_3d->measurements_old_norm_all.push_back(measurements_old_norm_all);
                pg_3d->point_clouds_all.push_back(point_clouds_all);
                pg_3d->vpCovKFi_old_2d.push_back(vpCovKFi_old);
                pg_3d->vpCovKFi_cur_3d.push_back(vpCovKFi_cur);
                pg_3d->curGlobalLoopKf_id.push_back(kf_3d_id);
                pg_3d->oldGlobalLoopKf_id.push_back(kf_2d_id);
                pg_3d->oldAgent_id_forLoopKf.push_back(agent_2d_id);
                pg_3d->globalLoop_mutex.unlock();
                
                Matrix3d Rs_i ;
                Vector3d Ps_i ;//当前帧
                kf_3d->getOriginPose(Ps_i, Rs_i);
                



                Vector3d q;
                q<<euler_array[0][0],euler_array[0][1],euler_array[0][2];
                Matrix3d Rs_loop = Utility::ypr2R(q);
                Vector3d Ps_loop = Vector3d( t_array[0][0],  t_array[0][1],  t_array[0][2]);

    //求得的是3d到2d的关系
                Vector3d relative_t = Rs_loop.transpose() * (Ps_i - Ps_loop);
    //                Matrix3d relative_q = Rs_loop.transpose() * Rs_i;
                double relative_yaw = Utility::normalizeAngle(Utility::R2ypr(Rs_i).x() - Utility::R2ypr(Rs_loop).x());
                double relative_pitch = Utility::normalizeAngle(Utility::R2ypr(Rs_i).y() - Utility::R2ypr(Rs_loop).y());
                double relative_roll = Utility::normalizeAngle(Utility::R2ypr(Rs_i).z() - Utility::R2ypr(Rs_loop).z());
    //            Quaterniond rela_q=Quaterniond(relative_q);
                
                Quaterniond rs_loop_q=Quaterniond(Rs_loop),rs_i_q=Quaterniond(Rs_i);
                Quaterniond rela_q=rs_loop_q.inverse()*rs_i_q;
    //测试
    //            Quaterniond tmp_q,tmp_i;
    //            tmp_q=Rs_loop;
    //            tmp_i=Rs_i;
    //            double w_q_i[4],i_q_w[4],t_w_ij[3],t_i_ij[3];
    //            w_q_i[0]=tmp_q.w();
    //            w_q_i[1]=tmp_q.x();
    //            w_q_i[2]=tmp_q.y();
    //            w_q_i[3]=tmp_q.z();
    //            QuaternionInverse(w_q_i, i_q_w);
    //            t_w_ij[0]=Ps_i[0] - Ps_loop[0];
    //            t_w_ij[1]=Ps_i[1] - Ps_loop[1];
    //            t_w_ij[2]=Ps_i[2] - Ps_loop[2];
    //            ceres::QuaternionRotatePoint(i_q_w, t_w_ij, t_i_ij);
    ////            cout<<"relative_t"<<relative_t.x()<<" , "<<relative_t.y()<<" , "<<relative_t.z()<<endl;
    ////            cout<<"t_i_ij="<<t_i_ij[0]<<" , "<<t_i_ij[1]<<" , "<<t_i_ij[2]<<endl;
    //
    //            double w_q_j[4],q_i_j[4];
    //            w_q_j[0]=tmp_i.w();
    //            w_q_j[1]=tmp_i.x();
    //            w_q_j[2]=tmp_i.y();
    //            w_q_j[3]=tmp_i.z();
    //            ceres::QuaternionProduct(i_q_w, w_q_j, q_i_j);
    ////            cout<<"rela_q"<<rela_q.w()<<" , "<<rela_q.x()<<" , "<<rela_q.y()<<" , "<<rela_q.z()<<endl;
    ////            cout<<"q_i_j"<<q_i_j[0]<<" , "<<q_i_j[1]<<" , "<<q_i_j[2]<<" , "<<q_i_j[3]<<endl;
    //
    //            if(fabs(rela_q.x()-q_i_j[1])>0.000001 || fabs(rela_q.y()-q_i_j[2])>0.000001 ||fabs(rela_q.z()-q_i_j[3])>0.000001 ){
    ////                cout<<"rela_q"<<rela_q.w()<<" , "<<rela_q.x()<<" , "<<rela_q.y()<<" , "<<rela_q.z()<<endl;
    ////                cout<<"q_i_j"<<q_i_j[0]<<" , "<<q_i_j[1]<<" , "<<q_i_j[2]<<" , "<<q_i_j[3]<<endl;
    //                cout<<"数据不规范"<<endl;
    //                pCurrentMap->isFirstFusion_globalMutex.lock();
    //
    //                isFirstFusion[client_id_3d]-=1;
    //                pCurrentMap->isFirstFusion_globalMutex.unlock();
    //                return;
    //            }
                //实验记录
    //            std::ofstream outFile;
    //            //打开文件
    //            outFile.open("/Users/zhangjianhua/Desktop/hh/VINS_MapFusion/VINS_MapFusion/data/"+
    //                             to_string(kf_3d->global_index)+"&"+to_string(kf_3d->header)+"&"+to_string(kf_2d->global_index)+"&"+to_string(kf_2d->header)+".txt");
    //            outFile.setf(ios::fixed, ios::floatfield);  // 设定为 fixed 模式，以小数点表示浮点数
    //            outFile.precision(19);
    //                //写入数据
    ////                outFile <<"测试是否存在误匹配，当前client.id:\n"<<kf_3d->c->id<<"\n当作帧的header:\n"<<kf_3d->header<<"\n当作帧的global_index:\n"<<kf_3d->global_index<<"\n2d帧的client.id:\n"<<kf_2d->c->id <<"\n2d帧的header:\n"<<kf_2d->header<<"\n2d帧的global_index:\n"<<kf_2d->global_index  <<"\n3d-2d的r:\n"<<rela_q<<"\n3d-2d的t\n"<<relative_t;
    //            outFile <<kf_3d->c->id<<"\n"<<kf_3d->header<<"\n"<<kf_3d->global_index<<"\n"<<kf_2d->c->id <<"\n"<<kf_2d->header<<"\n"<<kf_2d->global_index  <<"\n"<<rela_q.x()<<"\n"<<rela_q.y()<<"\n"<<rela_q.z()<<"\n"<<rela_q.w()<<"\n"<<relative_t[0]<<"\n"<<relative_t[1]<<"\n"<<relative_t[2];
    //                //关闭文件
    //            outFile.close();
                Eigen::Matrix<double, 8, 1> connected_info;
                connected_info <<relative_t.x(), relative_t.y(), relative_t.z(),
                rela_q.w(), rela_q.x(), rela_q.y(), rela_q.z(),
                relative_yaw;
    //            for(int i=0, len=clientId.size();i<len;i++){
    //                if(clientId[i]==client_matchId && kfId[i]==kf2d_global_index){
                        kf_3d->relative_global_loop_info_multiClient.push_back(connected_info);
    //                }
    //            }
                
    //            实验 开始
    //            cout<<"回环："<<pg_2d->c->getId()<<" ,"<<pg_3d->c->getId()<<endl;
                bool isFuse=pg_3d->fuseClientId[pg_2d->c->getId()];
    //            cout<<"isFuse= "<<isFuse<<" , "<<pg_2d->c->getId()<<endl;
                if(!isFuse){
                    cout<<"回环："<<pg_2d->c->getId()<<" , "<<pg_3d->c->getId()<<endl;
                    cout<<"回环kfid："<<kf_2d->global_index<<" , "<<kf_3d->global_index<<endl;
    //                是第一次融合
                    pg_3d->fuseClientId[pg_2d->c->getId()]=true;
                    Matrix3d r_w2_j;
                    Vector3d t_w2_j;
                    kf_2d->getOriginPose(t_w2_j, r_w2_j);
                    pg_3d->fromI2OtherClient_r[pg_2d->c->getId()]=r_w2_j*Rs_loop.transpose();
                    pg_3d->fromI2OtherClient_t[pg_2d->c->getId()]=-pg_3d->fromI2OtherClient_r[pg_2d->c->getId()]*Ps_loop+t_w2_j;
                    
    //                cout<<"赋值1："<<pg_2d->c->getId()<<" , " <<pg_3d->fromI2OtherClient_t[pg_2d->c->getId()] <<" , "<<pg_3d->fromI2OtherClient_r[pg_2d->c->getId()] <<endl;
                }
                isFuse=pg_2d->fuseClientId[pg_3d->c->getId()];
    //            cout<<isFuse<<endl;
                if(!isFuse){
    //                是第一次融合
                    pg_2d->fuseClientId[pg_3d->c->getId()]=true;
                    Matrix3d r_w1_j;
                    Vector3d t_w1_j;
                    kf_3d->getOriginPose(t_w1_j, r_w1_j);
                    pg_2d->fromI2OtherClient_r[pg_3d->c->getId()]=Rs_loop* r_w1_j.transpose();
                    pg_2d->fromI2OtherClient_t[pg_3d->c->getId()]=-pg_2d->fromI2OtherClient_r[pg_3d->c->getId()]*t_w1_j+ Ps_loop;
    //                cout<<"赋值2："<<pg_3d->c->getId()<<" , " <<pg_2d->fromI2OtherClient_t[pg_3d->c->getId()] <<" , "<<pg_2d->fromI2OtherClient_r[pg_3d->c->getId()] <<endl;
                }
    //实验 end
                
                
            
            
    //            这个是触发全局优化 之前是设置的其它地图，默认是和主地图优化
    //            现在 设置成3d地图
    //            加一个读写锁 只这里一次赋值 用来判断 是否和其它地图发生了融合 最终做什么样的优化
            pCurrentMap->readWriteLock_is_fusion_mutex.writeLock();
            pCurrentMap->is_fusion=1;
            pCurrentMap->readWriteLock_is_fusion_mutex.writeUnLock();
                
            pCurrentMap->isFirstFusion_globalMutex.lock();
           //找到了
            isFirstFusion[client_id_3d]-=1;
            //思考一下赋值 加锁
            int latest_index_cur_test=latest_globalLoop_index[client_id_3d];
            latest_index_cur_test=latest_index_cur_test>curKF_global_index?latest_index_cur_test:curKF_global_index;
            latest_globalLoop_index[client_id_3d]=latest_index_cur_test;
            if(earliest_globalLoop_index[client_id_3d]==-1 || earliest_globalLoop_index[client_id_3d]>curKF_global_index){
                earliest_globalLoop_index[client_id_3d]=curKF_global_index;
            }
            pCurrentMap->isFirstFusion_globalMutex.unlock();
                
            pg_2d->isFirstFusion_globalMutex.lock();
            //思考一下赋值 加锁
            int latest_index_other_test=latest_globalLoop_index[client_id_2d];
            latest_index_other_test=latest_index_other_test>otherKF_global_index?latest_index_other_test:otherKF_global_index;
            latest_globalLoop_index[client_id_2d]=latest_index_other_test;//目前唯一赋值的地方
            //记录主地图和其它地图最早的融合位置
            if(earliest_globalLoop_index[client_id_2d]==-1 || earliest_globalLoop_index[client_id_2d]>otherKF_global_index){
                earliest_globalLoop_index[client_id_2d]=otherKF_global_index;
            }
            pg_2d->isFirstFusion_globalMutex.unlock();
                
            kf_3d->update_globalLoopConnection(relative_t, rela_q, relative_yaw);
            kf_3d->global_relative_pitch=relative_pitch;
            kf_3d->global_relative_roll=relative_roll;
            kf_3d->detect_globalLoop(kf_2d->global_index);
            kf_2d->is_detected_globalLoop(kf_3d->global_index);
                    
            if( ! uf.isConnected(client_id_3d, client_id_2d)){
                uf.connect(client_id_3d, client_id_2d);
            }
            
            pCurrentMap->start_global_fuse_opti_mutex.lock();
            pCurrentMap->start_global_fuse_opti=1;
            pCurrentMap->start_global_fuse_opti_mutex.unlock();

                
    //            子地图实验 拿到和其它地图最相似的一帧，找对应的子地图进行融合-----------------------
//                global_featureMap->allocateSubMap_multi(kf_3d, kf_2d);
                
    //                    ------实验 记录能和哪些帧匹配 id header 是哪个地图的------
    //        std::ofstream outFile;
    //        outFile.setf(ios::fixed, ios::floatfield);  // 设定为 fixed 模式，以小数点表示浮点数
    //        outFile.precision(16);  // 设置精度 2
    //        //打开文件
    //        outFile.open("/Users/zhangjianhua/Desktop/VINS_MapFusion/VINS_MapFusion/data/loop_old/"+ to_string(kf_3d->c->getId())+"&"+
    //                     to_string(kf_3d->global_index)+"&"+to_string(kf_3d->header)+"&"+to_string(kf_2d->c->getId())+"&"+to_string(kf_2d->global_index)+"&"+to_string(kf_2d->header)+".txt");
    //                //写入数据
    //        outFile << kf_3d->c->getId()<<" "<<kf_3d->global_index<<" "<<kf_3d->header<<"\n" <<kf_2d->c->getId()<<" "<<kf_2d->global_index<<" "<<kf_2d->header;
    //
    //        outFile<<"\n";
    //        //关闭文件
    //        outFile.close();
    //                    ------实验 子地图 记录能和哪些帧匹配 id header------
                
//                std::ofstream outFile;
//                outFile.setf(ios::fixed, ios::floatfield);  // 设定为 fixed 模式，以小数点表示浮点数
//                outFile.precision(16);  // 设置精度
//                outFile.open("/Users/zhangjianhua/Desktop/VINS_MapFusion/VINS_MapFusion/data/loop_subMap/"+ to_string(kf_3d->c->getId())+"&"+
//                             to_string(kf_3d->global_index)+"&"+to_string(kf_2d->c->getId())+"&"+to_string(kf_2d->global_index)+".txt");
//                        //写入数据
//                outFile << kf_3d->c->getId()<<" "<<kf_3d->global_index<<" "<<kf_3d->header<<"\n" <<kf_2d->c->getId()<<" "<<kf_2d->global_index<<" "<<kf_2d->header;
//
//                outFile<<"\n";
//                //关闭文件
//                outFile.close();
    //                    ------实验 end 子地图 记录能和哪些帧匹配 id header------
        }
        else{
            cout<<"全局匹配帧数不够="<<similarNum<<endl;
            pCurrentMap->isFirstFusion_globalMutex.lock();

            isFirstFusion[client_id_3d]-=1;
            pCurrentMap->isFirstFusion_globalMutex.unlock();
        }
    }
    TE(realMergeLocal_19_if);
}
//基于8的基础改的
//第三篇论文
//这个i 代表的是此次回环触发 的3d点 所在地图id 即新增地图
//后面改改，还是应该用老帧 做3d点 因为误差小一些
// 虽然是多个地图融合，但是我们是转到一个世界坐标系 我们选择参与优化的clientid最小的
//这里是多个地图联合优化 位姿稍微变差了一点点
void PoseGraphGlobal::GlobalFuse_9(int i){
    cout<<"最终的全局优化"<<i<<endl;
    bool isUpdateFusionDraw=false;
//    cout<<"死锁没"<<endl;
    //因为现在写的都是和主地图发生地图融合 所以其中一个地图直接这么获取了
//    poseGraphGlobal_mutex.lock();
    readWriteLock.readLock();
    map<int,PoseGraph*>::iterator iter_map = PoseGraphGloabl_map.find(i);
    if(iter_map==PoseGraphGloabl_map.end())
    {
//        poseGraphGlobal_mutex.unlock();
        readWriteLock.readUnLock();
        assert(false);//都已经发生回环了，却找不到地图 说明数据插错
    }
    PoseGraph* pAddKfMap= iter_map->second;
    int len = PoseGraphGloabl_map.size();
    readWriteLock.readUnLock();
    
    vector<std::unique_lock<std::mutex>* > lock_all;
    std::unique_lock<std::mutex> lock(pAddKfMap->keyFrameList_global_fusion_mutex, std::defer_lock);
    if (lock.try_lock()) {
        cout<<"加锁："<<pAddKfMap->c->id<<endl;
        lock_all.push_back(&lock);
    } else {
        cout<<"最终的全局优化中断"<<i<<endl;
        return;
    }
    if(i==mainClientID){
        isUpdateFusionDraw=true;
    }

//    TODO 用来多用户ar 发送ar位姿的
    pAddKfMap->isFirstFusion_globalMutex.lock();
    isFusion[i]=1;
    pAddKfMap->isFirstFusion_globalMutex.unlock();
    
    double total_lenth_other=0.0;
    vector< double> length_other;
    PoseGraph* pMainMap;//id最小的
    vector<PoseGraph *> vMap_all;//除id最小,也就是匹配上的全部其它地图
    map<int,int> vMapId_all;//int表示clientId 后面表示存放在vMap_all的下标
    //找其它融合的地图 一起参与优化
    bool isFindMinClient=true;
    readWriteLock.readLock();
    if(PoseGraphGloabl_map.size()>1){
        readWriteLock.readUnLock();
        for(int client_id=0;client_id<len;client_id++){//这里的i其实代表的就是 ClientId
            if(client_id==i){
                continue;
            }
            if(uf.isConnected(i, client_id)){
                readWriteLock.readLock();
                map<int,PoseGraph*>::iterator iter_map_other = PoseGraphGloabl_map.find(client_id);
                if(iter_map_other==PoseGraphGloabl_map.end()){
                    readWriteLock.readUnLock();
                    continue;
                }
                PoseGraph* pOtherMap= iter_map_other->second;//新的地图 小的地图
                readWriteLock.readUnLock();
                
                
                
//                cout <<"锁定"<< pOtherMap->c->id<<endl;
                std::unique_lock<std::mutex> lock(pOtherMap->keyFrameList_global_fusion_mutex, std::defer_lock);
                if (lock.try_lock()) {
                    cout<<"加锁："<<pOtherMap->c->id<<endl;
                    lock_all.push_back(&lock);
                } else {
                    //                    把之前锁住了的解锁了
                    cout<<"最终的全局优化中断"<<pOtherMap->c->id<<endl;
//                    for(int flag_start=0,flag_end=lock_all.size();flag_start<flag_end;flag_start++){
//                        cout<<"解锁："<<flag_start<<endl;
//                        (lock_all[flag_start])->unlock();
//                    }
                    return;
                }
         
                
                if(isFindMinClient){
                    isFindMinClient=false;
                    if(i>client_id){
//                        这里就是id最小的地图
                        pMainMap=pOtherMap;
//                        cout<<"主地图大小："<<pMainMap->size()<<endl;
                      
                        vMap_all.push_back(pAddKfMap);
                        vMapId_all.insert(make_pair(pAddKfMap->c->id,vMap_all.size()-1));
                        total_lenth_other+=pAddKfMap->total_length;
                        length_other.push_back(pAddKfMap->total_length);
                        
                        if(client_id==mainClientID){
                            isUpdateFusionDraw=true;
                        }
                        continue;
                    }else{
                        pMainMap=pAddKfMap;
                    }
                }
                vMap_all.push_back(pOtherMap);
                vMapId_all.insert(make_pair(pOtherMap->c->id,vMap_all.size()-1));
                
                total_lenth_other+=pOtherMap->total_length;
                length_other.push_back(pOtherMap->total_length);
                
            }
            
        }
    }
    else{
        readWriteLock.readUnLock();
        assert(false);//都要发生全局优化了 却只有1个地图
    }
    
   
    
    //主地图从earliest_loop_index_main开始--当前帧结束
    //小地图从第一帧开始--当前发生回环的帧 这个有可能是回环帧，也有可能是融合帧
    ceres::Problem problem;
    ceres::Solver::Options options;
    //options.linear_solver_type = ceres::DENSE_NORMAL_CHOLESKY;
    options.linear_solver_type = ceres::DENSE_SCHUR;
    options.minimizer_progress_to_stdout = false;
    options.max_num_iterations = 6;
    ceres::Solver::Summary summary;
    ceres::LossFunction *loss_function;
    loss_function = new ceres::HuberLoss(1.0);
    //AngleLocalParameterization类的主要作用是指定yaw角优化变量的迭代更新，重载了括号运算
    ceres::LocalParameterization* angle_local_parameterization =
    AngleLocalParameterization::Create();
            
    
    double total_lenth_main=pMainMap->total_length;
    //总的位姿长度 除以总的帧数
    double total_lenth_sum=total_lenth_main+total_lenth_other;
    int max_frame_num_global_main=(total_lenth_main/total_lenth_sum)*max_frame_num_global;
    double min_dis_main=total_lenth_main/max_frame_num_global_main;
    
    //要优化的变量的最大个数 主地图
    int max_length_main=pMainMap->size()+1;
    double t_array_main[max_length_main][3];//平移数组，其中存放每个关键帧的平移向量
    Quaterniond q_array_main[max_length_main];
    double euler_array_main[max_length_main][3];
    vector<bool> need_resample_main;
    
    pMainMap->max_frame_num_global=max_frame_num_global_main;
    pMainMap->min_dis=min_dis_main;
    

    const int mapOther_sum=vMap_all.size();
    vector< double** > t_other_all;
    vector< vector<Quaterniond > > q_other_all;
    vector< double** > euler_other_all;
    vector< vector<bool> > resample_other_all;
    
    int earliest_loop_index_main=pMainMap->earliest_loop_index;
    int earliest_global_looped_index_main=earliest_globalLoop_index[pMainMap->c->id];
    if (earliest_loop_index_main > earliest_global_looped_index_main || earliest_loop_index_main == -1  )
        earliest_loop_index_main=earliest_global_looped_index_main;
    
    int latest_loop_index_main=pMainMap->latest_loop_index;
    int latest_global_looped_index_main=latest_globalLoop_index[pMainMap->c->id];
    if (latest_global_looped_index_main > latest_loop_index_main)
        latest_loop_index_main=latest_global_looped_index_main;
//    pMainMap->loop_index_multiClient.push(earliest_loop_index_main);
//    pMainMap->curKF_loop_index_multiClient.push(latest_loop_index_main);//这个是要发回客户端 用来更新位姿的 TODO 后面要改改
    
    vector<int> earliest_loopIndex_other_all;
    vector<int> latest_loopIndex_other_all;
    
    vector<int> latest_loop_index_other_update;
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
        
        int earliest_loop_index_other=pMap_other->earliest_loop_index;
        int earliest_global_looped_index_other=earliest_globalLoop_index[pMap_other->c->id];
        if (earliest_loop_index_other > earliest_global_looped_index_other || earliest_loop_index_other == -1  )
            earliest_loop_index_other=earliest_global_looped_index_other;
        earliest_loopIndex_other_all.push_back(earliest_loop_index_other);
        
        int latest_loop_index_other=pMap_other->latest_loop_index;
        int latest_global_looped_index_other=latest_globalLoop_index[pMap_other->c->id];
        if (latest_global_looped_index_other > latest_loop_index_other)
            latest_loop_index_other=latest_global_looped_index_other;
        latest_loopIndex_other_all.push_back(latest_loop_index_other);
        
//        pMap_other->isFirstFusion_globalMutex.lock();
//        pMap_other->loop_index_multiClient.push(0);
//        pMap_other->curKF_loop_index_multiClient.push(latest_loop_index_other);
//        pMap_other->isFirstFusion_globalMutex.unlock();
        latest_loop_index_other_update.push_back(latest_loop_index_other);
        
        double total_length_otherMap=length_other[flag_start];
        int max_frame_num_global_other=(total_length_otherMap/total_lenth_sum)*max_frame_num_global;
        double min_dis_other=total_length_otherMap/max_frame_num_global_other;
        pMap_other->max_frame_num_global=max_frame_num_global_other;
        pMap_other->min_dis=min_dis_other;
        
        //要优化的变量的最大个数 小地图
        int max_length_other=pMap_other->keyFrameList.size()+1;
        double** t_test=new double*[max_length_other];
        for(int index_flag=0;index_flag<max_length_other;index_flag++) t_test[index_flag] = new double[3];
        t_other_all.push_back(t_test);
        
        vector<Quaterniond > q_array_other(max_length_other);
        q_other_all.push_back(q_array_other);
        
        double** euler_test=new double*[max_length_other];
        for(int index_flag=0;index_flag<max_length_other;index_flag++) euler_test[index_flag] = new double[3];
        euler_other_all.push_back(euler_test);
        
        vector<bool> need_resample_other;
        resample_other_all.push_back(need_resample_other);
    }
   
    

    vector<int> special_kf_inOpti_main;
    vector<int> kf_id_hasComPlace_main;
    //遍历关键帧列表
    list<KeyFrame*>::iterator it_main = pMainMap->keyFrameList.begin();
    Vector3d last_P_main = Vector3d(0, 0, 0);
    double dis_main = 0;
    int resample_id=0;
    for(;it_main!=pMainMap->keyFrameList.end();it_main++){
        if((*it_main)->global_index < earliest_loop_index_main){
            continue;
        }
        (*it_main)->resample_globalIndex = resample_id;
        Vector3d tmp_t;
        Matrix3d tmp_r;
        //获取关键帧it的位姿
        (*it_main)->getPose(tmp_t, tmp_r);
        dis_main += (tmp_t - last_P_main).norm();
        //全局优化 还是要加序列边 不然太长了 判断条件 再加个两个地图之间发生了融合
        if((*it_main)->global_index == earliest_loop_index_main || dis_main > min_dis_main || (*it_main)->is_get_loop_info || (*it_main)->is_looped || (*it_main)->has_global_loop || (*it_main)->is_global_looped || pMainMap->keyFrameList.size() < max_frame_num_global_main)
        {
            dis_main = 0;
            last_P_main = tmp_t;
            need_resample_main.push_back(0);
            
//            pMainMap->special_kf_inOpti.push_back((*it_main)->global_index);
            special_kf_inOpti_main.push_back((*it_main)->global_index);
            
            if(((*it_main)->has_global_loop || (*it_main)->is_global_looped) && (*it_main)->is_Send==false ){
                kf_id_hasComPlace_main.push_back((*it_main)->global_index);
//                pMainMap->add2_kf_id_hasComPlace_withOtherMap((*it_main)->global_index);
                (*it_main)->is_Send=true;
            }
            
        }
        else
        {
            last_P_main = tmp_t;
            need_resample_main.push_back(1);
        }
        
        Quaterniond tmp_q;
        Matrix3d tmp_r_origin;
        Vector3d tmp_t_origin;
        (*it_main)->getOriginPose(tmp_t_origin, tmp_r_origin);
//                (*it_main)->getPose(tmp_t, tmp_r);
        tmp_q = tmp_r_origin;
        t_array_main[resample_id][0] = tmp_t_origin(0);
        t_array_main[resample_id][1] = tmp_t_origin(1);
        t_array_main[resample_id][2] = tmp_t_origin(2);
        q_array_main[resample_id] = tmp_q;
        //将矩阵转换为向量
        Vector3d euler_angle = Utility::R2ypr(tmp_r_origin);
        euler_array_main[resample_id][0] = euler_angle.x();
        euler_array_main[resample_id][1] = euler_angle.y();
        euler_array_main[resample_id][2] = euler_angle.z();
        
        resample_id++;
        
        if ((*it_main)->global_index == latest_loop_index_main)
            break;
    }
    
//    pMainMap->special_kf_mutex.lock();
//    pMainMap->add2_kf_id_hasComPlace_withOtherMap(kf_id_hasComPlace_main);
//   pMainMap->special_kf_inOpti.push(special_kf_inOpti_main);
//   pMainMap->special_kf_mutex.unlock();
    
    vector<vector<int>> special_kf_inOpti_cur_all;
    vector<vector<int>> kf_id_hasComPlace_cur_all;
    
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
        //遍历关键帧列表
        list<KeyFrame*>::iterator it_other = pMap_other->keyFrameList.begin();

        Vector3d last_P_other = Vector3d(0, 0, 0);
        double dis_other = 0;
        
        vector<int> special_kf_inOpti_cur;
        vector<int> kf_id_hasCom_cur;
        resample_id=0;
        resample_other_all[flag_start].clear();
       
        //小地图是从第一个帧开始优化
        for(;it_other!=pMap_other->keyFrameList.end();it_other++){
            (*it_other)->resample_globalIndex = resample_id;
            
            Vector3d tmp_t;
            Matrix3d tmp_r;
            //获取关键帧it的位姿
            (*it_other)->getPose(tmp_t, tmp_r);
            dis_other += (tmp_t - last_P_other).norm();
            
            
            //全局优化 还是要加序列边 不然太长了 判断条件 再加个两个地图之间发生了融合
            //第一个地图融合位置，超过长度了，发生过回环，被回环了，总共的帧长度比最大值小
            //还要再加一个 发生了融合，被融合了
            if((*it_other)->global_index == 0 || dis_other > pMap_other->min_dis || (*it_other)->is_get_loop_info || (*it_other)->is_looped || (*it_other)->has_global_loop || (*it_other)->is_global_looped || pMap_other->keyFrameList.size() < pMap_other->max_frame_num_global)
            {
                dis_other = 0;
                last_P_other = tmp_t;
                resample_other_all[flag_start].push_back(0);
                
    //            pCurMap->special_kf_inOpti.push_back((*it_other)->global_index);
                special_kf_inOpti_cur.push_back((*it_other)->global_index);
                
                if(((*it_other)->has_global_loop || (*it_other)->is_global_looped) && (*it_other)->is_Send==false ){
                    kf_id_hasCom_cur.push_back((*it_other)->global_index);
    //                pCurMap->add2_kf_id_hasComPlace_withOtherMap((*it_other)->global_index);
                    (*it_other)->is_Send=true;
                }
                
            }
            else
            {
                last_P_other = tmp_t;
                resample_other_all[flag_start].push_back(1);
            }
            
            Quaterniond tmp_q;
            Matrix3d tmp_r_origin;
            Vector3d tmp_t_origin;
            (*it_other)->getOriginPose(tmp_t_origin, tmp_r_origin);
    //                (*it_main)->getPose(tmp_t, tmp_r);
            tmp_q = tmp_r_origin;
            (t_other_all[flag_start])[resample_id][0] = tmp_t_origin(0);
            (t_other_all[flag_start])[resample_id][1] = tmp_t_origin(1);
            (t_other_all[flag_start])[resample_id][2] = tmp_t_origin(2);
            q_other_all[flag_start][resample_id] = tmp_q;
            //将矩阵转换为向量
            Vector3d euler_angle = Utility::R2ypr(tmp_r_origin);
            euler_other_all[flag_start][resample_id][0] = euler_angle.x();
            euler_other_all[flag_start][resample_id][1] = euler_angle.y();
            euler_other_all[flag_start][resample_id][2] = euler_angle.z();
            
            resample_id++;
            
            if ((*it_other)->global_index == latest_loopIndex_other_all[flag_start])
                break;
        }
        
//        pMap_other->special_kf_mutex.lock();
//        pMap_other->add2_kf_id_hasComPlace_withOtherMap(kf_id_hasCom_cur);
//        pMap_other->special_kf_inOpti.push(special_kf_inOpti_cur);
//        pMap_other->special_kf_mutex.unlock();
        
        special_kf_inOpti_cur_all.push_back(special_kf_inOpti_cur);
        kf_id_hasComPlace_cur_all.push_back(kf_id_hasCom_cur);
        
    }
    
    std::vector<ceres::ResidualBlockId> residual_block_ids;
    ceres::ResidualBlockId              block_id;
    
    int i_main = 0;
    for (it_main = pMainMap->keyFrameList.begin(); it_main != pMainMap->keyFrameList.end(); it_main++)
    {
        if ((*it_main)->global_index < earliest_loop_index_main)
            continue;
//        (*it_main)->resample_globalIndex = i_main;
        
//        Quaterniond tmp_q;
//        Matrix3d tmp_r;
//        Vector3d tmp_t;
//        (*it_main)->getOriginPose(tmp_t, tmp_r);
////                (*it_main)->getPose(tmp_t, tmp_r);
//        tmp_q = tmp_r;
//        t_array_main[i_main][0] = tmp_t(0);
//        t_array_main[i_main][1] = tmp_t(1);
//        t_array_main[i_main][2] = tmp_t(2);
//        q_array_main[i_main] = tmp_q;
//        //将矩阵转换为向量
//        Vector3d euler_angle = Utility::R2ypr(tmp_r);
//        euler_array_main[i_main][0] = euler_angle.x();
//        euler_array_main[i_main][1] = euler_angle.y();
//        euler_array_main[i_main][2] = euler_angle.z();
        //将关键帧列表中所有index>=earliest_loop_index的关键帧的位姿加入到参数块当中
        problem.AddParameterBlock(euler_array_main[i_main], 1, angle_local_parameterization);
        problem.AddParameterBlock(t_array_main[i_main], 3);
//        cout<<"主地图数据r："<<euler_array_main[i_main][0]<<" , "<<euler_array_main[i_main][1]<<" , "<<euler_array_main[i_main][2]<<endl;
//        cout<<"主地图数据t："<<t_array_main[i_main][0]<<" , "<<t_array_main[i_main][1]<<" , "<<t_array_main[i_main][2]<<endl;
        //设置约束：如果该帧是最早的闭环帧的情况下，则固定它的位姿
        if ((*it_main)->global_index == earliest_loop_index_main)
        {
            problem.SetParameterBlockConstant(euler_array_main[i_main]);
            problem.SetParameterBlockConstant(t_array_main[i_main]);
//                cout<<"测试 更新哪里变了："<<euler_array_main[i_main][0]<<" "<<euler_array_main[i_main][1]<<" "<<euler_array_main[i_main][2]<<" "<<t_array_main[i_main][0]<<" "<<t_array_main[i_main][1]<<" "<<t_array_main[i_main][2]<<" "<<i_main<<endl;
        }
        
        if(need_resample_main[i_main])
        {
            i_main++;
            continue;
        }
        
        
        int j = 1, sequence_link_cnt = 0;
        while(sequence_link_cnt < 5)
        {
            if (i_main - j >= 0)
            {
//                        list<KeyFrame*>::iterator tmp = it_main;
//                        std::advance (tmp, -j);
                if(need_resample_main[i_main-j])
                {
                    j++;
                    continue;
                }
                else
                {
                    sequence_link_cnt++;
                }
                Vector3d euler_conncected = Utility::R2ypr(q_array_main[i_main-j].toRotationMatrix());
                //p̂_j^w - p̂_i^w 计算平移量的偏差
                Vector3d relative_t(t_array_main[i_main][0] - t_array_main[i_main-j][0], t_array_main[i_main][1] - t_array_main[i_main-j][1], t_array_main[i_main][2] - t_array_main[i_main-j][2]);
                //p̂_{ij}^{i} = {R̂_i^w}^{-1} (p̂_j^w - p̂_i^w)
                //p̂ ij= (R̂ iw ) (p̂ jw − p̂ iw )
                relative_t = q_array_main[i_main-j].inverse() * relative_t;
                //ψ̂ _ij = ψ̂ _j − ψ̂ _i
                double relative_yaw = euler_array_main[i_main][0] - euler_array_main[i_main-j][0];
//                cout<<"主地图序列帧relative_t："<<relative_t[0]<<" , "<<relative_t[1]<<" , "<<relative_t[2]<<endl;
//                cout<<"主地图序列帧euler_conncected："<<euler_conncected[0]<<" , "<<euler_conncected[1]<<" , "<<euler_conncected[2]<<endl;
//                cout<<"主地图序列帧relative_yaw："<<relative_yaw<<endl;
                ceres::CostFunction* cost_function = FourDOFError_another::Create( relative_t.x(), relative_t.y(), relative_t.z(),
                                                                          relative_yaw, euler_conncected.y(), euler_conncected.z(),6-sequence_link_cnt);
                block_id = problem.AddResidualBlock(cost_function, loss_function, euler_array_main[i_main-j],
                                         t_array_main[i_main-j],
                                         euler_array_main[i_main],
                                         t_array_main[i_main]);
                
                residual_block_ids.push_back( block_id );
            }
            else
            {
                break;
            }
            j++;
        }

        //        添加的是闭环边，是指检测到闭环的两帧
        if((*it_main)->is_get_loop_info   )
        {
            if((*it_main)->loop_index >= earliest_loop_index_main)
            {
                int connected_index = pMainMap->getKeyframe((*it_main)->loop_index)->resample_globalIndex;

                Vector3d euler_conncected = Utility::R2ypr(q_array_main[connected_index].toRotationMatrix());
                Vector3d relative_t((*it_main)->loop_info_better(0), (*it_main)->loop_info_better(1), (*it_main)->loop_info_better(2));
                double relative_yaw = (*it_main)->loop_info_better(3);
//                cout<<"主地图回环relative_t："<<relative_t[0]<<" , "<<relative_t[1]<<" , "<<relative_t[2]<<endl;
//                cout<<"主地图回环euler_conncected："<<euler_conncected[0]<<" , "<<euler_conncected[1]<<" , "<<euler_conncected[2]<<endl;
//                cout<<"主地图回环relative_yaw："<<relative_yaw<<endl;
                ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),
                                                                                relative_yaw, euler_conncected.y(), euler_conncected.z(),10.0);
                block_id =problem.AddResidualBlock(cost_function, NULL, euler_array_main[connected_index],
                                         t_array_main[connected_index],
                                         euler_array_main[i_main],
                                         t_array_main[i_main]);
                
                residual_block_ids.push_back( block_id );
            }else{
                assert(false);//报错
            }
        }

        
        if((*it_main)->has_global_loop)
       {
           //这里后面还要添加else
           if((*it_main)->global_loop_index < 0)
           {
               //因为这意味着数据保存出错了 发生了融合的帧的id小于最早发生融合的id
               assert(false);
               return;
           }
//           获取是和哪个其它地图发生了回环
           (*it_main)->readWriteLock_loop.readLock();
           int loop_index_flag_end=(*it_main)->clientId.size();
           (*it_main)->readWriteLock_loop.readUnLock();
//           遍历该帧的 所有回环帧
           for(int loop_index_flag=0;loop_index_flag<loop_index_flag_end;loop_index_flag++){
               (*it_main)->readWriteLock_loop.readLock();
               int matching_clientId=(*it_main)->clientId[loop_index_flag];
               int matching_kfId=(*it_main)->kfId[loop_index_flag];
               std::pair<Matrix3d , Vector3d > matching_rt=(*it_main)->relativePose[loop_index_flag];
               (*it_main)->readWriteLock_loop.readUnLock();
               
//               找到这个对应的其它地图
               int vmap_index=vMapId_all[matching_clientId];
               PoseGraph * pMap_other=vMap_all[vmap_index];
               //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束 会出现空指针的问题
               int connected_index = pMap_other->getKeyframe(matching_kfId)->resample_globalIndex;//这里可能多个
               
//               Vector3d euler_conncected = Utility::R2ypr(matching_rt.first);
//               Vector3d relative_t=matching_rt.second;
//               double relative_yaw = euler_conncected[0]-euler_other_all[vmap_index][connected_index][0];
//               cout<<"主地图共同探索kfid"<<matching_kfId<<" , "<<earliest_loopIndex_other_all[vmap_index]<<endl;
//               cout<<"主地图共同探索matching_clientId"<<matching_clientId<<" , "<<vmap_index<<" , "<<latest_loopIndex_other_all[vmap_index]<<endl;
//               cout<<"主地图共同探索connected_index"<<connected_index<<" , "<<vmap_index<<" , "<<matching_clientId<<endl;
//               cout<<"主地图q"<<q_other_all[vmap_index][connected_index].x()<<", "<<q_other_all[vmap_index][connected_index].y()<<", "<<q_other_all[vmap_index][connected_index].z()<<" , "<<q_other_all[vmap_index][connected_index].w()<<endl;
               if(matching_kfId < earliest_loopIndex_other_all[vmap_index])
               {
                   //因为这意味着数据保存出错了 发生了融合的帧的id小于最早发生融合的id
                   assert(false);
                   return;
               }
               
               Vector3d euler_conncected = Utility::R2ypr(q_other_all[vmap_index][connected_index].toRotationMatrix());
               Vector3d relative_t((*it_main)->relative_global_loop_info_multiClient[loop_index_flag](0), (*it_main)->relative_global_loop_info_multiClient[loop_index_flag](1), (*it_main)->relative_global_loop_info_multiClient[loop_index_flag](2));
               double relative_yaw = (*it_main)->relative_global_loop_info_multiClient[loop_index_flag](7);
               
//               cout<<"主地图共同探索relative_t："<<relative_t[0]<<" , "<<relative_t[1]<<" , "<<relative_t[2]<<endl;
//               cout<<"主地图共同探索euler_conncected："<<euler_conncected[0]<<" , "<<euler_conncected[1]<<" , "<<euler_conncected[2]<<endl;
//               cout<<"主地图共同探索relative_yaw："<<relative_yaw<<endl;
               //这里到时候 再写一个求导的
               ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z(),5.0);
               block_id = problem.AddResidualBlock(cost_function, NULL, euler_other_all[vmap_index][connected_index] ,
                                       t_other_all[vmap_index][connected_index] ,
                                        euler_array_main[i_main],
                                        t_array_main[i_main]);
               
               residual_block_ids.push_back( block_id );
           }
          
           
           
       }
        
        
        if ((*it_main)->global_index == latest_loop_index_main)
            break;
        i_main++;
    }
    
    
    //*************************************第一个数据
    
    int i_other = 0;
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
        i_other = 0;
        for (auto it_other = pMap_other->keyFrameList.begin(); it_other != pMap_other->keyFrameList.end(); it_other++)
        {
    //        (*it_other)->resample_globalIndex = i_other;
            
//            Quaterniond tmp_q;
//            Matrix3d tmp_r;
//            Vector3d tmp_t;
//            (*it_other)->getOriginPose(tmp_t, tmp_r);
//
//            tmp_q=tmp_r;
//
//            (t_other_all[flag_start])[i_other][0]=tmp_t.x();
//            (t_other_all[flag_start])[i_other][1]=tmp_t.y();
//            (t_other_all[flag_start])[i_other][2]=tmp_t.z();
//
////            int len = sizeof(q_other_all[flag_start]) / sizeof(q_other_all[flag_start][0]);
//            q_other_all[flag_start][i_other]=tmp_q;
//
//            //将矩阵转换为向量
//            Vector3d euler_angle = Utility::R2ypr(tmp_r);
//            euler_other_all[flag_start][i_other][0] = euler_angle.x();
//            euler_other_all[flag_start][i_other][1] = euler_angle.y();
//            euler_other_all[flag_start][i_other][2] = euler_angle.z();
            //将关键帧列表中所有index>=earliest_loop_index的关键帧的位姿加入到参数块当中
           
            problem.AddParameterBlock(euler_other_all[flag_start][i_other], 1, angle_local_parameterization);
            problem.AddParameterBlock(t_other_all[flag_start][i_other], 3);
//            cout<<"其它地图数据r："<<euler_other_all[flag_start][i_other][0]<<" , "<<euler_other_all[flag_start][i_other][1]<<" , "<<euler_other_all[flag_start][i_other][2]<<endl;
//            cout<<"其它地图数据t："<<t_other_all[flag_start][i_other][0]<<" , "<<t_other_all[flag_start][i_other][1]<<" , "<<t_other_all[flag_start][i_other][2]<<endl;

            if(resample_other_all[flag_start][i_other])
            {
               
                i_other++;
                continue;
            }


            int j = 1, sequence_link_cnt = 0;
            while(sequence_link_cnt < 5)
            {
                if (i_other - j >= 0)
                {
    //                        list<KeyFrame*>::iterator tmp = it_other;
    //                        std::advance (tmp, -j);
                    if(resample_other_all[flag_start][i_other-j])
                    {
                        j++;
                        continue;
                    }
                    else
                    {
                        sequence_link_cnt++;
                    }
                    Vector3d euler_conncected = Utility::R2ypr(q_other_all[flag_start][i_other-j].toRotationMatrix());
                    //p̂_j^w - p̂_i^w 计算平移量的偏差
                    Vector3d relative_t(t_other_all[flag_start][i_other][0] - t_other_all[flag_start][i_other-j][0], t_other_all[flag_start][i_other][1] - t_other_all[flag_start][i_other-j][1], t_other_all[flag_start][i_other][2] - t_other_all[flag_start][i_other-j][2]);
                    //p̂_{ij}^{i} = {R̂_i^w}^{-1} (p̂_j^w - p̂_i^w)
                    //p̂ ij= (R̂ iw ) (p̂ jw − p̂ iw )
                    relative_t = q_other_all[flag_start][i_other-j].inverse() * relative_t;
                    //ψ̂ _ij = ψ̂ _j − ψ̂ _i
                    double relative_yaw = euler_other_all[flag_start][i_other][0] - euler_other_all[flag_start][i_other-j][0];
//                    cout<<"其它地图序列帧relative_t："<<relative_t[0]<<" , "<<relative_t[1]<<" , "<<relative_t[2]<<endl;
//                    cout<<"其它地图序列帧euler_conncected："<<euler_conncected[0]<<" , "<<euler_conncected[1]<<" , "<<euler_conncected[2]<<endl;
//                    cout<<"其它地图序列帧relative_yaw："<<relative_yaw<<endl;
                    ceres::CostFunction* cost_function = FourDOFError_another::Create( relative_t.x(), relative_t.y(), relative_t.z(),
                                                                              relative_yaw, euler_conncected.y(), euler_conncected.z(),6-sequence_link_cnt);
                    block_id = problem.AddResidualBlock(cost_function, loss_function, euler_other_all[flag_start][i_other-j],
                                             t_other_all[flag_start][i_other-j],
                                             euler_other_all[flag_start][i_other],
                                             t_other_all[flag_start][i_other]);
                    
                    
                    residual_block_ids.push_back( block_id );
                }
                else
                {
                    break;
                }
                j++;
            }
          
            //        添加的是闭环边，是指检测到闭环的两帧 一个数据拆成两份 这个注释掉了
            if((*it_other)->is_get_loop_info)
            {
                //这里后面还要添加else
                if((*it_other)->loop_index <0)
                {
                    assert(false);
                }
                //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束
                int connected_index = pMap_other->getKeyframe((*it_other)->loop_index)->resample_globalIndex;

                Vector3d euler_conncected = Utility::R2ypr(q_other_all[flag_start][connected_index].toRotationMatrix());
                Vector3d relative_t((*it_other)->loop_info_better(0), (*it_other)->loop_info_better(1), (*it_other)->loop_info_better(2));
                double relative_yaw = (*it_other)->loop_info_better(3);

    //                    cout<<fixed<<setprecision(6)<<"(*it_other)->loop_info(0)"<<(*it_other)->loop_info_better(0)<<" (*it_other)->loop_info(1)"<<(*it_other)->loop_info_better(1)<<" (*it_other)->loop_info(2)"<<(*it_other)->loop_info_better(2)<<" (*it_other)->loop_info(7)"<<(*it_other)->loop_info_better(3)<<" "<<(*it_other)->header<<" "<<pCurMap->getKeyframe((*it_other)->global_index)->header<<endl;
//                cout<<"其它地图回环relative_t："<<relative_t[0]<<" , "<<relative_t[1]<<" , "<<relative_t[2]<<endl;
//                cout<<"其它地图回环euler_conncected："<<euler_conncected[0]<<" , "<<euler_conncected[1]<<" , "<<euler_conncected[2]<<endl;
//                cout<<"其它地图回环relative_yaw："<<relative_yaw<<endl;
                
                ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z(),5.0);
                block_id = problem.AddResidualBlock(cost_function, NULL, euler_other_all[flag_start][connected_index],
                                         t_other_all[flag_start][connected_index],
                                         euler_other_all[flag_start][i_other],
                                         t_other_all[flag_start][i_other]);
                residual_block_ids.push_back( block_id );
                
            }
           
            if((*it_other)->has_global_loop)
           {
    //           获取是和哪个其它地图发生了回环
              (*it_other)->readWriteLock_loop.readLock();
              int loop_index_flag_end=(*it_other)->clientId.size();
              (*it_other)->readWriteLock_loop.readUnLock();
    //           遍历该帧的 所有回环帧
              for(int loop_index_flag=0;loop_index_flag<loop_index_flag_end;loop_index_flag++){
                  (*it_other)->readWriteLock_loop.readLock();
                  int matching_clientId=(*it_other)->clientId[loop_index_flag];
                  int matching_kfId=(*it_other)->kfId[loop_index_flag];
                  std::pair<Matrix3d , Vector3d > matching_rt=(*it_other)->relativePose[loop_index_flag];
                  (*it_other)->readWriteLock_loop.readUnLock();
                  
//                  Vector3d euler_conncected = Utility::R2ypr(matching_rt.first);
//                  Vector3d relative_t=matching_rt.second;
//                  double relative_yaw = euler_conncected[0];
                  
                  if(matching_clientId==pMainMap->c->id){
                      if(matching_kfId < earliest_loop_index_main)
                      {
                          //因为这意味着数据保存出错了 发生了融合的帧的id小于最早发生融合的id
                          assert(false);
                          return;
                      }
                      //说明是和此次新增地图 发生匹配
                      //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束
                      int connected_index = pMainMap->getKeyframe(matching_kfId)->resample_globalIndex;
                      
//                      double relative_yaw =euler_conncected[0]-euler_array_main[connected_index][0];
                      
                      Vector3d euler_conncected = Utility::R2ypr(q_array_main[connected_index].toRotationMatrix());
                      Vector3d relative_t((*it_other)->relative_global_loop_info_multiClient[loop_index_flag](0), (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](1), (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](2));
                      double relative_yaw = (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](7);
////                      cout<<"其它地图共同探索0kfid"<<matching_kfId<<" , "<<earliest_loop_index_main<<endl;
////                      cout<<"其它地图共同探索0matching_clientId"<<matching_clientId<<" , "<<latest_loop_index_main<<endl;
////                      cout<<"其它地图共同探索0connected_index"<<connected_index<<" , "<<sizeof(q_array_main) / sizeof(q_array_main[0])<<endl;
//                      cout<<"其它地图共同探索connected_index"<<connected_index<<" , "<<matching_clientId<<endl;
//                      cout<<"其它地图q"<<q_array_main[connected_index].x()<<", "<<q_array_main[connected_index].y()<<", "<<q_array_main[connected_index].z()<<" , "<<q_array_main[connected_index].w()<<endl;
//                      
//                      cout<<"其它地图共同探索0relative_t："<<relative_t[0]<<" , "<<relative_t[1]<<" , "<<relative_t[2]<<endl;
//                      cout<<"其它地图共同探索0euler_conncected："<<euler_conncected[0]<<" , "<<euler_conncected[1]<<" , "<<euler_conncected[2]<<endl;
//                      cout<<"其它地图共同探索0relative_yaw："<<relative_yaw<<endl;
                      //这里到时候 再写一个求导的
                      ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z(),5.0);
                      block_id = problem.AddResidualBlock(cost_function, NULL, euler_array_main[connected_index],
                                               t_array_main[connected_index],
                                               euler_other_all[flag_start][i_other],
                                               t_other_all[flag_start][i_other]);
                      residual_block_ids.push_back( block_id );
                      
                  }else{
                      int vmap_index=vMapId_all[matching_clientId];
                      if(matching_kfId < earliest_loopIndex_other_all[vmap_index])
                      {
                          //因为这意味着数据保存出错了 发生了融合的帧的id小于最早发生融合的id
                          assert(false);
                          return;
                      }
                      
        //               找到这个对应的其它地图
                      PoseGraph * pMap_fuse=vMap_all[vmap_index];
                      //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束 会出现空指针的问题
                      KeyFrame* matchingKf=pMap_fuse->getKeyframe(matching_kfId);
                      int connected_index = matchingKf->resample_globalIndex;//这里可能多个
//                      cout<<"匹配帧id"<<pMap_fuse->getKeyframe(matching_kfId)->global_index<<","<<pMap_fuse->c->getId()<<endl;
                        
    //                  double relative_yaw =euler_conncected[0]-euler_other_all[vmap_index][connected_index][0];
                      
                      Vector3d euler_conncected = Utility::R2ypr(q_other_all[vmap_index][connected_index].toRotationMatrix());
                      Vector3d relative_t((*it_other)->relative_global_loop_info_multiClient[loop_index_flag](0), (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](1), (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](2));
                      double relative_yaw = (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](7);
//                      cout<<"其它地图共同探索kfid"<<matching_kfId<<" , "<<earliest_loopIndex_other_all[vmap_index]<<endl;
//                      cout<<"其它地图共同探索matching_clientId"<<matching_clientId<<" , "<<vmap_index<<" , "<<latest_loopIndex_other_all[vmap_index]<<endl;
//                      cout<<"其它地图共同探索connected_index"<<connected_index<<" , "<<q_other_all[vmap_index].size()<<endl;
                      
//                      cout<<"其它地图共同探索connected_index"<<connected_index<<" , "<<vmap_index<<" , "<<matching_clientId<<endl;
//                      cout<<"其它地图q"<<q_other_all[vmap_index][connected_index].x()<<", "<<q_other_all[vmap_index][connected_index].y()<<", "<<q_other_all[vmap_index][connected_index].z()<<" , "<<q_other_all[vmap_index][connected_index].w()<<endl;
//
//
//                      cout<<"其它地图共同探索relative_t："<<relative_t[0]<<" , "<<relative_t[1]<<" , "<<relative_t[2]<<endl;
//                      cout<<"其它地图共同探索euler_conncected："<<euler_conncected[0]<<" , "<<euler_conncected[1]<<" , "<<euler_conncected[2]<<endl;
//                      cout<<"其它地图共同探索relative_yaw："<<relative_yaw<<endl;
                       //这里到时候 再写一个求导的 重复的残差
                       ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z(),10.0);
                      block_id = problem.AddResidualBlock(cost_function, NULL, euler_other_all[vmap_index][connected_index],
                                            t_other_all[vmap_index][connected_index],
                                            euler_other_all[flag_start][i_other],
                                            t_other_all[flag_start][i_other]);
                      
                      residual_block_ids.push_back( block_id );
                  }
                  
                  
              }
           }
            if ((*it_other)->global_index == latest_loopIndex_other_all[flag_start])
                break;
            i_other++;
          
        }

    }
    
    
    std::vector< ceres::ResidualBlockId > residual_block_ids_temp;
    residual_block_ids_temp.reserve( residual_block_ids.size() );
    
//    const int its[4]={2,6,10,10};
   
    for ( size_t ii = 0; ii <1; ii++ )
    {
        options.max_num_iterations =2;
//                    options.minimizer_progress_to_stdout = false;
//                    options.check_gradients = false;
//                    options.gradient_check_relative_precision = 1e-10;
        //options.function_tolerance = 1e-100; // default 1e-6


//                    set_ceres_solver_bound( problem, t_array );
        ceres::Solve( options, &problem, &summary );
//                    std::cout <<"算一个粗糙的相对位姿1："<< summary.BriefReport() << "\n";

        residual_block_ids_temp.clear();
        ceres::Problem::EvaluateOptions eval_options;
        eval_options.residual_blocks = residual_block_ids;
        double              total_cost = 0.0;
        std::vector<double> residuals;
        problem.Evaluate( eval_options, &total_cost, &residuals, nullptr, nullptr );

        double m_inliner_ratio_threshold = compute_inlier_residual_threshold( residuals, 0.8);
        double m_inlier_threshold = std::max( 2.0, m_inliner_ratio_threshold );
//                    cout<<"m_inlier_threshold="<<m_inlier_threshold<<endl;
//                    cout << "Inlier threshold is: " << m_inlier_final_threshold << endl;
        for ( unsigned int i = 0; i < residual_block_ids.size(); i++ )
        {
//            hh.push_back(fabs( residuals[ 2 * i + 0 ] ) + fabs( residuals[ 2 * i + 1 ] ));
//                        cout<<"测试误差："<<fabs( residuals[ 2 * i + 0 ] ) + fabs( residuals[ 2 * i + 1 ] )<<endl;
            if ( ( fabs( residuals[ 2 * i + 0 ] ) + fabs( residuals[ 2 * i + 1 ] ) ) > m_inlier_threshold ) // std::min( 1.0, 10 * avr_cost )
            {
                //screen_out << "Remove outliers, drop id = " << (void *)residual_block_ids[ i ] <<endl;
                problem.RemoveResidualBlock( residual_block_ids[ i ] );
//                point_all.push_back(i);
            }
            else
            {
                residual_block_ids_temp.push_back( residual_block_ids[ i ] );
            }
        }
        residual_block_ids = residual_block_ids_temp;
    }
    
    options.linear_solver_type = ceres::DENSE_SCHUR;//DENSE_QR DENSE_SCHUR
    options.max_num_iterations = 20;
    ceres::Solve(options, &problem, &summary);
    
    std::cout << "global fuse: "<<summary.BriefReport() << "\n";
    if(summary.termination_type!=ceres::CONVERGENCE){
        return;
    }
    
    pMainMap->loop_index_multiClient.push(earliest_loop_index_main);
    pMainMap->curKF_loop_index_multiClient.push(latest_loop_index_main);
    
    
    pMainMap->special_kf_mutex.lock();
    pMainMap->add2_kf_id_hasComPlace_withOtherMap(kf_id_hasComPlace_main);
   pMainMap->special_kf_inOpti.push(special_kf_inOpti_main);
   pMainMap->special_kf_mutex.unlock();
    
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
        
        vector<int> special_kf_inOpti_cur=special_kf_inOpti_cur_all[flag_start];
        vector<int> kf_id_hasCom_cur=kf_id_hasComPlace_cur_all[flag_start];
        
        pMap_other->special_kf_mutex.lock();
        pMap_other->add2_kf_id_hasComPlace_withOtherMap(kf_id_hasCom_cur);
        pMap_other->special_kf_inOpti.push(special_kf_inOpti_cur);
        pMap_other->special_kf_mutex.unlock();
        
        
        int latest_loop_index_other= latest_loop_index_other_update[flag_start];
        
        pMap_other->isFirstFusion_globalMutex.lock();
        pMap_other->loop_index_multiClient.push(0);
        pMap_other->curKF_loop_index_multiClient.push(latest_loop_index_other);
        pMap_other->isFirstFusion_globalMutex.unlock();
    }
    
    //------------------------------------------第一个数据优化后更新
    //优化完成，使用优化后的位姿来更新关键帧列表中index大于等于earliest_loop_index的所有关键帧的位姿
    
    Vector3d t_drift_it_other = Vector3d::Zero();
    Matrix3d r_drift_it_other = Matrix3d::Identity();
    
    vector<Matrix3d> r_global_cur;
    vector<Vector3d> t_global_cur;
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
        list<KeyFrame*>::iterator it_other = pMap_other->keyFrameList.begin();
        i_other = 0;
        r_global_cur.clear();
        t_global_cur.clear();
        for (; it_other != pMap_other->keyFrameList.end(); it_other++)
        {
            
            Quaterniond tmp_q;
            //向量转换为矩阵
            tmp_q = Utility::ypr2R(Vector3d(euler_other_all[flag_start][i_other][0], euler_other_all[flag_start][i_other][1], euler_other_all[flag_start][i_other][2]));
            Vector3d tmp_w1_t = Vector3d(t_other_all[flag_start][i_other][0], t_other_all[flag_start][i_other][1], t_other_all[flag_start][i_other][2]);
            Matrix3d tmp_w1_r = tmp_q.toRotationMatrix();
            
         
           
            if(resample_other_all[flag_start][i_other])
            {
                (*it_other)-> updatePose(r_drift_it_other * tmp_w1_t + t_drift_it_other, r_drift_it_other * tmp_w1_r);
            }
            else
            {
                Vector3d origin_t_it;
                Matrix3d origin_r_it;
                (*it_other)->getOriginPose(origin_t_it, origin_r_it);
                
                
                r_drift_it_other = tmp_w1_r * origin_r_it.transpose();
                t_drift_it_other = tmp_w1_t - r_drift_it_other * origin_t_it;
                (*it_other)-> updatePose(tmp_w1_t, tmp_w1_r);
                
    //            pCurMap->add2_r_global_multiClient(tmp_w1_r);
    //            pCurMap->add2_t_global_multiClient(tmp_w1_t);
                r_global_cur.push_back(tmp_w1_r);
                t_global_cur.push_back(tmp_w1_t);
            }
            if ((*it_other)->global_index == latest_loopIndex_other_all[flag_start])
                break;
            i_other++;
            
        }
        //如果将地图建模成可变形的呢
        //根据计算出当前帧的drift，更新全部关键帧位姿
        Vector3d cur_t_other, origin_t_other;
        Matrix3d cur_r_other, origin_r_other;
        //获取优化后当前帧的位姿cur_t,cur_r
        (*it_other)->getPose(cur_t_other, cur_r_other);
        //获取优化前有漂移的当前帧的位姿vio_t,vio_r
        (*it_other)->getOriginPose(origin_t_other, origin_r_other);
        pMap_other->yaw_drift = Utility::R2ypr(cur_r_other).x() - Utility::R2ypr(origin_r_other).x();
        pMap_other->r_drift = Utility::ypr2R(Vector3d(pMap_other->yaw_drift, 0, 0));
        pMap_other->t_drift = cur_t_other - pMap_other->r_drift * origin_t_other;
        
    //    pCurMap->add2_r_global_multiClient(pCurMap->r_drift);
    //    pCurMap->add2_t_global_multiClient(pCurMap->t_drift);
        r_global_cur.push_back(pMap_other->r_drift);
        t_global_cur.push_back(pMap_other->t_drift);
        pMap_other->add2_r_global_multiClient(r_global_cur);
        pMap_other->add2_t_global_multiClient(t_global_cur);
        if((r_global_cur.size()-1)!=pMap_other->special_kf_inOpti.back().size()){
            cout<<"当前地图id"<<pMap_other->c->id<<" , "<<latest_loopIndex_other_all[flag_start]<<endl;
            cout<<"resample下标数量不一致："<<r_global_cur.size()<<" , "<<pMap_other->special_kf_inOpti.back().size()<<endl;
            while (pMap_other->special_kf_inOpti.size()!=2)
            {
                cout << pMap_other->special_kf_inOpti.front().size()<< " "; // Output the 1st element
                pMap_other->special_kf_inOpti.pop();  // Delete the 1st element
            }
            std::cout << std::endl;
            cout << "倒数第二个："<<pMap_other->special_kf_inOpti.front().size()<< endl;
            assert(false);//20 38
        }

        //下面代码为把当前关键帧it之后的关键帧的位姿通过求解的偏移量转换到world坐标系下
        for (; it_other != pMap_other->keyFrameList.end(); it_other++)
        {
            Vector3d P;
            Matrix3d R;
            (*it_other)->getOriginPose(P, R);
            P = pMap_other->r_drift * P + pMap_other->t_drift;
            R = pMap_other->r_drift * R;
            (*it_other)-> updatePose(P, R);
        }
        pMap_other->lastKF_index.push(pMap_other->keyFrameList.back()->global_index);
    }
    
    
    
    //---------------------------------------第2个数据的更新
    //优化完成，使用优化后的位姿来更新关键帧列表中index大于等于earliest_loop_index的所有关键帧的位姿
    i_main = 0;
    Vector3d t_drift_it_main = Vector3d::Zero();
    Matrix3d r_drift_it_main = Matrix3d::Identity();
    
    vector<Matrix3d> r_global_main;
    vector<Vector3d> t_global_main;
    for (it_main = pMainMap->keyFrameList.begin(); it_main != pMainMap->keyFrameList.end(); it_main++)
    {
        if ((*it_main)->global_index < earliest_loop_index_main)
            continue;

        Quaterniond tmp_q;
        //向量转换为矩阵
        tmp_q = Utility::ypr2R(Vector3d(euler_array_main[i_main][0], euler_array_main[i_main][1], euler_array_main[i_main][2]));
        Vector3d tmp_w1_t = Vector3d(t_array_main[i_main][0], t_array_main[i_main][1], t_array_main[i_main][2]);
        Matrix3d tmp_w1_r = tmp_q.toRotationMatrix();

//                cout<<"测试 优化完成 更新哪里变了："<<euler_array_main[i_main][0]<<" "<<euler_array_main[i_main][1]<<" "<<euler_array_main[i_main][2]<<" "<<t_array_main[i_main][0]<<" "<<t_array_main[i_main][1]<<" "<<t_array_main[i_main][2]<<" "<<i_main<<endl;
        if(need_resample_main[i_main])
        {
            (*it_main)-> updatePose(r_drift_it_main * tmp_w1_t + t_drift_it_main, r_drift_it_main * tmp_w1_r);
        }
        else
        {
            Vector3d origin_t_it;
            Matrix3d origin_r_it;
            (*it_main)->getOriginPose(origin_t_it, origin_r_it);
            r_drift_it_main = tmp_w1_r * origin_r_it.transpose();
            t_drift_it_main = tmp_w1_t - r_drift_it_main * origin_t_it;
            (*it_main)-> updatePose(tmp_w1_t, tmp_w1_r);
            
//            pMainMap->add2_r_global_multiClient(tmp_w1_r);
//            pMainMap->add2_t_global_multiClient(tmp_w1_t);
            r_global_main.push_back(tmp_w1_r);
            t_global_main.push_back(tmp_w1_t);

        }
        if ((*it_main)->global_index == latest_loop_index_main)
            break;
        i_main++;

    }
    //根据计算出当前帧的drift，更新全部关键帧位姿
    Vector3d cur_t_main, origin_t_main;
    Matrix3d cur_r_main, origin_r_main;
    //获取优化后当前帧的位姿cur_t,cur_r
    (*it_main)->getPose(cur_t_main, cur_r_main);
    //获取优化前有漂移的当前帧的位姿vio_t,vio_r
    (*it_main)->getOriginPose(origin_t_main, origin_r_main);
    pMainMap->yaw_drift = Utility::R2ypr(cur_r_main).x() - Utility::R2ypr(origin_r_main).x();
    pMainMap->r_drift = Utility::ypr2R(Vector3d(pMainMap->yaw_drift, 0, 0));
    pMainMap->t_drift = cur_t_main - pMainMap->r_drift * origin_t_main;
    
//    pMainMap->add2_r_global_multiClient(pMainMap->r_drift);
//    pMainMap->add2_t_global_multiClient(pMainMap->t_drift);
    r_global_main.push_back(pMainMap->r_drift);
    t_global_main.push_back(pMainMap->t_drift);
    pMainMap->add2_r_global_multiClient(r_global_main);
    pMainMap->add2_t_global_multiClient(t_global_main);
    
    if((r_global_main.size()-1)!=pMainMap->special_kf_inOpti.back().size()){
        cout<<"当前地图id"<<pMainMap->c->id<<" , "<<latest_loop_index_main<<endl;
        cout<<"resample_main下标数量不一致："<<r_global_main.size()<<" , "<<pMainMap->special_kf_inOpti.back().size()<<endl;
        while (pMainMap->special_kf_inOpti.size()!=2)
        {
            cout << pMainMap->special_kf_inOpti.front().size()<< " "; // Output the 1st element
            pMainMap->special_kf_inOpti.pop();  // Delete the 1st element
        }
        std::cout << std::endl;
        cout << "倒数第二个："<<pMainMap->special_kf_inOpti.front().size()<< endl;
        assert(false);//20 38
    }

    //下面代码为把当前关键帧it之后的关键帧的位姿通过求解的偏移量转换到world坐标系下
    for (; it_main != pMainMap->keyFrameList.end(); it_main++)
    {
        Vector3d P;
        Matrix3d R;
        (*it_main)->getOriginPose(P, R);
        P = pMainMap->r_drift * P + pMainMap->t_drift;
        R = pMainMap->r_drift * R;
        (*it_main)-> updatePose(P, R);
    }
    
//    pCurMap->isFirstFusion_globalMutex.unlock();
    
    
    
    
    
    pMainMap->lastKF_index.push(pMainMap->keyFrameList.back()->global_index);
//            位姿更新都留到显示那里
    pMainMap->updateVisualization();
    
    readWriteLock.readLock();
    PoseGraph* pMainMap_0=PoseGraphGloabl_map[0];
    readWriteLock.readUnLock();
    
   
    pAddKfMap->refine_path_mutex.lock();
    if(isUpdateFusionDraw){
        pMainMap_0->fusion_relative_isUpdate[pMainMap->c->id]=0;
        pMainMap_0->fusion_poseGraph_mutex.lock();
        pMainMap_0->fusion_otherGraph[pMainMap->c->id]=pMainMap;
        pMainMap_0->fusion_poseGraph_mutex.unlock();
    }
    pAddKfMap->refine_path_mutex.unlock();
    
    
    
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
        pMap_other->updateVisualization();
        pMap_other->isSendGloablData_multiClient=true;
        
        pAddKfMap->refine_path_mutex.lock();
        if(isUpdateFusionDraw){
            pMainMap_0->fusion_relative_isUpdate[pMap_other->c->id]=0;
            pMainMap_0->fusion_poseGraph_mutex.lock();
            pMainMap_0->fusion_otherGraph[pMap_other->c->id]=pMap_other;
            pMainMap_0->fusion_poseGraph_mutex.unlock();
        }
        pAddKfMap->refine_path_mutex.unlock();
        
        
        delete [](t_other_all[flag_start][0]);
        delete [](t_other_all[flag_start][1]);
        delete [](t_other_all[flag_start][2]);
        delete [](t_other_all[flag_start]);
        delete [](euler_other_all[flag_start][0]);
        delete [](euler_other_all[flag_start][1]);
        delete [](euler_other_all[flag_start][2]);
        delete [](euler_other_all[flag_start]);
              
    }
    //发送数据
    pMainMap->isSendGloablData_multiClient=true;
    //                    把之前锁住了的解锁了
//    for(int flag_start=0,flag_end=lock_all.size();flag_start<flag_end;flag_start++){
//        cout<<"解锁："<<flag_start<<endl;
//        (lock_all[flag_start])->unlock();
//    }
    cout<<"最终的全局优化结束"<<i<<endl;
//    cout<<"测试 偏移对不对"<<pCurMap->t_drift[0]<<" "<<pCurMap->t_drift[1]<<" "<<pCurMap->t_drift[2]<<endl;
    
    
}

//将现有优化的位姿当优化初始值  会出现很多不能收敛的
void PoseGraphGlobal::GlobalFuse_14(int i){
    cout<<"最终的全局优化"<<i<<endl;
    bool isUpdateFusionDraw=false;
//    cout<<"死锁没"<<endl;
    //因为现在写的都是和主地图发生地图融合 所以其中一个地图直接这么获取了
//    poseGraphGlobal_mutex.lock();
    readWriteLock.readLock();
    map<int,PoseGraph*>::iterator iter_map = PoseGraphGloabl_map.find(i);
    if(iter_map==PoseGraphGloabl_map.end())
    {
//        poseGraphGlobal_mutex.unlock();
        readWriteLock.readUnLock();
        assert(false);//都已经发生回环了，却找不到地图 说明数据插错
    }
    PoseGraph* pAddKfMap= iter_map->second;
    int len = PoseGraphGloabl_map.size();
    readWriteLock.readUnLock();
    
    vector<std::unique_lock<std::mutex>* > lock_all;
    std::unique_lock<std::mutex> lock(pAddKfMap->keyFrameList_global_fusion_mutex, std::defer_lock);
    if (lock.try_lock()) {
        cout<<"加锁："<<pAddKfMap->c->id<<endl;
        lock_all.push_back(&lock);
    } else {
        cout<<"最终的全局优化中断"<<i<<endl;
        return;
    }
    if(i==mainClientID){
        isUpdateFusionDraw=true;
    }

//    TODO 用来多用户ar 发送ar位姿的
    pAddKfMap->isFirstFusion_globalMutex.lock();
    isFusion[i]=1;
    pAddKfMap->isFirstFusion_globalMutex.unlock();
    
    double total_lenth_other=0.0;
    vector< double> length_other;
    PoseGraph* pMainMap;//id最小的
    vector<PoseGraph *> vMap_all;//除id最小,也就是匹配上的全部其它地图
    map<int,int> vMapId_all;//int表示clientId 后面表示存放在vMap_all的下标
    //找其它融合的地图 一起参与优化
    bool isFindMinClient=true;
    readWriteLock.readLock();
    if(PoseGraphGloabl_map.size()>1){
        readWriteLock.readUnLock();
        for(int client_id=0;client_id<len;client_id++){//这里的i其实代表的就是 ClientId
            if(client_id==i){
                continue;
            }
            if(uf.isConnected(i, client_id)){
                readWriteLock.readLock();
                map<int,PoseGraph*>::iterator iter_map_other = PoseGraphGloabl_map.find(client_id);
                if(iter_map_other==PoseGraphGloabl_map.end()){
                    readWriteLock.readUnLock();
                    continue;
                }
                PoseGraph* pOtherMap= iter_map_other->second;//新的地图 小的地图
                readWriteLock.readUnLock();
                
                
                
//                cout <<"锁定"<< pOtherMap->c->id<<endl;
                std::unique_lock<std::mutex> lock(pOtherMap->keyFrameList_global_fusion_mutex, std::defer_lock);
                if (lock.try_lock()) {
                    cout<<"加锁："<<pOtherMap->c->id<<endl;
                    lock_all.push_back(&lock);
                } else {
                    //                    把之前锁住了的解锁了
                    cout<<"最终的全局优化中断"<<pOtherMap->c->id<<endl;
//                    for(int flag_start=0,flag_end=lock_all.size();flag_start<flag_end;flag_start++){
//                        cout<<"解锁："<<flag_start<<endl;
//                        (lock_all[flag_start])->unlock();
//                    }
                    return;
                }
         
                
                if(isFindMinClient){
                    isFindMinClient=false;
                    if(i>client_id){
//                        这里就是id最小的地图
                        pMainMap=pOtherMap;
//                        cout<<"主地图大小："<<pMainMap->size()<<endl;
                      
                        vMap_all.push_back(pAddKfMap);
                        vMapId_all.insert(make_pair(pAddKfMap->c->id,vMap_all.size()-1));
                        total_lenth_other+=pAddKfMap->total_length;
                        length_other.push_back(pAddKfMap->total_length);
                        
                        if(client_id==mainClientID){
                            isUpdateFusionDraw=true;
                        }
                        continue;
                    }else{
                        pMainMap=pAddKfMap;
                    }
                }
                vMap_all.push_back(pOtherMap);
                vMapId_all.insert(make_pair(pOtherMap->c->id,vMap_all.size()-1));
                
                total_lenth_other+=pOtherMap->total_length;
                length_other.push_back(pOtherMap->total_length);
                
            }
            
        }
    }
    else{
        readWriteLock.readUnLock();
        assert(false);//都要发生全局优化了 却只有1个地图
    }
    
   
    
    //主地图从earliest_loop_index_main开始--当前帧结束
    //小地图从第一帧开始--当前发生回环的帧 这个有可能是回环帧，也有可能是融合帧
    ceres::Problem problem;
    ceres::Solver::Options options;
    //options.linear_solver_type = ceres::DENSE_NORMAL_CHOLESKY;
    options.linear_solver_type = ceres::DENSE_SCHUR;
    options.minimizer_progress_to_stdout = false;
    options.max_num_iterations = 6;
    ceres::Solver::Summary summary;
    ceres::LossFunction *loss_function;
    loss_function = new ceres::HuberLoss(1.0);
    //AngleLocalParameterization类的主要作用是指定yaw角优化变量的迭代更新，重载了括号运算
    ceres::LocalParameterization* angle_local_parameterization =
    AngleLocalParameterization::Create();
            
    
    double total_lenth_main=pMainMap->total_length;
    //总的位姿长度 除以总的帧数
    double total_lenth_sum=total_lenth_main+total_lenth_other;
    int max_frame_num_global_main=(total_lenth_main/total_lenth_sum)*max_frame_num_global;
    double min_dis_main=total_lenth_main/max_frame_num_global_main;
    
    //要优化的变量的最大个数 主地图
    int max_length_main=pMainMap->size()+1;
    double t_array_main[max_length_main][3];//平移数组，其中存放每个关键帧的平移向量
    Quaterniond q_array_main[max_length_main];
    double euler_array_main[max_length_main][3];
    vector<bool> need_resample_main;
    
    double t_array_main_ori[max_length_main][3];//平移数组，其中存放每个关键帧的平移向量
    Quaterniond q_array_main_ori[max_length_main];
    double euler_array_main_ori[max_length_main][3];
    
    pMainMap->max_frame_num_global=max_frame_num_global_main;
    pMainMap->min_dis=min_dis_main;
    

    const int mapOther_sum=vMap_all.size();
    vector< double** > t_other_all;
    vector< vector<Quaterniond > > q_other_all;
    vector< double** > euler_other_all;
    vector< vector<bool> > resample_other_all;
    
    vector< double** > t_other_all_ori;
    vector< vector<Quaterniond > > q_other_all_ori;
    vector< double** > euler_other_all_ori;
    
    int earliest_loop_index_main=pMainMap->earliest_loop_index;
    int earliest_global_looped_index_main=earliest_globalLoop_index[pMainMap->c->id];
    if (earliest_loop_index_main > earliest_global_looped_index_main || earliest_loop_index_main == -1  )
        earliest_loop_index_main=earliest_global_looped_index_main;
    
    int latest_loop_index_main=pMainMap->latest_loop_index;
    int latest_global_looped_index_main=latest_globalLoop_index[pMainMap->c->id];
    if (latest_global_looped_index_main > latest_loop_index_main)
        latest_loop_index_main=latest_global_looped_index_main;
//    pMainMap->loop_index_multiClient.push(earliest_loop_index_main);
//    pMainMap->curKF_loop_index_multiClient.push(latest_loop_index_main);//这个是要发回客户端 用来更新位姿的 TODO 后面要改改
    
    vector<int> earliest_loopIndex_other_all;
    vector<int> latest_loopIndex_other_all;
    
    
    vector<int> latest_loop_index_other_update;
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
        
        int earliest_loop_index_other=pMap_other->earliest_loop_index;
        int earliest_global_looped_index_other=earliest_globalLoop_index[pMap_other->c->id];
        if (earliest_loop_index_other > earliest_global_looped_index_other || earliest_loop_index_other == -1  )
            earliest_loop_index_other=earliest_global_looped_index_other;
        earliest_loopIndex_other_all.push_back(earliest_loop_index_other);
        
        int latest_loop_index_other=pMap_other->latest_loop_index;
        int latest_global_looped_index_other=latest_globalLoop_index[pMap_other->c->id];
        if (latest_global_looped_index_other > latest_loop_index_other)
            latest_loop_index_other=latest_global_looped_index_other;
        latest_loopIndex_other_all.push_back(latest_loop_index_other);
        
//        pMap_other->isFirstFusion_globalMutex.lock();
//        pMap_other->loop_index_multiClient.push(0);
//        pMap_other->curKF_loop_index_multiClient.push(latest_loop_index_other);
//        pMap_other->isFirstFusion_globalMutex.unlock();
        
        latest_loop_index_other_update.push_back(latest_loop_index_other);
        
        
        double total_length_otherMap=length_other[flag_start];
        int max_frame_num_global_other=(total_length_otherMap/total_lenth_sum)*max_frame_num_global;
        double min_dis_other=total_length_otherMap/max_frame_num_global_other;
        pMap_other->max_frame_num_global=max_frame_num_global_other;
        pMap_other->min_dis=min_dis_other;
        
        //要优化的变量的最大个数 小地图
        int max_length_other=pMap_other->keyFrameList.size()+1;
        double** t_test=new double*[max_length_other];
        for(int index_flag=0;index_flag<max_length_other;index_flag++) t_test[index_flag] = new double[3];
        t_other_all.push_back(t_test);
        
        vector<Quaterniond > q_array_other(max_length_other);
        q_other_all.push_back(q_array_other);
        
        double** euler_test=new double*[max_length_other];
        for(int index_flag=0;index_flag<max_length_other;index_flag++) euler_test[index_flag] = new double[3];
        euler_other_all.push_back(euler_test);
        
        vector<bool> need_resample_other;
        resample_other_all.push_back(need_resample_other);
        
        
        double** t_test_ori=new double*[max_length_other];
        for(int index_flag=0;index_flag<max_length_other;index_flag++) t_test_ori[index_flag] = new double[3];
        t_other_all_ori.push_back(t_test_ori);

        vector<Quaterniond > q_array_other_ori(max_length_other);
        q_other_all_ori.push_back(q_array_other_ori);

        double** euler_test_ori=new double*[max_length_other];
        for(int index_flag=0;index_flag<max_length_other;index_flag++) euler_test_ori[index_flag] = new double[3];
        euler_other_all_ori.push_back(euler_test_ori);
    }
   
    

    vector<int> special_kf_inOpti_main;
    vector<int> kf_id_hasComPlace_main;
    //遍历关键帧列表
    list<KeyFrame*>::iterator it_main = pMainMap->keyFrameList.begin();
    Vector3d last_P_main = Vector3d(0, 0, 0);
    double dis_main = 0;
    int resample_id=0;
    for(;it_main!=pMainMap->keyFrameList.end();it_main++){
        if((*it_main)->global_index < earliest_loop_index_main){
            continue;
        }
        (*it_main)->resample_globalIndex = resample_id;
        Vector3d tmp_t;
        Matrix3d tmp_r;
        //获取关键帧it的位姿
        (*it_main)->getPose(tmp_t, tmp_r);
        dis_main += (tmp_t - last_P_main).norm();
        //全局优化 还是要加序列边 不然太长了 判断条件 再加个两个地图之间发生了融合
        if((*it_main)->global_index == earliest_loop_index_main || dis_main > min_dis_main || (*it_main)->is_get_loop_info || (*it_main)->is_looped || (*it_main)->has_global_loop || (*it_main)->is_global_looped || pMainMap->keyFrameList.size() < max_frame_num_global_main)
        {
            dis_main = 0;
            last_P_main = tmp_t;
            need_resample_main.push_back(0);
            
//            pMainMap->special_kf_inOpti.push_back((*it_main)->global_index);
            special_kf_inOpti_main.push_back((*it_main)->global_index);
            
            if(((*it_main)->has_global_loop || (*it_main)->is_global_looped) && (*it_main)->is_Send==false ){
                kf_id_hasComPlace_main.push_back((*it_main)->global_index);
//                pMainMap->add2_kf_id_hasComPlace_withOtherMap((*it_main)->global_index);
                (*it_main)->is_Send=true;
            }
            
        }
        else
        {
            last_P_main = tmp_t;
            need_resample_main.push_back(1);
        }
        
        Quaterniond tmp_q;
        Matrix3d tmp_r_origin;
        Vector3d tmp_t_origin;
//        (*it_main)->getOriginPose(tmp_t_origin, tmp_r_origin);
                (*it_main)->getPose(tmp_t_origin, tmp_r_origin);
        tmp_q = tmp_r_origin;
        t_array_main[resample_id][0] = tmp_t_origin(0);
        t_array_main[resample_id][1] = tmp_t_origin(1);
        t_array_main[resample_id][2] = tmp_t_origin(2);
        q_array_main[resample_id] = tmp_q;
        //将矩阵转换为向量
        Vector3d euler_angle = Utility::R2ypr(tmp_r_origin);
        euler_array_main[resample_id][0] = euler_angle.x();
        euler_array_main[resample_id][1] = euler_angle.y();
        euler_array_main[resample_id][2] = euler_angle.z();
        
        
        (*it_main)->getOriginPose(tmp_t_origin, tmp_r_origin);
        tmp_q = tmp_r_origin;
        t_array_main_ori[resample_id][0] = tmp_t_origin(0);
        t_array_main_ori[resample_id][1] = tmp_t_origin(1);
        t_array_main_ori[resample_id][2] = tmp_t_origin(2);
        q_array_main_ori[resample_id] = tmp_q;
        //将矩阵转换为向量
        euler_angle = Utility::R2ypr(tmp_r_origin);
        euler_array_main_ori[resample_id][0] = euler_angle.x();
        euler_array_main_ori[resample_id][1] = euler_angle.y();
        euler_array_main_ori[resample_id][2] = euler_angle.z();
        
        resample_id++;
        
        if ((*it_main)->global_index == latest_loop_index_main)
            break;
    }
    
//    pMainMap->special_kf_mutex.lock();
//    pMainMap->add2_kf_id_hasComPlace_withOtherMap(kf_id_hasComPlace_main);
//   pMainMap->special_kf_inOpti.push(special_kf_inOpti_main);
//   pMainMap->special_kf_mutex.unlock();
    
    vector<vector<int>> special_kf_inOpti_cur_all;
    vector<vector<int>> kf_id_hasComPlace_cur_all;
    
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
        //遍历关键帧列表
        list<KeyFrame*>::iterator it_other = pMap_other->keyFrameList.begin();

        Vector3d last_P_other = Vector3d(0, 0, 0);
        double dis_other = 0;
        
        vector<int> special_kf_inOpti_cur;
        vector<int> kf_id_hasCom_cur;
        resample_id=0;
        resample_other_all[flag_start].clear();
       
        //小地图是从第一个帧开始优化
        for(;it_other!=pMap_other->keyFrameList.end();it_other++){
            (*it_other)->resample_globalIndex = resample_id;
            
            Vector3d tmp_t;
            Matrix3d tmp_r;
            //获取关键帧it的位姿
            (*it_other)->getPose(tmp_t, tmp_r);
            dis_other += (tmp_t - last_P_other).norm();
            
            
            //全局优化 还是要加序列边 不然太长了 判断条件 再加个两个地图之间发生了融合
            //第一个地图融合位置，超过长度了，发生过回环，被回环了，总共的帧长度比最大值小
            //还要再加一个 发生了融合，被融合了
            if((*it_other)->global_index == 0 || dis_other > pMap_other->min_dis || (*it_other)->is_get_loop_info || (*it_other)->is_looped || (*it_other)->has_global_loop || (*it_other)->is_global_looped || pMap_other->keyFrameList.size() < pMap_other->max_frame_num_global)
            {
                dis_other = 0;
                last_P_other = tmp_t;
                resample_other_all[flag_start].push_back(0);
                
    //            pCurMap->special_kf_inOpti.push_back((*it_other)->global_index);
                special_kf_inOpti_cur.push_back((*it_other)->global_index);
                
                if(((*it_other)->has_global_loop || (*it_other)->is_global_looped) && (*it_other)->is_Send==false ){
                    kf_id_hasCom_cur.push_back((*it_other)->global_index);
    //                pCurMap->add2_kf_id_hasComPlace_withOtherMap((*it_other)->global_index);
                    (*it_other)->is_Send=true;
                }
                
            }
            else
            {
                last_P_other = tmp_t;
                resample_other_all[flag_start].push_back(1);
            }
            
            Quaterniond tmp_q;
            Matrix3d tmp_r_origin;
            Vector3d tmp_t_origin;
//            (*it_other)->getOriginPose(tmp_t_origin, tmp_r_origin);
                    (*it_main)->getPose(tmp_t_origin, tmp_r_origin);
            tmp_q = tmp_r_origin;
            (t_other_all[flag_start])[resample_id][0] = tmp_t_origin(0);
            (t_other_all[flag_start])[resample_id][1] = tmp_t_origin(1);
            (t_other_all[flag_start])[resample_id][2] = tmp_t_origin(2);
            q_other_all[flag_start][resample_id] = tmp_q;
            //将矩阵转换为向量
            Vector3d euler_angle = Utility::R2ypr(tmp_r_origin);
            euler_other_all[flag_start][resample_id][0] = euler_angle.x();
            euler_other_all[flag_start][resample_id][1] = euler_angle.y();
            euler_other_all[flag_start][resample_id][2] = euler_angle.z();
            
            
            (*it_other)->getOriginPose(tmp_t_origin, tmp_r_origin);
            tmp_q = tmp_r_origin;
            (t_other_all_ori[flag_start])[resample_id][0] = tmp_t_origin(0);
            (t_other_all_ori[flag_start])[resample_id][1] = tmp_t_origin(1);
            (t_other_all_ori[flag_start])[resample_id][2] = tmp_t_origin(2);
            q_other_all_ori[flag_start][resample_id] = tmp_q;
            //将矩阵转换为向量
            euler_angle = Utility::R2ypr(tmp_r_origin);
            euler_other_all_ori[flag_start][resample_id][0] = euler_angle.x();
            euler_other_all_ori[flag_start][resample_id][1] = euler_angle.y();
            euler_other_all_ori[flag_start][resample_id][2] = euler_angle.z();
            
            resample_id++;
            
            if ((*it_other)->global_index == latest_loopIndex_other_all[flag_start])
                break;
        }
        
//        pMap_other->special_kf_mutex.lock();
//        pMap_other->add2_kf_id_hasComPlace_withOtherMap(kf_id_hasCom_cur);
//        pMap_other->special_kf_inOpti.push(special_kf_inOpti_cur);
//        pMap_other->special_kf_mutex.unlock();
        
        
        special_kf_inOpti_cur_all.push_back(special_kf_inOpti_cur);
        kf_id_hasComPlace_cur_all.push_back(kf_id_hasCom_cur);
        
    }
    
    
    int i_main = 0;
    for (it_main = pMainMap->keyFrameList.begin(); it_main != pMainMap->keyFrameList.end(); it_main++)
    {
        if ((*it_main)->global_index < earliest_loop_index_main)
            continue;
//        (*it_main)->resample_globalIndex = i_main;
        
//        Quaterniond tmp_q;
//        Matrix3d tmp_r;
//        Vector3d tmp_t;
//        (*it_main)->getOriginPose(tmp_t, tmp_r);
////                (*it_main)->getPose(tmp_t, tmp_r);
//        tmp_q = tmp_r;
//        t_array_main[i_main][0] = tmp_t(0);
//        t_array_main[i_main][1] = tmp_t(1);
//        t_array_main[i_main][2] = tmp_t(2);
//        q_array_main[i_main] = tmp_q;
//        //将矩阵转换为向量
//        Vector3d euler_angle = Utility::R2ypr(tmp_r);
//        euler_array_main[i_main][0] = euler_angle.x();
//        euler_array_main[i_main][1] = euler_angle.y();
//        euler_array_main[i_main][2] = euler_angle.z();
        //将关键帧列表中所有index>=earliest_loop_index的关键帧的位姿加入到参数块当中
        problem.AddParameterBlock(euler_array_main[i_main], 1, angle_local_parameterization);
        problem.AddParameterBlock(t_array_main[i_main], 3);
//        cout<<"主地图数据r："<<euler_array_main[i_main][0]<<" , "<<euler_array_main[i_main][1]<<" , "<<euler_array_main[i_main][2]<<endl;
//        cout<<"主地图数据t："<<t_array_main[i_main][0]<<" , "<<t_array_main[i_main][1]<<" , "<<t_array_main[i_main][2]<<endl;
        //设置约束：如果该帧是最早的闭环帧的情况下，则固定它的位姿
        if ((*it_main)->global_index == earliest_loop_index_main)
        {
            problem.SetParameterBlockConstant(euler_array_main[i_main]);
            problem.SetParameterBlockConstant(t_array_main[i_main]);
//                cout<<"测试 更新哪里变了："<<euler_array_main[i_main][0]<<" "<<euler_array_main[i_main][1]<<" "<<euler_array_main[i_main][2]<<" "<<t_array_main[i_main][0]<<" "<<t_array_main[i_main][1]<<" "<<t_array_main[i_main][2]<<" "<<i_main<<endl;
        }
        
        if(need_resample_main[i_main])
        {
            i_main++;
            continue;
        }
        
        
        int j = 1, sequence_link_cnt = 0;
        while(sequence_link_cnt < 5)
        {
            if (i_main - j >= 0)
            {
//                        list<KeyFrame*>::iterator tmp = it_main;
//                        std::advance (tmp, -j);
                if(need_resample_main[i_main-j])
                {
                    j++;
                    continue;
                }
                else
                {
                    sequence_link_cnt++;
                }
//                Vector3d euler_conncected = Utility::R2ypr(q_array_main[i_main-j].toRotationMatrix());
//                //p̂_j^w - p̂_i^w 计算平移量的偏差
//                Vector3d relative_t(t_array_main[i_main][0] - t_array_main[i_main-j][0], t_array_main[i_main][1] - t_array_main[i_main-j][1], t_array_main[i_main][2] - t_array_main[i_main-j][2]);
//                //p̂_{ij}^{i} = {R̂_i^w}^{-1} (p̂_j^w - p̂_i^w)
//                //p̂ ij= (R̂ iw ) (p̂ jw − p̂ iw )
//                relative_t = q_array_main[i_main-j].inverse() * relative_t;
//                //ψ̂ _ij = ψ̂ _j − ψ̂ _i
//                double relative_yaw = euler_array_main[i_main][0] - euler_array_main[i_main-j][0];
                
                
                Vector3d euler_conncected = Utility::R2ypr(q_array_main_ori[i_main-j].toRotationMatrix());
                //p̂_j^w - p̂_i^w 计算平移量的偏差
                Vector3d relative_t(t_array_main_ori[i_main][0] - t_array_main_ori[i_main-j][0], t_array_main_ori[i_main][1] - t_array_main_ori[i_main-j][1], t_array_main_ori[i_main][2] - t_array_main_ori[i_main-j][2]);
                //p̂_{ij}^{i} = {R̂_i^w}^{-1} (p̂_j^w - p̂_i^w)
                //p̂ ij= (R̂ iw ) (p̂ jw − p̂ iw )
                relative_t = q_array_main_ori[i_main-j].inverse() * relative_t;
                //ψ̂ _ij = ψ̂ _j − ψ̂ _i
                double relative_yaw = euler_array_main_ori[i_main][0] - euler_array_main_ori[i_main-j][0];
                
//                cout<<"主地图序列帧relative_t："<<relative_t[0]<<" , "<<relative_t[1]<<" , "<<relative_t[2]<<endl;
//                cout<<"主地图序列帧euler_conncected："<<euler_conncected[0]<<" , "<<euler_conncected[1]<<" , "<<euler_conncected[2]<<endl;
//                cout<<"主地图序列帧relative_yaw："<<relative_yaw<<endl;
                ceres::CostFunction* cost_function = FourDOFError_another::Create( relative_t.x(), relative_t.y(), relative_t.z(),
                                                                          relative_yaw, euler_conncected.y(), euler_conncected.z());
                problem.AddResidualBlock(cost_function, loss_function, euler_array_main[i_main-j],
                                         t_array_main[i_main-j],
                                         euler_array_main[i_main],
                                         t_array_main[i_main]);
            }
            else
            {
                break;
            }
            j++;
        }

        //        添加的是闭环边，是指检测到闭环的两帧
        if((*it_main)->is_get_loop_info   )
        {
            if((*it_main)->loop_index >= earliest_loop_index_main)
            {
                int connected_index = pMainMap->getKeyframe((*it_main)->loop_index)->resample_globalIndex;

//                Vector3d euler_conncected = Utility::R2ypr(q_array_main[connected_index].toRotationMatrix());
//                Vector3d relative_t((*it_main)->loop_info_better(0), (*it_main)->loop_info_better(1), (*it_main)->loop_info_better(2));
//                double relative_yaw = (*it_main)->loop_info_better(3);
                
                
                Vector3d euler_conncected = Utility::R2ypr(q_array_main_ori[connected_index].toRotationMatrix());
                Vector3d relative_t((*it_main)->loop_info_better(0), (*it_main)->loop_info_better(1), (*it_main)->loop_info_better(2));
                double relative_yaw = (*it_main)->loop_info_better(3);
//                cout<<"主地图回环relative_t："<<relative_t[0]<<" , "<<relative_t[1]<<" , "<<relative_t[2]<<endl;
//                cout<<"主地图回环euler_conncected："<<euler_conncected[0]<<" , "<<euler_conncected[1]<<" , "<<euler_conncected[2]<<endl;
//                cout<<"主地图回环relative_yaw："<<relative_yaw<<endl;
                ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),
                                                                                relative_yaw, euler_conncected.y(), euler_conncected.z(),10.0);
                problem.AddResidualBlock(cost_function, NULL, euler_array_main[connected_index],
                                         t_array_main[connected_index],
                                         euler_array_main[i_main],
                                         t_array_main[i_main]);
            }else{
                assert(false);//报错
            }
        }

        
        if((*it_main)->has_global_loop)
       {
           //这里后面还要添加else
           if((*it_main)->global_loop_index < 0)
           {
               //因为这意味着数据保存出错了 发生了融合的帧的id小于最早发生融合的id
               assert(false);
               return;
           }
//           获取是和哪个其它地图发生了回环
           (*it_main)->readWriteLock_loop.readLock();
           int loop_index_flag_end=(*it_main)->clientId.size();
           (*it_main)->readWriteLock_loop.readUnLock();
//           遍历该帧的 所有回环帧
           for(int loop_index_flag=0;loop_index_flag<loop_index_flag_end;loop_index_flag++){
               (*it_main)->readWriteLock_loop.readLock();
               int matching_clientId=(*it_main)->clientId[loop_index_flag];
               int matching_kfId=(*it_main)->kfId[loop_index_flag];
               std::pair<Matrix3d , Vector3d > matching_rt=(*it_main)->relativePose[loop_index_flag];
               (*it_main)->readWriteLock_loop.readUnLock();
               
//               找到这个对应的其它地图
               int vmap_index=vMapId_all[matching_clientId];
               PoseGraph * pMap_other=vMap_all[vmap_index];
               //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束 会出现空指针的问题
               int connected_index = pMap_other->getKeyframe(matching_kfId)->resample_globalIndex;//这里可能多个
               
//               Vector3d euler_conncected = Utility::R2ypr(matching_rt.first);
//               Vector3d relative_t=matching_rt.second;
//               double relative_yaw = euler_conncected[0]-euler_other_all[vmap_index][connected_index][0];
//               cout<<"主地图共同探索kfid"<<matching_kfId<<" , "<<earliest_loopIndex_other_all[vmap_index]<<endl;
//               cout<<"主地图共同探索matching_clientId"<<matching_clientId<<" , "<<vmap_index<<" , "<<latest_loopIndex_other_all[vmap_index]<<endl;
               cout<<"主地图共同探索connected_index"<<connected_index<<" , "<<vmap_index<<" , "<<matching_clientId<<endl;
               cout<<"主地图q"<<q_other_all[vmap_index][connected_index].x()<<", "<<q_other_all[vmap_index][connected_index].y()<<", "<<q_other_all[vmap_index][connected_index].z()<<" , "<<q_other_all[vmap_index][connected_index].w()<<endl;
               if(matching_kfId < earliest_loopIndex_other_all[vmap_index])
               {
                   //因为这意味着数据保存出错了 发生了融合的帧的id小于最早发生融合的id
                   assert(false);
                   return;
               }
               
//               Vector3d euler_conncected = Utility::R2ypr(q_other_all[vmap_index][connected_index].toRotationMatrix());
               
               Vector3d euler_conncected = Utility::R2ypr(q_other_all_ori[vmap_index][connected_index].toRotationMatrix());
               Vector3d relative_t((*it_main)->relative_global_loop_info_multiClient[loop_index_flag](0), (*it_main)->relative_global_loop_info_multiClient[loop_index_flag](1), (*it_main)->relative_global_loop_info_multiClient[loop_index_flag](2));
               double relative_yaw = (*it_main)->relative_global_loop_info_multiClient[loop_index_flag](7);
               
//               cout<<"主地图共同探索relative_t："<<relative_t[0]<<" , "<<relative_t[1]<<" , "<<relative_t[2]<<endl;
//               cout<<"主地图共同探索euler_conncected："<<euler_conncected[0]<<" , "<<euler_conncected[1]<<" , "<<euler_conncected[2]<<endl;
//               cout<<"主地图共同探索relative_yaw："<<relative_yaw<<endl;
               //这里到时候 再写一个求导的
               ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z(),10.0);
               problem.AddResidualBlock(cost_function, NULL, euler_other_all[vmap_index][connected_index] ,
                                       t_other_all[vmap_index][connected_index] ,
                                        euler_array_main[i_main],
                                        t_array_main[i_main]);
           }
          
           
           
       }
        
        
        if ((*it_main)->global_index == latest_loop_index_main)
            break;
        i_main++;
    }
    
    
    //*************************************第一个数据
    
    int i_other = 0;
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
        i_other = 0;
        for (auto it_other = pMap_other->keyFrameList.begin(); it_other != pMap_other->keyFrameList.end(); it_other++)
        {
    //        (*it_other)->resample_globalIndex = i_other;
            
//            Quaterniond tmp_q;
//            Matrix3d tmp_r;
//            Vector3d tmp_t;
//            (*it_other)->getOriginPose(tmp_t, tmp_r);
//
//            tmp_q=tmp_r;
//
//            (t_other_all[flag_start])[i_other][0]=tmp_t.x();
//            (t_other_all[flag_start])[i_other][1]=tmp_t.y();
//            (t_other_all[flag_start])[i_other][2]=tmp_t.z();
//
////            int len = sizeof(q_other_all[flag_start]) / sizeof(q_other_all[flag_start][0]);
//            q_other_all[flag_start][i_other]=tmp_q;
//
//            //将矩阵转换为向量
//            Vector3d euler_angle = Utility::R2ypr(tmp_r);
//            euler_other_all[flag_start][i_other][0] = euler_angle.x();
//            euler_other_all[flag_start][i_other][1] = euler_angle.y();
//            euler_other_all[flag_start][i_other][2] = euler_angle.z();
            //将关键帧列表中所有index>=earliest_loop_index的关键帧的位姿加入到参数块当中
           
            problem.AddParameterBlock(euler_other_all[flag_start][i_other], 1, angle_local_parameterization);
            problem.AddParameterBlock(t_other_all[flag_start][i_other], 3);
//            cout<<"其它地图数据r："<<euler_other_all[flag_start][i_other][0]<<" , "<<euler_other_all[flag_start][i_other][1]<<" , "<<euler_other_all[flag_start][i_other][2]<<endl;
//            cout<<"其它地图数据t："<<t_other_all[flag_start][i_other][0]<<" , "<<t_other_all[flag_start][i_other][1]<<" , "<<t_other_all[flag_start][i_other][2]<<endl;

            if(resample_other_all[flag_start][i_other])
            {
               
                i_other++;
                continue;
            }


            int j = 1, sequence_link_cnt = 0;
            while(sequence_link_cnt < 5)
            {
                if (i_other - j >= 0)
                {
    //                        list<KeyFrame*>::iterator tmp = it_other;
    //                        std::advance (tmp, -j);
                    if(resample_other_all[flag_start][i_other-j])
                    {
                        j++;
                        continue;
                    }
                    else
                    {
                        sequence_link_cnt++;
                    }
//                    Vector3d euler_conncected = Utility::R2ypr(q_other_all[flag_start][i_other-j].toRotationMatrix());
//                    //p̂_j^w - p̂_i^w 计算平移量的偏差
//                    Vector3d relative_t(t_other_all[flag_start][i_other][0] - t_other_all[flag_start][i_other-j][0], t_other_all[flag_start][i_other][1] - t_other_all[flag_start][i_other-j][1], t_other_all[flag_start][i_other][2] - t_other_all[flag_start][i_other-j][2]);
//                    //p̂_{ij}^{i} = {R̂_i^w}^{-1} (p̂_j^w - p̂_i^w)
//                    //p̂ ij= (R̂ iw ) (p̂ jw − p̂ iw )
//                    relative_t = q_other_all[flag_start][i_other-j].inverse() * relative_t;
//                    //ψ̂ _ij = ψ̂ _j − ψ̂ _i
//                    double relative_yaw = euler_other_all[flag_start][i_other][0] - euler_other_all[flag_start][i_other-j][0];
                    
                    Vector3d euler_conncected = Utility::R2ypr(q_other_all_ori[flag_start][i_other-j].toRotationMatrix());
                    //p̂_j^w - p̂_i^w 计算平移量的偏差
                    Vector3d relative_t(t_other_all_ori[flag_start][i_other][0] - t_other_all_ori[flag_start][i_other-j][0], t_other_all_ori[flag_start][i_other][1] - t_other_all_ori[flag_start][i_other-j][1], t_other_all_ori[flag_start][i_other][2] - t_other_all_ori[flag_start][i_other-j][2]);
                    //p̂_{ij}^{i} = {R̂_i^w}^{-1} (p̂_j^w - p̂_i^w)
                    //p̂ ij= (R̂ iw ) (p̂ jw − p̂ iw )
                    relative_t = q_other_all_ori[flag_start][i_other-j].inverse() * relative_t;
                    //ψ̂ _ij = ψ̂ _j − ψ̂ _i
                    double relative_yaw = euler_other_all_ori[flag_start][i_other][0] - euler_other_all_ori[flag_start][i_other-j][0];
                    
                    
//                    cout<<"其它地图序列帧relative_t："<<relative_t[0]<<" , "<<relative_t[1]<<" , "<<relative_t[2]<<endl;
//                    cout<<"其它地图序列帧euler_conncected："<<euler_conncected[0]<<" , "<<euler_conncected[1]<<" , "<<euler_conncected[2]<<endl;
//                    cout<<"其它地图序列帧relative_yaw："<<relative_yaw<<endl;
                    ceres::CostFunction* cost_function = FourDOFError_another::Create( relative_t.x(), relative_t.y(), relative_t.z(),
                                                                              relative_yaw, euler_conncected.y(), euler_conncected.z());
                    problem.AddResidualBlock(cost_function, loss_function, euler_other_all[flag_start][i_other-j],
                                             t_other_all[flag_start][i_other-j],
                                             euler_other_all[flag_start][i_other],
                                             t_other_all[flag_start][i_other]);
                }
                else
                {
                    break;
                }
                j++;
            }
          
            //        添加的是闭环边，是指检测到闭环的两帧 一个数据拆成两份 这个注释掉了
            if((*it_other)->is_get_loop_info)
            {
                //这里后面还要添加else
                if((*it_other)->loop_index <0)
                {
                    assert(false);
                }
                //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束
                int connected_index = pMap_other->getKeyframe((*it_other)->loop_index)->resample_globalIndex;

//                Vector3d euler_conncected = Utility::R2ypr(q_other_all[flag_start][connected_index].toRotationMatrix());
                
                Vector3d euler_conncected = Utility::R2ypr(q_other_all_ori[flag_start][connected_index].toRotationMatrix());
                Vector3d relative_t((*it_other)->loop_info_better(0), (*it_other)->loop_info_better(1), (*it_other)->loop_info_better(2));
                double relative_yaw = (*it_other)->loop_info_better(3);

    //                    cout<<fixed<<setprecision(6)<<"(*it_other)->loop_info(0)"<<(*it_other)->loop_info_better(0)<<" (*it_other)->loop_info(1)"<<(*it_other)->loop_info_better(1)<<" (*it_other)->loop_info(2)"<<(*it_other)->loop_info_better(2)<<" (*it_other)->loop_info(7)"<<(*it_other)->loop_info_better(3)<<" "<<(*it_other)->header<<" "<<pCurMap->getKeyframe((*it_other)->global_index)->header<<endl;
//                cout<<"其它地图回环relative_t："<<relative_t[0]<<" , "<<relative_t[1]<<" , "<<relative_t[2]<<endl;
//                cout<<"其它地图回环euler_conncected："<<euler_conncected[0]<<" , "<<euler_conncected[1]<<" , "<<euler_conncected[2]<<endl;
//                cout<<"其它地图回环relative_yaw："<<relative_yaw<<endl;
                
                ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z(),10.0);
                problem.AddResidualBlock(cost_function, NULL, euler_other_all[flag_start][connected_index],
                                         t_other_all[flag_start][connected_index],
                                         euler_other_all[flag_start][i_other],
                                         t_other_all[flag_start][i_other]);
                
            }
           
            if((*it_other)->has_global_loop)
           {
    //           获取是和哪个其它地图发生了回环
              (*it_other)->readWriteLock_loop.readLock();
              int loop_index_flag_end=(*it_other)->clientId.size();
              (*it_other)->readWriteLock_loop.readUnLock();
    //           遍历该帧的 所有回环帧
              for(int loop_index_flag=0;loop_index_flag<loop_index_flag_end;loop_index_flag++){
                  (*it_other)->readWriteLock_loop.readLock();
                  int matching_clientId=(*it_other)->clientId[loop_index_flag];
                  int matching_kfId=(*it_other)->kfId[loop_index_flag];
                  std::pair<Matrix3d , Vector3d > matching_rt=(*it_other)->relativePose[loop_index_flag];
                  (*it_other)->readWriteLock_loop.readUnLock();
                  
//                  Vector3d euler_conncected = Utility::R2ypr(matching_rt.first);
//                  Vector3d relative_t=matching_rt.second;
//                  double relative_yaw = euler_conncected[0];
                  
                  if(matching_clientId==pMainMap->c->id){
                      if(matching_kfId < earliest_loop_index_main)
                      {
                          //因为这意味着数据保存出错了 发生了融合的帧的id小于最早发生融合的id
                          assert(false);
                          return;
                      }
                      //说明是和此次新增地图 发生匹配
                      //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束
                      int connected_index = pMainMap->getKeyframe(matching_kfId)->resample_globalIndex;
                      
//                      double relative_yaw =euler_conncected[0]-euler_array_main[connected_index][0];
                      
//                      Vector3d euler_conncected = Utility::R2ypr(q_array_main[connected_index].toRotationMatrix());
                      
                      Vector3d euler_conncected = Utility::R2ypr(q_array_main_ori[connected_index].toRotationMatrix());
                      Vector3d relative_t((*it_other)->relative_global_loop_info_multiClient[loop_index_flag](0), (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](1), (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](2));
                      double relative_yaw = (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](7);
////                      cout<<"其它地图共同探索0kfid"<<matching_kfId<<" , "<<earliest_loop_index_main<<endl;
////                      cout<<"其它地图共同探索0matching_clientId"<<matching_clientId<<" , "<<latest_loop_index_main<<endl;
////                      cout<<"其它地图共同探索0connected_index"<<connected_index<<" , "<<sizeof(q_array_main) / sizeof(q_array_main[0])<<endl;
//                      cout<<"其它地图共同探索connected_index"<<connected_index<<" , "<<matching_clientId<<endl;
//                      cout<<"其它地图q"<<q_array_main[connected_index].x()<<", "<<q_array_main[connected_index].y()<<", "<<q_array_main[connected_index].z()<<" , "<<q_array_main[connected_index].w()<<endl;
//
//                      cout<<"其它地图共同探索0relative_t："<<relative_t[0]<<" , "<<relative_t[1]<<" , "<<relative_t[2]<<endl;
//                      cout<<"其它地图共同探索0euler_conncected："<<euler_conncected[0]<<" , "<<euler_conncected[1]<<" , "<<euler_conncected[2]<<endl;
//                      cout<<"其它地图共同探索0relative_yaw："<<relative_yaw<<endl;
                      //这里到时候 再写一个求导的
                      ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z(),10.0);
                      problem.AddResidualBlock(cost_function, NULL, euler_array_main[connected_index],
                                               t_array_main[connected_index],
                                               euler_other_all[flag_start][i_other],
                                               t_other_all[flag_start][i_other]);
                      
                  }else{
                      int vmap_index=vMapId_all[matching_clientId];
                      if(matching_kfId < earliest_loopIndex_other_all[vmap_index])
                      {
                          //因为这意味着数据保存出错了 发生了融合的帧的id小于最早发生融合的id
                          assert(false);
                          return;
                      }
                      
        //               找到这个对应的其它地图
                      PoseGraph * pMap_fuse=vMap_all[vmap_index];
                      //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束 会出现空指针的问题
                      int connected_index = pMap_fuse->getKeyframe(matching_kfId)->resample_globalIndex;//这里可能多个
                        
    //                  double relative_yaw =euler_conncected[0]-euler_other_all[vmap_index][connected_index][0];
                      
//                      Vector3d euler_conncected = Utility::R2ypr(q_other_all[vmap_index][connected_index].toRotationMatrix());
                      
                      Vector3d euler_conncected = Utility::R2ypr(q_other_all_ori[vmap_index][connected_index].toRotationMatrix());
                      Vector3d relative_t((*it_other)->relative_global_loop_info_multiClient[loop_index_flag](0), (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](1), (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](2));
                      double relative_yaw = (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](7);
//                      cout<<"其它地图共同探索kfid"<<matching_kfId<<" , "<<earliest_loopIndex_other_all[vmap_index]<<endl;
//                      cout<<"其它地图共同探索matching_clientId"<<matching_clientId<<" , "<<vmap_index<<" , "<<latest_loopIndex_other_all[vmap_index]<<endl;
//                      cout<<"其它地图共同探索connected_index"<<connected_index<<" , "<<q_other_all[vmap_index].size()<<endl;
                      
//                      cout<<"其它地图共同探索connected_index"<<connected_index<<" , "<<vmap_index<<" , "<<matching_clientId<<endl;
//                      cout<<"其它地图q"<<q_other_all[vmap_index][connected_index].x()<<", "<<q_other_all[vmap_index][connected_index].y()<<", "<<q_other_all[vmap_index][connected_index].z()<<" , "<<q_other_all[vmap_index][connected_index].w()<<endl;
//
//
//                      cout<<"其它地图共同探索relative_t："<<relative_t[0]<<" , "<<relative_t[1]<<" , "<<relative_t[2]<<endl;
//                      cout<<"其它地图共同探索euler_conncected："<<euler_conncected[0]<<" , "<<euler_conncected[1]<<" , "<<euler_conncected[2]<<endl;
//                      cout<<"其它地图共同探索relative_yaw："<<relative_yaw<<endl;
                       //这里到时候 再写一个求导的
                       ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z(),10.0);
                       problem.AddResidualBlock(cost_function, NULL, euler_other_all[vmap_index][connected_index],
                                            t_other_all[vmap_index][connected_index],
                                            euler_other_all[flag_start][i_other],
                                            t_other_all[flag_start][i_other]);
                  }
                  
                  
              }
           }
            if ((*it_other)->global_index == latest_loopIndex_other_all[flag_start])
                break;
            i_other++;
          
        }

    }
    
    ceres::Solve(options, &problem, &summary);
    
    std::cout << "global fuse: "<<summary.BriefReport() << "\n";
    if(summary.termination_type!=ceres::CONVERGENCE){
        
//        for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
//            PoseGraph * pMap_other=vMap_all[flag_start];
//            pMap_other->special_kf_mutex.lock();
//            pMap_other->pop_kf_id_hasComPlace_withOtherMap();
//            pMap_other->special_kf_inOpti.pop();
//            pMap_other->special_kf_mutex.unlock();
//        }
//        pMainMap->special_kf_mutex.lock();
//        pMainMap->pop_kf_id_hasComPlace_withOtherMap();
//       pMainMap->special_kf_inOpti.pop();
//       pMainMap->special_kf_mutex.unlock();
        
        
        return;
    }
    pMainMap->loop_index_multiClient.push(earliest_loop_index_main);
    pMainMap->curKF_loop_index_multiClient.push(latest_loop_index_main);
    
    
    pMainMap->special_kf_mutex.lock();
    pMainMap->add2_kf_id_hasComPlace_withOtherMap(kf_id_hasComPlace_main);
   pMainMap->special_kf_inOpti.push(special_kf_inOpti_main);
   pMainMap->special_kf_mutex.unlock();
    
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
        
        vector<int> special_kf_inOpti_cur=special_kf_inOpti_cur_all[flag_start];
        vector<int> kf_id_hasCom_cur=kf_id_hasComPlace_cur_all[flag_start];
        
        pMap_other->special_kf_mutex.lock();
        pMap_other->add2_kf_id_hasComPlace_withOtherMap(kf_id_hasCom_cur);
        pMap_other->special_kf_inOpti.push(special_kf_inOpti_cur);
        pMap_other->special_kf_mutex.unlock();
        
        
        int latest_loop_index_other= latest_loop_index_other_update[flag_start];
        
        pMap_other->isFirstFusion_globalMutex.lock();
        pMap_other->loop_index_multiClient.push(0);
        pMap_other->curKF_loop_index_multiClient.push(latest_loop_index_other);
        pMap_other->isFirstFusion_globalMutex.unlock();
    }
    //------------------------------------------第一个数据优化后更新
    //优化完成，使用优化后的位姿来更新关键帧列表中index大于等于earliest_loop_index的所有关键帧的位姿
    
    Vector3d t_drift_it_other = Vector3d::Zero();
    Matrix3d r_drift_it_other = Matrix3d::Identity();
    
    vector<Matrix3d> r_global_cur;
    vector<Vector3d> t_global_cur;
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
        list<KeyFrame*>::iterator it_other = pMap_other->keyFrameList.begin();
        i_other = 0;
        r_global_cur.clear();
        t_global_cur.clear();
        for (; it_other != pMap_other->keyFrameList.end(); it_other++)
        {
            
            Quaterniond tmp_q;
            //向量转换为矩阵
            tmp_q = Utility::ypr2R(Vector3d(euler_other_all[flag_start][i_other][0], euler_other_all[flag_start][i_other][1], euler_other_all[flag_start][i_other][2]));
            Vector3d tmp_w1_t = Vector3d(t_other_all[flag_start][i_other][0], t_other_all[flag_start][i_other][1], t_other_all[flag_start][i_other][2]);
            Matrix3d tmp_w1_r = tmp_q.toRotationMatrix();
            
         
           
            if(resample_other_all[flag_start][i_other])
            {
                (*it_other)-> updatePose(r_drift_it_other * tmp_w1_t + t_drift_it_other, r_drift_it_other * tmp_w1_r);
            }
            else
            {
                Vector3d origin_t_it;
                Matrix3d origin_r_it;
                (*it_other)->getOriginPose(origin_t_it, origin_r_it);
                
                
                r_drift_it_other = tmp_w1_r * origin_r_it.transpose();
                t_drift_it_other = tmp_w1_t - r_drift_it_other * origin_t_it;
                (*it_other)-> updatePose(tmp_w1_t, tmp_w1_r);
                
    //            pCurMap->add2_r_global_multiClient(tmp_w1_r);
    //            pCurMap->add2_t_global_multiClient(tmp_w1_t);
                r_global_cur.push_back(tmp_w1_r);
                t_global_cur.push_back(tmp_w1_t);
            }
            if ((*it_other)->global_index == latest_loopIndex_other_all[flag_start])
                break;
            i_other++;
            
        }
        //如果将地图建模成可变形的呢
        //根据计算出当前帧的drift，更新全部关键帧位姿
        Vector3d cur_t_other, origin_t_other;
        Matrix3d cur_r_other, origin_r_other;
        //获取优化后当前帧的位姿cur_t,cur_r
        (*it_other)->getPose(cur_t_other, cur_r_other);
        //获取优化前有漂移的当前帧的位姿vio_t,vio_r
        (*it_other)->getOriginPose(origin_t_other, origin_r_other);
        pMap_other->yaw_drift = Utility::R2ypr(cur_r_other).x() - Utility::R2ypr(origin_r_other).x();
        pMap_other->r_drift = Utility::ypr2R(Vector3d(pMap_other->yaw_drift, 0, 0));
        pMap_other->t_drift = cur_t_other - pMap_other->r_drift * origin_t_other;
        
    //    pCurMap->add2_r_global_multiClient(pCurMap->r_drift);
    //    pCurMap->add2_t_global_multiClient(pCurMap->t_drift);
        r_global_cur.push_back(pMap_other->r_drift);
        t_global_cur.push_back(pMap_other->t_drift);
        pMap_other->add2_r_global_multiClient(r_global_cur);
        pMap_other->add2_t_global_multiClient(t_global_cur);
        if((r_global_cur.size()-1)!=pMap_other->special_kf_inOpti.back().size()){
            cout<<"当前地图id"<<pMap_other->c->id<<" , "<<latest_loopIndex_other_all[flag_start]<<endl;
            cout<<"resample下标数量不一致："<<r_global_cur.size()<<" , "<<pMap_other->special_kf_inOpti.back().size()<<endl;
            while (pMap_other->special_kf_inOpti.size()!=2)
            {
                cout << pMap_other->special_kf_inOpti.front().size()<< " "; // Output the 1st element
                pMap_other->special_kf_inOpti.pop();  // Delete the 1st element
            }
            std::cout << std::endl;
            cout << "倒数第二个："<<pMap_other->special_kf_inOpti.front().size()<< endl;
            assert(false);//20 38
        }

        //下面代码为把当前关键帧it之后的关键帧的位姿通过求解的偏移量转换到world坐标系下
        for (; it_other != pMap_other->keyFrameList.end(); it_other++)
        {
            Vector3d P;
            Matrix3d R;
            (*it_other)->getOriginPose(P, R);
            P = pMap_other->r_drift * P + pMap_other->t_drift;
            R = pMap_other->r_drift * R;
            (*it_other)-> updatePose(P, R);
        }
        pMap_other->lastKF_index.push(pMap_other->keyFrameList.back()->global_index);
    }
    
    
    
    //---------------------------------------第2个数据的更新
    //优化完成，使用优化后的位姿来更新关键帧列表中index大于等于earliest_loop_index的所有关键帧的位姿
    i_main = 0;
    Vector3d t_drift_it_main = Vector3d::Zero();
    Matrix3d r_drift_it_main = Matrix3d::Identity();
    
    vector<Matrix3d> r_global_main;
    vector<Vector3d> t_global_main;
    for (it_main = pMainMap->keyFrameList.begin(); it_main != pMainMap->keyFrameList.end(); it_main++)
    {
        if ((*it_main)->global_index < earliest_loop_index_main)
            continue;

        Quaterniond tmp_q;
        //向量转换为矩阵
        tmp_q = Utility::ypr2R(Vector3d(euler_array_main[i_main][0], euler_array_main[i_main][1], euler_array_main[i_main][2]));
        Vector3d tmp_w1_t = Vector3d(t_array_main[i_main][0], t_array_main[i_main][1], t_array_main[i_main][2]);
        Matrix3d tmp_w1_r = tmp_q.toRotationMatrix();

//                cout<<"测试 优化完成 更新哪里变了："<<euler_array_main[i_main][0]<<" "<<euler_array_main[i_main][1]<<" "<<euler_array_main[i_main][2]<<" "<<t_array_main[i_main][0]<<" "<<t_array_main[i_main][1]<<" "<<t_array_main[i_main][2]<<" "<<i_main<<endl;
        if(need_resample_main[i_main])
        {
            (*it_main)-> updatePose(r_drift_it_main * tmp_w1_t + t_drift_it_main, r_drift_it_main * tmp_w1_r);
        }
        else
        {
            Vector3d origin_t_it;
            Matrix3d origin_r_it;
            (*it_main)->getOriginPose(origin_t_it, origin_r_it);
            r_drift_it_main = tmp_w1_r * origin_r_it.transpose();
            t_drift_it_main = tmp_w1_t - r_drift_it_main * origin_t_it;
            (*it_main)-> updatePose(tmp_w1_t, tmp_w1_r);
            
//            pMainMap->add2_r_global_multiClient(tmp_w1_r);
//            pMainMap->add2_t_global_multiClient(tmp_w1_t);
            r_global_main.push_back(tmp_w1_r);
            t_global_main.push_back(tmp_w1_t);

        }
        if ((*it_main)->global_index == latest_loop_index_main)
            break;
        i_main++;

    }
    //根据计算出当前帧的drift，更新全部关键帧位姿
    Vector3d cur_t_main, origin_t_main;
    Matrix3d cur_r_main, origin_r_main;
    //获取优化后当前帧的位姿cur_t,cur_r
    (*it_main)->getPose(cur_t_main, cur_r_main);
    //获取优化前有漂移的当前帧的位姿vio_t,vio_r
    (*it_main)->getOriginPose(origin_t_main, origin_r_main);
    pMainMap->yaw_drift = Utility::R2ypr(cur_r_main).x() - Utility::R2ypr(origin_r_main).x();
    pMainMap->r_drift = Utility::ypr2R(Vector3d(pMainMap->yaw_drift, 0, 0));
    pMainMap->t_drift = cur_t_main - pMainMap->r_drift * origin_t_main;
    
//    pMainMap->add2_r_global_multiClient(pMainMap->r_drift);
//    pMainMap->add2_t_global_multiClient(pMainMap->t_drift);
    r_global_main.push_back(pMainMap->r_drift);
    t_global_main.push_back(pMainMap->t_drift);
    pMainMap->add2_r_global_multiClient(r_global_main);
    pMainMap->add2_t_global_multiClient(t_global_main);
    
    if((r_global_main.size()-1)!=pMainMap->special_kf_inOpti.back().size()){
        cout<<"当前地图id"<<pMainMap->c->id<<" , "<<latest_loop_index_main<<endl;
        cout<<"resample_main下标数量不一致："<<r_global_main.size()<<" , "<<pMainMap->special_kf_inOpti.back().size()<<endl;
        while (pMainMap->special_kf_inOpti.size()!=2)
        {
            cout << pMainMap->special_kf_inOpti.front().size()<< " "; // Output the 1st element
            pMainMap->special_kf_inOpti.pop();  // Delete the 1st element
        }
        std::cout << std::endl;
        cout << "倒数第二个："<<pMainMap->special_kf_inOpti.front().size()<< endl;
        assert(false);//20 38
    }

    //下面代码为把当前关键帧it之后的关键帧的位姿通过求解的偏移量转换到world坐标系下
    for (; it_main != pMainMap->keyFrameList.end(); it_main++)
    {
        Vector3d P;
        Matrix3d R;
        (*it_main)->getOriginPose(P, R);
        P = pMainMap->r_drift * P + pMainMap->t_drift;
        R = pMainMap->r_drift * R;
        (*it_main)-> updatePose(P, R);
    }
    
//    pCurMap->isFirstFusion_globalMutex.unlock();
    
    
    
    
    
    pMainMap->lastKF_index.push(pMainMap->keyFrameList.back()->global_index);
//            位姿更新都留到显示那里
    pMainMap->updateVisualization();
    
    readWriteLock.readLock();
    PoseGraph* pMainMap_0=PoseGraphGloabl_map[0];
    readWriteLock.readUnLock();
    
   
    pAddKfMap->refine_path_mutex.lock();
    if(isUpdateFusionDraw){
        pMainMap_0->fusion_relative_isUpdate[pMainMap->c->id]=0;
        pMainMap_0->fusion_poseGraph_mutex.lock();
        pMainMap_0->fusion_otherGraph[pMainMap->c->id]=pMainMap;
        pMainMap_0->fusion_poseGraph_mutex.unlock();
    }
    pAddKfMap->refine_path_mutex.unlock();
    
    
    
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
        pMap_other->updateVisualization();
        pMap_other->isSendGloablData_multiClient=true;
        
        pAddKfMap->refine_path_mutex.lock();
        if(isUpdateFusionDraw){
            pMainMap_0->fusion_relative_isUpdate[pMap_other->c->id]=0;
            pMainMap_0->fusion_poseGraph_mutex.lock();
            pMainMap_0->fusion_otherGraph[pMap_other->c->id]=pMap_other;
            pMainMap_0->fusion_poseGraph_mutex.unlock();
        }
        pAddKfMap->refine_path_mutex.unlock();
        
        
        delete [](t_other_all[flag_start][0]);
        delete [](t_other_all[flag_start][1]);
        delete [](t_other_all[flag_start][2]);
        delete [](t_other_all[flag_start]);
        delete [](euler_other_all[flag_start][0]);
        delete [](euler_other_all[flag_start][1]);
        delete [](euler_other_all[flag_start][2]);
        delete [](euler_other_all[flag_start]);
        
        
        delete [](t_other_all_ori[flag_start][0]);
        delete [](t_other_all_ori[flag_start][1]);
        delete [](t_other_all_ori[flag_start][2]);
        delete [](t_other_all_ori[flag_start]);
        delete [](euler_other_all_ori[flag_start][0]);
        delete [](euler_other_all_ori[flag_start][1]);
        delete [](euler_other_all_ori[flag_start][2]);
        delete [](euler_other_all_ori[flag_start]);
              
    }
    //发送数据
    pMainMap->isSendGloablData_multiClient=true;
    //                    把之前锁住了的解锁了
//    for(int flag_start=0,flag_end=lock_all.size();flag_start<flag_end;flag_start++){
//        cout<<"解锁："<<flag_start<<endl;
//        (lock_all[flag_start])->unlock();
//    }
    cout<<"最终的全局优化结束"<<i<<endl;
//    cout<<"测试 偏移对不对"<<pCurMap->t_drift[0]<<" "<<pCurMap->t_drift[1]<<" "<<pCurMap->t_drift[2]<<endl;
    
    
}

//这里是多个地图联合优化 位姿稍微变差了一点点
//基于9的基础改 这里是将第一次融合的相对位姿 的 除yaw之外的旋转角 乘给了所有人 10维的优化
void PoseGraphGlobal::GlobalFuse_10(int i){
    cout<<"最终的全局优化"<<i<<endl;
    bool isUpdateFusionDraw=false;
//    cout<<"死锁没"<<endl;
    //因为现在写的都是和主地图发生地图融合 所以其中一个地图直接这么获取了
//    poseGraphGlobal_mutex.lock();
    readWriteLock.readLock();
    map<int,PoseGraph*>::iterator iter_map = PoseGraphGloabl_map.find(i);
    if(iter_map==PoseGraphGloabl_map.end())
    {
//        poseGraphGlobal_mutex.unlock();
        readWriteLock.readUnLock();
        assert(false);//都已经发生回环了，却找不到地图 说明数据插错
    }
    PoseGraph* pAddKfMap= iter_map->second;
    int len = PoseGraphGloabl_map.size();
    readWriteLock.readUnLock();
    
    vector<std::unique_lock<std::mutex>* > lock_all;
    std::unique_lock<std::mutex> lock(pAddKfMap->keyFrameList_global_fusion_mutex, std::defer_lock);
    if (lock.try_lock()) {
        cout<<"加锁："<<pAddKfMap->c->id<<endl;
        lock_all.push_back(&lock);
    } else {
        cout<<"最终的全局优化中断"<<i<<endl;
        return;
    }
    if(i==mainClientID){
        isUpdateFusionDraw=true;
    }


    
    double total_lenth_other=0.0;
    vector< double> length_other;
    PoseGraph* pMainMap;//id最小的
    vector<PoseGraph *> vMap_all;//除id最小,也就是匹配上的全部其它地图
    map<int,int> vMapId_all;//int表示clientId 后面表示存放在vMap_all的下标
    //找其它融合的地图 一起参与优化
    bool isFindMinClient=true;
    readWriteLock.readLock();
    if(PoseGraphGloabl_map.size()>1){
        readWriteLock.readUnLock();
        for(int client_id=0;client_id<len;client_id++){//这里的i其实代表的就是 ClientId
            if(client_id==i){
                continue;
            }
            if(uf.isConnected(i, client_id)){
                readWriteLock.readLock();
                map<int,PoseGraph*>::iterator iter_map_other = PoseGraphGloabl_map.find(client_id);
                if(iter_map_other==PoseGraphGloabl_map.end()){
                    readWriteLock.readUnLock();
                    continue;
                }
                PoseGraph* pOtherMap= iter_map_other->second;//新的地图 小的地图
                readWriteLock.readUnLock();
                
                
                std::unique_lock<std::mutex> lock(pOtherMap->keyFrameList_global_fusion_mutex, std::defer_lock);
                if (lock.try_lock()) {
                    cout<<"加锁："<<pOtherMap->c->id<<endl;
                    lock_all.push_back(&lock);
                } else {
                    //                    把之前锁住了的解锁了
                    cout<<"最终的全局优化中断"<<pOtherMap->c->id<<endl;
                    return;
                }
         
                
                if(isFindMinClient){
                    isFindMinClient=false;
                    if(i>client_id){
//                        这里就是id最小的地图
                        pMainMap=pOtherMap;
//                        cout<<"主地图大小："<<pMainMap->size()<<endl;
                      
                        vMap_all.push_back(pAddKfMap);
                        vMapId_all.insert(make_pair(pAddKfMap->c->id,vMap_all.size()-1));
                        total_lenth_other+=pAddKfMap->total_length;
                        length_other.push_back(pAddKfMap->total_length);
                        
                        if(client_id==mainClientID){
                            isUpdateFusionDraw=true;
                        }
                        continue;
                    }else{
                        pMainMap=pAddKfMap;
                    }
                }
                vMap_all.push_back(pOtherMap);
                vMapId_all.insert(make_pair(pOtherMap->c->id,vMap_all.size()-1));
                
                total_lenth_other+=pOtherMap->total_length;
                length_other.push_back(pOtherMap->total_length);
                
            }
            
        }
    }
    else{
        readWriteLock.readUnLock();
        assert(false);//都要发生全局优化了 却只有1个地图
    }
    
   
    
    //主地图从earliest_loop_index_main开始--当前帧结束
    //小地图从第一帧开始--当前发生回环的帧 这个有可能是回环帧，也有可能是融合帧
    ceres::Problem problem;
    ceres::Solver::Options options;
    //options.linear_solver_type = ceres::DENSE_NORMAL_CHOLESKY;
    options.linear_solver_type = ceres::DENSE_SCHUR;
    options.minimizer_progress_to_stdout = false;
    options.max_num_iterations = 15;
    ceres::Solver::Summary summary;
    ceres::LossFunction *loss_function;
    loss_function = new ceres::HuberLoss(1.0);
    //AngleLocalParameterization类的主要作用是指定yaw角优化变量的迭代更新，重载了括号运算
    ceres::LocalParameterization* angle_local_parameterization =
    AngleLocalParameterization::Create();
            
    
    double total_lenth_main=pMainMap->total_length;
    //总的位姿长度 除以总的帧数
    double total_lenth_sum=total_lenth_main+total_lenth_other;
    int max_frame_num_global_main=(total_lenth_main/total_lenth_sum)*max_frame_num_global;
    double min_dis_main=total_lenth_main/max_frame_num_global_main;
    
    //要优化的变量的最大个数 主地图
    int max_length_main=pMainMap->size()+1;
    double t_array_main[max_length_main][3];//平移数组，其中存放每个关键帧的平移向量
    Quaterniond q_array_main[max_length_main];
    double euler_array_main[max_length_main][3];
    vector<bool> need_resample_main;
    
//    double rt_global_main[7]={0};//为单位矩阵
//    rt_global_main[6]=1;
    double t_global_main_relative[3]={0};//为单位矩阵
    double r_global_main_relative[4]={0};//为单位矩阵
    r_global_main_relative[3]=1;
    
    pMainMap->max_frame_num_global=max_frame_num_global_main;
    pMainMap->min_dis=min_dis_main;
    

    const int mapOther_sum=vMap_all.size();
    vector< double** > t_other_all;
    vector< vector<Quaterniond > > q_other_all;
    vector< double** > euler_other_all;//里面存储的是度数  不是弧度
    vector< vector<bool> > resample_other_all;
    
//    vector< double > pitch_other_all;
//    vector< double > roll_other_all;
//    这个后续记录在帧内部
//    vector< double** > rt_global_all;
    
//    这个是每一帧都有一个rt
//    vector< double** > t_global_all;
//    vector< double** > r_global_all;
    
//    这个是每一地图都有一个rt
    vector< double* > t_global_all;
    vector< double* > r_global_all;
    
    int main_clientId=pMainMap->c->id;
    
    pMainMap->loop_index_mutex.lock();
    int earliest_loop_index_main=pMainMap->earliest_loop_index;
    int earliest_global_looped_index_main=earliest_globalLoop_index[pMainMap->c->id];
    int latest_loop_index_main=pMainMap->latest_loop_index;
    int latest_global_looped_index_main=latest_globalLoop_index[pMainMap->c->id];
    pMainMap->loop_index_mutex.unlock();
    
    if (earliest_loop_index_main > earliest_global_looped_index_main || earliest_loop_index_main == -1  )
        earliest_loop_index_main=earliest_global_looped_index_main;
    
    
    if (latest_global_looped_index_main > latest_loop_index_main)
        latest_loop_index_main=latest_global_looped_index_main;
//    pMainMap->loop_index_multiClient.push(earliest_loop_index_main);
//    pMainMap->curKF_loop_index_multiClient.push(latest_loop_index_main);//这个是要发回客户端 用来更新位姿的 TODO 后面要改改
    vector<int> latest_loop_index_other_correct;
    vector<int> earliest_loopIndex_other_all;
    vector<int> latest_loopIndex_other_all;
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
        
        pMap_other->loop_index_mutex.lock();
        int earliest_loop_index_other=pMap_other->earliest_loop_index;
        int earliest_global_looped_index_other=earliest_globalLoop_index[pMap_other->c->id];
        int latest_loop_index_other=pMap_other->latest_loop_index;
        int latest_global_looped_index_other=latest_globalLoop_index[pMap_other->c->id];
        pMap_other->loop_index_mutex.unlock();
        
        if (earliest_loop_index_other > earliest_global_looped_index_other || earliest_loop_index_other == -1  )
            earliest_loop_index_other=earliest_global_looped_index_other;
        earliest_loopIndex_other_all.push_back(earliest_loop_index_other);
        
        
        if (latest_global_looped_index_other > latest_loop_index_other)
            latest_loop_index_other=latest_global_looped_index_other;
        latest_loopIndex_other_all.push_back(latest_loop_index_other);
        
//        pMap_other->isFirstFusion_globalMutex.lock();
//        pMap_other->loop_index_multiClient.push(0);
//        pMap_other->curKF_loop_index_multiClient.push(latest_loop_index_other);
//        pMap_other->isFirstFusion_globalMutex.unlock();
        latest_loop_index_other_correct.push_back(latest_loop_index_other);
        
        double total_length_otherMap=length_other[flag_start];
        int max_frame_num_global_other=(total_length_otherMap/total_lenth_sum)*max_frame_num_global;
        double min_dis_other=total_length_otherMap/max_frame_num_global_other;
        pMap_other->max_frame_num_global=max_frame_num_global_other;
        pMap_other->min_dis=min_dis_other;
        
        //要优化的变量的最大个数 小地图
        int max_length_other=pMap_other->keyFrameList.size()+1;
        double** t_test=new double*[max_length_other];
        for(int index_flag=0;index_flag<max_length_other;index_flag++) t_test[index_flag] = new double[3];
        t_other_all.push_back(t_test);
        
        vector<Quaterniond > q_array_other(max_length_other);
        q_other_all.push_back(q_array_other);
        
        double** euler_test=new double*[max_length_other];
        for(int index_flag=0;index_flag<max_length_other;index_flag++) euler_test[index_flag] = new double[3];
        euler_other_all.push_back(euler_test);
        
        vector<bool> need_resample_other;
        resample_other_all.push_back(need_resample_other);
        
//        double** t_global_test=new double*[max_length_other];
//        double** r_global_test=new double*[max_length_other];
//        for(int index_flag=0;index_flag<max_length_other;index_flag++){
//            t_global_test[index_flag] = new double[3];
//            r_global_test[index_flag] = new double[4];
//            r_global_test[index_flag][3]=1;
//
//            for(int hh=0;hh<3;hh++){
//                t_global_test[index_flag][hh]=0;
//                r_global_test[index_flag][hh]=0;
//            }
//        }
//        t_global_all.push_back(t_global_test);
//        r_global_all.push_back(r_global_test);
        
        double t_global_test[3]={0};
        double r_global_test[4]={0};
        r_global_test[3]=1;
        t_global_all.push_back(t_global_test);
        r_global_all.push_back(r_global_test);
    }
   
    //*************************************遍历数据 记录要参与优化的

    vector<int> special_kf_inOpti_main;
    vector<int> kf_id_hasComPlace_main;
    //遍历关键帧列表
    list<KeyFrame*>::iterator it_main = pMainMap->keyFrameList.begin();
    Vector3d last_P_main = Vector3d(0, 0, 0);
    double dis_main = 0;
    int resample_id=0;
    for(;it_main!=pMainMap->keyFrameList.end();it_main++){
        if((*it_main)->global_index < earliest_loop_index_main){
            continue;
        }
        (*it_main)->resample_globalIndex = resample_id;
        Vector3d tmp_t;
        Matrix3d tmp_r;
        //获取关键帧it的位姿
        (*it_main)->getPose(tmp_t, tmp_r);
        dis_main += (tmp_t - last_P_main).norm();
        //全局优化 还是要加序列边 不然太长了 判断条件 再加个两个地图之间发生了融合
        if((*it_main)->global_index == earliest_loop_index_main || dis_main > min_dis_main || (*it_main)->is_get_loop_info || (*it_main)->is_looped || (*it_main)->has_global_loop || (*it_main)->is_global_looped || pMainMap->keyFrameList.size() < max_frame_num_global_main)
        {
            dis_main = 0;
            last_P_main = tmp_t;
            need_resample_main.push_back(0);
            
//            pMainMap->special_kf_inOpti.push_back((*it_main)->global_index);
            special_kf_inOpti_main.push_back((*it_main)->global_index);
            
            if(((*it_main)->has_global_loop || (*it_main)->is_global_looped) && (*it_main)->is_Send==false ){
                kf_id_hasComPlace_main.push_back((*it_main)->global_index);
//                pMainMap->add2_kf_id_hasComPlace_withOtherMap((*it_main)->global_index);
                (*it_main)->is_Send=true;
            }
            
        }
        else
        {
            last_P_main = tmp_t;
            need_resample_main.push_back(1);
        }
        
        Quaterniond tmp_q;
        Matrix3d tmp_r_origin;
        Vector3d tmp_t_origin;
        (*it_main)->getOriginPose(tmp_t_origin, tmp_r_origin);
//                (*it_main)->getPose(tmp_t, tmp_r);
        tmp_q = tmp_r_origin;
        t_array_main[resample_id][0] = tmp_t_origin(0);
        t_array_main[resample_id][1] = tmp_t_origin(1);
        t_array_main[resample_id][2] = tmp_t_origin(2);
        q_array_main[resample_id] = tmp_q;
        //将矩阵转换为向量
        Vector3d euler_angle = Utility::R2ypr(tmp_r_origin);
        euler_array_main[resample_id][0] = euler_angle.x();
        euler_array_main[resample_id][1] = euler_angle.y();
        euler_array_main[resample_id][2] = euler_angle.z();
        
        resample_id++;
        
        if ((*it_main)->global_index == latest_loop_index_main)
            break;
    }
    
//    pMainMap->special_kf_mutex.lock();
//    pMainMap->add2_kf_id_hasComPlace_withOtherMap(kf_id_hasComPlace_main);
//   pMainMap->special_kf_inOpti.push(special_kf_inOpti_main);
//   pMainMap->special_kf_mutex.unlock();
    
    vector<vector<int> > special_kf_inOpti_cur_all;
    vector<vector<int> > kf_id_hasCom_cur_all;
    
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
        //遍历关键帧列表
        list<KeyFrame*>::iterator it_other = pMap_other->keyFrameList.begin();

        Vector3d last_P_other = Vector3d(0, 0, 0);
        double dis_other = 0;
        
        vector<int> special_kf_inOpti_cur;
        vector<int> kf_id_hasCom_cur;
        resample_id=0;
        resample_other_all[flag_start].clear();
       
        //小地图是从第一个帧开始优化
        for(;it_other!=pMap_other->keyFrameList.end();it_other++){
            (*it_other)->resample_globalIndex = resample_id;
            
            Vector3d tmp_t;
            Matrix3d tmp_r;
            //获取关键帧it的位姿
            (*it_other)->getPose(tmp_t, tmp_r);
            dis_other += (tmp_t - last_P_other).norm();
            
            
            //全局优化 还是要加序列边 不然太长了 判断条件 再加个两个地图之间发生了融合
            //第一个地图融合位置，超过长度了，发生过回环，被回环了，总共的帧长度比最大值小
            //还要再加一个 发生了融合，被融合了
            if((*it_other)->global_index == 0 || dis_other > pMap_other->min_dis || (*it_other)->is_get_loop_info || (*it_other)->is_looped || (*it_other)->has_global_loop || (*it_other)->is_global_looped || pMap_other->keyFrameList.size() < pMap_other->max_frame_num_global)
            {
                dis_other = 0;
                last_P_other = tmp_t;
                resample_other_all[flag_start].push_back(0);
                
    //            pCurMap->special_kf_inOpti.push_back((*it_other)->global_index);
                special_kf_inOpti_cur.push_back((*it_other)->global_index);
                
                if(((*it_other)->has_global_loop || (*it_other)->is_global_looped) && (*it_other)->is_Send==false ){
                    kf_id_hasCom_cur.push_back((*it_other)->global_index);
    //                pCurMap->add2_kf_id_hasComPlace_withOtherMap((*it_other)->global_index);
                    (*it_other)->is_Send=true;
                }
                
            }
            else
            {
                last_P_other = tmp_t;
                resample_other_all[flag_start].push_back(1);
            }
            
            Quaterniond tmp_q;
            Matrix3d tmp_r_origin;
            Vector3d tmp_t_origin;
            (*it_other)->getOriginPose(tmp_t_origin, tmp_r_origin);
    //                (*it_main)->getPose(tmp_t, tmp_r);
            tmp_q = tmp_r_origin;
            (t_other_all[flag_start])[resample_id][0] = tmp_t_origin(0);
            (t_other_all[flag_start])[resample_id][1] = tmp_t_origin(1);
            (t_other_all[flag_start])[resample_id][2] = tmp_t_origin(2);
            q_other_all[flag_start][resample_id] = tmp_q;
            //将矩阵转换为向量
            Vector3d euler_angle = Utility::R2ypr(tmp_r_origin);
            euler_other_all[flag_start][resample_id][0] = euler_angle.x();
            euler_other_all[flag_start][resample_id][1] = euler_angle.y();
            euler_other_all[flag_start][resample_id][2] = euler_angle.z();
            
            resample_id++;
            
            if ((*it_other)->global_index == latest_loopIndex_other_all[flag_start])
                break;
        }
        
//        pMap_other->special_kf_mutex.lock();
//        pMap_other->add2_kf_id_hasComPlace_withOtherMap(kf_id_hasCom_cur);
//        pMap_other->special_kf_inOpti.push(special_kf_inOpti_cur);
//        pMap_other->special_kf_mutex.unlock();
        special_kf_inOpti_cur_all.push_back(special_kf_inOpti_cur);
        kf_id_hasCom_cur_all.push_back(kf_id_hasCom_cur);
        
    }
    
    //*************************************第一个数据
//    if(pMainMap->relativeOtherMap_clientId!=-1){
//        assert(false);//因为最小的地图 那他没有和更小的地图融合 relativeOtherMap_clientId这个记录它融合的所有地图的最小id
//    }

//    暂时注释 后面会求导那些了 再改
//        ceres::LocalParameterization *local_parameterization = new PoseQ_LocalParameterization();
//        problem.AddParameterBlock(r_global_main_relative, 4, local_parameterization);
//        problem.SetParameterBlockConstant(r_global_main_relative);
//
//        problem.AddParameterBlock(t_global_main_relative, 3);
//        problem.SetParameterBlockConstant(t_global_main_relative);

    int i_main = 0;
    for (it_main = pMainMap->keyFrameList.begin(); it_main != pMainMap->keyFrameList.end(); it_main++)
    {
        if ((*it_main)->global_index < earliest_loop_index_main)
            continue;

        
        //将关键帧列表中所有index>=earliest_loop_index的关键帧的位姿加入到参数块当中
        problem.AddParameterBlock(euler_array_main[i_main], 1, angle_local_parameterization);
        problem.AddParameterBlock(t_array_main[i_main], 3);
        //设置约束：如果该帧是最早的闭环帧的情况下，则固定它的位姿
        if ((*it_main)->global_index == earliest_loop_index_main)
        {
            problem.SetParameterBlockConstant(euler_array_main[i_main]);
            problem.SetParameterBlockConstant(t_array_main[i_main]);
        }
        
        if(need_resample_main[i_main])
        {
            i_main++;
            continue;
        }
        
        
        int j = 1, sequence_link_cnt = 0;
        while(sequence_link_cnt < 5)
        {
            if (i_main - j >= 0)
            {
//                        list<KeyFrame*>::iterator tmp = it_main;
//                        std::advance (tmp, -j);
                if(need_resample_main[i_main-j])
                {
                    j++;
                    continue;
                }
                else
                {
                    sequence_link_cnt++;
                }
                Vector3d euler_conncected = Utility::R2ypr(q_array_main[i_main-j].toRotationMatrix());
                //p̂_j^w - p̂_i^w 计算平移量的偏差
                Vector3d relative_t(t_array_main[i_main][0] - t_array_main[i_main-j][0], t_array_main[i_main][1] - t_array_main[i_main-j][1], t_array_main[i_main][2] - t_array_main[i_main-j][2]);
                //p̂_{ij}^{i} = {R̂_i^w}^{-1} (p̂_j^w - p̂_i^w)
                //p̂ ij= (R̂ iw ) (p̂ jw − p̂ iw )
                relative_t = q_array_main[i_main-j].inverse() * relative_t;
                //ψ̂ _ij = ψ̂ _j − ψ̂ _i
                double relative_yaw = euler_array_main[i_main][0] - euler_array_main[i_main-j][0];
//                cout<<"主地图序列帧relative_t："<<relative_t[0]<<" , "<<relative_t[1]<<" , "<<relative_t[2]<<endl;
//                cout<<"主地图序列帧euler_conncected："<<euler_conncected[0]<<" , "<<euler_conncected[1]<<" , "<<euler_conncected[2]<<endl;
//                cout<<"主地图序列帧relative_yaw："<<relative_yaw<<endl;
                ceres::CostFunction* cost_function = FourDOFError_another::Create( relative_t.x(), relative_t.y(), relative_t.z(),
                                                                          relative_yaw, euler_conncected.y(), euler_conncected.z());
                problem.AddResidualBlock(cost_function, loss_function, euler_array_main[i_main-j],
                                         t_array_main[i_main-j],
                                         euler_array_main[i_main],
                                         t_array_main[i_main]);
            }
            else
            {
                break;
            }
            j++;
        }

        //        添加的是闭环边，是指检测到闭环的两帧
        if((*it_main)->is_get_loop_info   )
        {
            if((*it_main)->loop_index >= earliest_loop_index_main)
            {
                int connected_index = pMainMap->getKeyframe((*it_main)->loop_index)->resample_globalIndex;

                Vector3d euler_conncected = Utility::R2ypr(q_array_main[connected_index].toRotationMatrix());
                Vector3d relative_t((*it_main)->loop_info_better(0), (*it_main)->loop_info_better(1), (*it_main)->loop_info_better(2));
                double relative_yaw = (*it_main)->loop_info_better(3);
//                cout<<"主地图回环relative_t："<<relative_t[0]<<" , "<<relative_t[1]<<" , "<<relative_t[2]<<endl;
//                cout<<"主地图回环euler_conncected："<<euler_conncected[0]<<" , "<<euler_conncected[1]<<" , "<<euler_conncected[2]<<endl;
//                cout<<"主地图回环relative_yaw："<<relative_yaw<<endl;
                ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),
                                                                                relative_yaw, euler_conncected.y(), euler_conncected.z(),10.0);
                problem.AddResidualBlock(cost_function, NULL, euler_array_main[connected_index],
                                         t_array_main[connected_index],
                                         euler_array_main[i_main],
                                         t_array_main[i_main]);
            }else{
                cout<<"主地图回环id:"<<(*it_main)->loop_index<<" , "<<earliest_loop_index_main<<endl;
                assert(false);//报错36 37
            }
        }

        
        if((*it_main)->has_global_loop)
       {
           //这里后面还要添加else
           if((*it_main)->global_loop_index < 0)
           {
               //因为这意味着数据保存出错了 发生了融合的帧的id小于最早发生融合的id
               assert(false);
               return;
           }
//           获取是和哪个其它地图发生了回环
           (*it_main)->readWriteLock_loop.readLock();
           int loop_index_flag_end=(*it_main)->clientId.size();
           (*it_main)->readWriteLock_loop.readUnLock();
//           遍历该帧的 所有回环帧
           for(int loop_index_flag=0;loop_index_flag<loop_index_flag_end;loop_index_flag++){
               (*it_main)->readWriteLock_loop.readLock();
               int matching_clientId=(*it_main)->clientId[loop_index_flag];
               int matching_kfId=(*it_main)->kfId[loop_index_flag];
               std::pair<Matrix3d , Vector3d > matching_rt=(*it_main)->relativePose[loop_index_flag];
               (*it_main)->readWriteLock_loop.readUnLock();
               
//               找到这个对应的其它地图
               int vmap_index=vMapId_all[matching_clientId];
               PoseGraph * pMap_other=vMap_all[vmap_index];
               //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束 会出现空指针的问题
               int connected_index = pMap_other->getKeyframe(matching_kfId)->resample_globalIndex;//这里可能多个
               
               if(matching_kfId < earliest_loopIndex_other_all[vmap_index])
               {
                   //因为这意味着数据保存出错了 发生了融合的帧的id小于最早发生融合的id
                   assert(false);
                   return;
               }
               
               Vector3d euler_conncected = Utility::R2ypr(q_other_all[vmap_index][connected_index].toRotationMatrix());
               Vector3d relative_t((*it_main)->relative_global_loop_info_multiClient[loop_index_flag](0), (*it_main)->relative_global_loop_info_multiClient[loop_index_flag](1), (*it_main)->relative_global_loop_info_multiClient[loop_index_flag](2));
               double relative_yaw = (*it_main)->relative_global_loop_info_multiClient[loop_index_flag](7);
               
               //这里到时候 再写一个求导的
               ceres::CostFunction* cost_function1 = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z(),10.0);
               problem.AddResidualBlock(cost_function1, NULL, euler_other_all[vmap_index][connected_index] ,
                                       t_other_all[vmap_index][connected_index] ,
                                        euler_array_main[i_main],
                                        t_array_main[i_main]);
               
//               MultiClientFactor_merge *f = new MultiClientFactor_merge(relative_t, euler_conncected.y(), euler_conncected.z());
//               problem.AddResidualBlock(f, NULL, euler_other_all[vmap_index][connected_index] ,
//                                        t_other_all[vmap_index][connected_index] , t_array_main[i_main] ,t_global_all[vmap_index][connected_index],r_global_all[vmap_index][connected_index],t_global_main_relative,r_global_main_relative);
//
//               Vector3d euler_conncected_j = Utility::R2ypr(q_array_main[i_main].toRotationMatrix());
//               ceres::CostFunction* cost_function = EightDOFWeightError_yaw::Create( relative_yaw, euler_conncected.y(), euler_conncected.z(),euler_conncected_j.y(),euler_conncected_j.z());
//             problem.AddResidualBlock(cost_function, NULL, euler_other_all[vmap_index][connected_index] ,euler_array_main[i_main] , r_global_all[vmap_index][connected_index] ,r_global_main_relative);
               
//               同上暂时注释的
//               MultiClientFactor_merge *f = new MultiClientFactor_merge(relative_t, euler_conncected.y(), euler_conncected.z());
//               problem.AddResidualBlock(f, NULL, euler_other_all[vmap_index][connected_index] ,
//                                        t_other_all[vmap_index][connected_index] , t_array_main[i_main] ,t_global_all[vmap_index],r_global_all[vmap_index],t_global_main_relative,r_global_main_relative);
//
//               Vector3d euler_conncected_j = Utility::R2ypr(q_array_main[i_main].toRotationMatrix());
//               ceres::CostFunction* cost_function = EightDOFWeightError_yaw::Create( relative_yaw, euler_conncected.y(), euler_conncected.z(),euler_conncected_j.y(),euler_conncected_j.z());
//             problem.AddResidualBlock(cost_function, NULL, euler_other_all[vmap_index][connected_index] ,euler_array_main[i_main] , r_global_all[vmap_index] ,r_global_main_relative);
           }
          
           
           
       }
        
        
        if ((*it_main)->global_index == latest_loop_index_main)
            break;
        i_main++;
    }
    
    int i_other = 0;
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
//        problem.AddParameterBlock(&pitch_other_all[flag_start], 1);
//        problem.AddParameterBlock(&roll_other_all[flag_start], 1);
        i_other = 0;
//        同上暂时注释的
//        problem.AddParameterBlock(r_global_all[flag_start], 4, local_parameterization);
////        problem.SetParameterBlockConstant(r_global_all[flag_start]);
//        problem.AddParameterBlock(t_global_all[flag_start], 3);
////        problem.SetParameterBlockConstant(t_global_all[flag_start]);
        for (auto it_other = pMap_other->keyFrameList.begin(); it_other != pMap_other->keyFrameList.end(); it_other++)
        {
            //将关键帧列表中所有index>=earliest_loop_index的关键帧的位姿加入到参数块当中
           
            problem.AddParameterBlock(euler_other_all[flag_start][i_other], 1, angle_local_parameterization);
            problem.AddParameterBlock(t_other_all[flag_start][i_other], 3);

//            ceres::LocalParameterization *local_parameterization = new PoseQ_LocalParameterization();
//            problem.AddParameterBlock(r_global_all[flag_start][i_other], 4, local_parameterization);
//            problem.AddParameterBlock(t_global_all[flag_start][i_other], 3);
            
            if(resample_other_all[flag_start][i_other])
            {
               
                i_other++;
                continue;
            }
            
//            if(i_other>0){
//
//                ceres::CostFunction* cost_function = SixDOFWeightError_relativeR::Create( );
//                problem.AddResidualBlock(cost_function, NULL, r_global_all[flag_start][i_other-1],
//                                       r_global_all[flag_start][i_other]);
//
//
//                ceres::CostFunction* cost_function_t = SixDOFWeightError_relativet::Create( );
//                problem.AddResidualBlock(cost_function_t, NULL, t_global_all[flag_start][i_other-1],
//                                       t_global_all[flag_start][i_other]);
//            }


            int j = 1, sequence_link_cnt = 0;
            while(sequence_link_cnt < 5)
            {
                if (i_other - j >= 0)
                {

                    if(resample_other_all[flag_start][i_other-j])
                    {
                        j++;
                        continue;
                    }
                    else
                    {
                        sequence_link_cnt++;
                    }
                    Vector3d euler_conncected = Utility::R2ypr(q_other_all[flag_start][i_other-j].toRotationMatrix());
                    //p̂_j^w - p̂_i^w 计算平移量的偏差
                    Vector3d relative_t(t_other_all[flag_start][i_other][0] - t_other_all[flag_start][i_other-j][0], t_other_all[flag_start][i_other][1] - t_other_all[flag_start][i_other-j][1], t_other_all[flag_start][i_other][2] - t_other_all[flag_start][i_other-j][2]);
                    //p̂_{ij}^{i} = {R̂_i^w}^{-1} (p̂_j^w - p̂_i^w)
                    //p̂ ij= (R̂ iw ) (p̂ jw − p̂ iw )
                    relative_t = q_other_all[flag_start][i_other-j].inverse() * relative_t;
                    //ψ̂ _ij = ψ̂ _j − ψ̂ _i
                    double relative_yaw = euler_other_all[flag_start][i_other][0] - euler_other_all[flag_start][i_other-j][0];
//                    cout<<"其它地图序列帧relative_t："<<relative_t[0]<<" , "<<relative_t[1]<<" , "<<relative_t[2]<<endl;
//                    cout<<"其它地图序列帧euler_conncected："<<euler_conncected[0]<<" , "<<euler_conncected[1]<<" , "<<euler_conncected[2]<<endl;
//                    cout<<"其它地图序列帧relative_yaw："<<relative_yaw<<endl;
                    ceres::CostFunction* cost_function = FourDOFError_another::Create( relative_t.x(), relative_t.y(), relative_t.z(),
                                                                              relative_yaw, euler_conncected.y(), euler_conncected.z());
                    problem.AddResidualBlock(cost_function, loss_function, euler_other_all[flag_start][i_other-j],
                                             t_other_all[flag_start][i_other-j],
                                             euler_other_all[flag_start][i_other],
                                             t_other_all[flag_start][i_other]);
                }
                else
                {
                    break;
                }
                j++;
            }
          
            //        添加的是闭环边，是指检测到闭环的两帧 一个数据拆成两份 这个注释掉了
            if((*it_other)->is_get_loop_info)
            {
                //这里后面还要添加else
                if((*it_other)->loop_index <0)
                {
                    assert(false);
                }
                //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束
                int connected_index = pMap_other->getKeyframe((*it_other)->loop_index)->resample_globalIndex;

                Vector3d euler_conncected = Utility::R2ypr(q_other_all[flag_start][connected_index].toRotationMatrix());
                Vector3d relative_t((*it_other)->loop_info_better(0), (*it_other)->loop_info_better(1), (*it_other)->loop_info_better(2));
                double relative_yaw = (*it_other)->loop_info_better(3);
                
                ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z(),10.0);
                problem.AddResidualBlock(cost_function, NULL, euler_other_all[flag_start][connected_index],
                                         t_other_all[flag_start][connected_index],
                                         euler_other_all[flag_start][i_other],
                                         t_other_all[flag_start][i_other]);
                
            }
           
            if((*it_other)->has_global_loop)
           {
    //           获取是和哪个其它地图发生了回环
              (*it_other)->readWriteLock_loop.readLock();
              int loop_index_flag_end=(*it_other)->clientId.size();
              (*it_other)->readWriteLock_loop.readUnLock();
    //           遍历该帧的 所有回环帧
              for(int loop_index_flag=0;loop_index_flag<loop_index_flag_end;loop_index_flag++){
                  (*it_other)->readWriteLock_loop.readLock();
                  int matching_clientId=(*it_other)->clientId[loop_index_flag];
                  int matching_kfId=(*it_other)->kfId[loop_index_flag];
                  std::pair<Matrix3d , Vector3d > matching_rt=(*it_other)->relativePose[loop_index_flag];
                  (*it_other)->readWriteLock_loop.readUnLock();
                  
//                  Vector3d euler_conncected = Utility::R2ypr(matching_rt.first);
//                  Vector3d relative_t=matching_rt.second;
//                  double relative_yaw = euler_conncected[0];
                  
                  if(matching_clientId==pMainMap->c->id){
                      if(matching_kfId < earliest_loop_index_main)
                      {
                          //因为这意味着数据保存出错了 发生了融合的帧的id小于最早发生融合的id
                          assert(false);
                          return;
                      }
                      //说明是和此次新增地图 发生匹配
                      //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束
                      int connected_index = pMainMap->getKeyframe(matching_kfId)->resample_globalIndex;
                      
//                      double relative_yaw =euler_conncected[0]-euler_array_main[connected_index][0];
                      
                      Vector3d euler_conncected = Utility::R2ypr(q_array_main[connected_index].toRotationMatrix());
                      Vector3d relative_t((*it_other)->relative_global_loop_info_multiClient[loop_index_flag](0), (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](1), (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](2));
                      double relative_yaw = (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](7);

                      //这里到时候 再写一个求导的
                      ceres::CostFunction* cost_function1 = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z(),10.0);
                      problem.AddResidualBlock(cost_function1, NULL, euler_array_main[connected_index],
                                               t_array_main[connected_index],
                                               euler_other_all[flag_start][i_other],
                                               t_other_all[flag_start][i_other]);
                      
//                      MultiClientFactor_merge *f = new MultiClientFactor_merge(relative_t, euler_conncected.y(), euler_conncected.z());
//                      problem.AddResidualBlock(f, NULL, euler_array_main[connected_index],
//                                               t_array_main[connected_index],t_other_all[flag_start][i_other] ,t_global_main_relative,r_global_main_relative ,t_global_all[flag_start][i_other] ,r_global_all[flag_start][i_other]);
//
//                      Vector3d euler_conncected_j = Utility::R2ypr(q_other_all[flag_start][i_other].toRotationMatrix());
//                      ceres::CostFunction* cost_function = EightDOFWeightError_yaw::Create( relative_yaw, euler_conncected.y(), euler_conncected.z(),euler_conncected_j.y(),euler_conncected_j.z());
//                    problem.AddResidualBlock(cost_function, NULL, euler_array_main[connected_index],euler_other_all[flag_start][i_other],r_global_main_relative ,r_global_all[flag_start][i_other]);
                      
//                      同上暂时注释的
//                      MultiClientFactor_merge *f = new MultiClientFactor_merge(relative_t, euler_conncected.y(), euler_conncected.z());
//                      problem.AddResidualBlock(f, NULL, euler_array_main[connected_index],
//                                               t_array_main[connected_index],t_other_all[flag_start][i_other] ,t_global_main_relative,r_global_main_relative ,t_global_all[flag_start] ,r_global_all[flag_start]);
//
//                      Vector3d euler_conncected_j = Utility::R2ypr(q_other_all[flag_start][i_other].toRotationMatrix());
//                      ceres::CostFunction* cost_function = EightDOFWeightError_yaw::Create( relative_yaw, euler_conncected.y(), euler_conncected.z(),euler_conncected_j.y(),euler_conncected_j.z());
//                    problem.AddResidualBlock(cost_function, NULL, euler_array_main[connected_index],euler_other_all[flag_start][i_other],r_global_main_relative ,r_global_all[flag_start]);
                      
                  }else{
                      int vmap_index=vMapId_all[matching_clientId];
                      if(matching_kfId < earliest_loopIndex_other_all[vmap_index])
                      {
                          //因为这意味着数据保存出错了 发生了融合的帧的id小于最早发生融合的id
                          assert(false);
                          return;
                      }
                      
        //               找到这个对应的其它地图
                      PoseGraph * pMap_fuse=vMap_all[vmap_index];
                      //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束 会出现空指针的问题
                      int connected_index = pMap_fuse->getKeyframe(matching_kfId)->resample_globalIndex;//这里可能多个
                        
    //                  double relative_yaw =euler_conncected[0]-euler_other_all[vmap_index][connected_index][0];
                      
                      Vector3d euler_conncected = Utility::R2ypr(q_other_all[vmap_index][connected_index].toRotationMatrix());
                      Vector3d relative_t((*it_other)->relative_global_loop_info_multiClient[loop_index_flag](0), (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](1), (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](2));
                      double relative_yaw = (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](7);

                       //这里到时候 再写一个求导的
                       ceres::CostFunction* cost_function1 = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z(),10.0);
                       problem.AddResidualBlock(cost_function1, NULL, euler_other_all[vmap_index][connected_index],
                                            t_other_all[vmap_index][connected_index],
                                            euler_other_all[flag_start][i_other],
                                            t_other_all[flag_start][i_other]);
                      
//                      MultiClientFactor_merge *f = new MultiClientFactor_merge(relative_t, euler_conncected.y(), euler_conncected.z());
//                      problem.AddResidualBlock(f, NULL, euler_other_all[vmap_index][connected_index],
//                                                 t_other_all[vmap_index][connected_index] ,t_other_all[flag_start][i_other],t_global_all[vmap_index][connected_index],r_global_all[vmap_index][connected_index] ,t_global_all[flag_start][i_other],r_global_all[flag_start][i_other]);
//
//                      Vector3d euler_conncected_j = Utility::R2ypr(q_other_all[flag_start][i_other].toRotationMatrix());
//                      ceres::CostFunction* cost_function = EightDOFWeightError_yaw::Create( relative_yaw, euler_conncected.y(), euler_conncected.z(),euler_conncected_j.y(),euler_conncected_j.z());
//                    problem.AddResidualBlock(cost_function, NULL, euler_other_all[vmap_index][connected_index] ,euler_other_all[flag_start][i_other] , r_global_all[vmap_index][connected_index] ,r_global_all[flag_start][i_other]);
                      
//                      同上暂时注释的
//                      MultiClientFactor_merge *f = new MultiClientFactor_merge(relative_t, euler_conncected.y(), euler_conncected.z());
//                      problem.AddResidualBlock(f, NULL, euler_other_all[vmap_index][connected_index],
//                                                 t_other_all[vmap_index][connected_index] ,t_other_all[flag_start][i_other],t_global_all[vmap_index] ,r_global_all[vmap_index] ,t_global_all[flag_start] ,r_global_all[flag_start] );
//
//                      Vector3d euler_conncected_j = Utility::R2ypr(q_other_all[flag_start][i_other].toRotationMatrix());
//                      ceres::CostFunction* cost_function = EightDOFWeightError_yaw::Create( relative_yaw, euler_conncected.y(), euler_conncected.z(),euler_conncected_j.y(),euler_conncected_j.z());
//                    problem.AddResidualBlock(cost_function, NULL, euler_other_all[vmap_index][connected_index] ,euler_other_all[flag_start][i_other] , r_global_all[vmap_index]  ,r_global_all[flag_start] );
                  }
                  
                  
              }
           }
            if ((*it_other)->global_index == latest_loopIndex_other_all[flag_start])
                break;
            i_other++;
          
        }

    }
    
    ceres::Solve(options, &problem, &summary);
    
    std::cout << "global fuse: "<<summary.BriefReport() << "\n";
    if(summary.termination_type!=ceres::CONVERGENCE){
        
        return;
    }
    
    pMainMap->special_kf_mutex.lock();
    pMainMap->add2_kf_id_hasComPlace_withOtherMap(kf_id_hasComPlace_main);
    pMainMap->special_kf_inOpti.push(special_kf_inOpti_main);
    pMainMap->special_kf_mutex.unlock();
    pMainMap->loop_index_multiClient.push(earliest_loop_index_main);
    pMainMap->curKF_loop_index_multiClient.push(latest_loop_index_main);//这个是要发回客户端 用来更新位姿的 TODO 后面要改改
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
        vector<int> special_kf_inOpti_cur=special_kf_inOpti_cur_all[flag_start];
        vector<int> kf_id_hasCom_cur=kf_id_hasCom_cur_all[flag_start];
        pMap_other->special_kf_mutex.lock();
        pMap_other->add2_kf_id_hasComPlace_withOtherMap(kf_id_hasCom_cur);
        pMap_other->special_kf_inOpti.push(special_kf_inOpti_cur);
        pMap_other->special_kf_mutex.unlock();
        
        int latest_loop_index=latest_loop_index_other_correct[flag_start];
        pMap_other->isFirstFusion_globalMutex.lock();
        pMap_other->loop_index_multiClient.push(0);
        pMap_other->curKF_loop_index_multiClient.push(latest_loop_index);
        pMap_other->isFirstFusion_globalMutex.unlock();
    }
    //------------------------------------------第一个数据优化后更新
    //优化完成，使用优化后的位姿来更新关键帧列表中index大于等于earliest_loop_index的所有关键帧的位姿
    
    Vector3d t_drift_it_other = Vector3d::Zero();
    Matrix3d r_drift_it_other = Matrix3d::Identity();
    
    vector<Matrix3d> r_global_cur;
    vector<Vector3d> t_global_cur;
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
        list<KeyFrame*>::iterator it_other = pMap_other->keyFrameList.begin();
        i_other = 0;
        r_global_cur.clear();
        t_global_cur.clear();
        for (; it_other != pMap_other->keyFrameList.end(); it_other++)
        {
            
            Quaterniond tmp_q;
            //向量转换为矩阵
            tmp_q = Utility::ypr2R(Vector3d(euler_other_all[flag_start][i_other][0], euler_other_all[flag_start][i_other][1], euler_other_all[flag_start][i_other][2]));
            Vector3d tmp_w1_t = Vector3d(t_other_all[flag_start][i_other][0], t_other_all[flag_start][i_other][1], t_other_all[flag_start][i_other][2]);
            Matrix3d tmp_w1_r = tmp_q.toRotationMatrix();
            
         
           
            if(resample_other_all[flag_start][i_other])
            {
                (*it_other)-> updatePose(r_drift_it_other * tmp_w1_t + t_drift_it_other, r_drift_it_other * tmp_w1_r);
            }
            else
            {
                Vector3d origin_t_it;
                Matrix3d origin_r_it;
                (*it_other)->getOriginPose(origin_t_it, origin_r_it);
                
                
                r_drift_it_other = tmp_w1_r * origin_r_it.transpose();
                t_drift_it_other = tmp_w1_t - r_drift_it_other * origin_t_it;
                (*it_other)-> updatePose(tmp_w1_t, tmp_w1_r);
                
    //            pCurMap->add2_r_global_multiClient(tmp_w1_r);
    //            pCurMap->add2_t_global_multiClient(tmp_w1_t);
                r_global_cur.push_back(tmp_w1_r);
                t_global_cur.push_back(tmp_w1_t);
            }
            if ((*it_other)->global_index == latest_loopIndex_other_all[flag_start])
                break;
            i_other++;
            
        }
        //如果将地图建模成可变形的呢
        //根据计算出当前帧的drift，更新全部关键帧位姿
        Vector3d cur_t_other, origin_t_other;
        Matrix3d cur_r_other, origin_r_other;
        //获取优化后当前帧的位姿cur_t,cur_r
        (*it_other)->getPose(cur_t_other, cur_r_other);
        //获取优化前有漂移的当前帧的位姿vio_t,vio_r
        (*it_other)->getOriginPose(origin_t_other, origin_r_other);
        pMap_other->yaw_drift = Utility::R2ypr(cur_r_other).x() - Utility::R2ypr(origin_r_other).x();
        pMap_other->r_drift = Utility::ypr2R(Vector3d(pMap_other->yaw_drift, 0, 0));
        pMap_other->t_drift = cur_t_other - pMap_other->r_drift * origin_t_other;
        
    //    pCurMap->add2_r_global_multiClient(pCurMap->r_drift);
    //    pCurMap->add2_t_global_multiClient(pCurMap->t_drift);
        r_global_cur.push_back(pMap_other->r_drift);
        t_global_cur.push_back(pMap_other->t_drift);
        pMap_other->add2_r_global_multiClient(r_global_cur);
        pMap_other->add2_t_global_multiClient(t_global_cur);
        if((r_global_cur.size()-1)!=pMap_other->special_kf_inOpti.back().size() && (r_global_cur.size()-1)!=(t_global_cur.size()-1)){
            cout<<"当前地图id"<<pMap_other->c->id<<" , "<<latest_loopIndex_other_all[flag_start]<<endl;
            cout<<"resample下标数量不一致："<<r_global_cur.size()<<" , "<<pMap_other->special_kf_inOpti.back().size()<<" , "<<t_global_cur.size()<<endl;
//            while (pMap_other->special_kf_inOpti.size()!=2)
//            {
//                cout << pMap_other->special_kf_inOpti.front().size()<< " "; // Output the 1st element
//                pMap_other->special_kf_inOpti.pop();  // Delete the 1st element
//            }
//            std::cout << std::endl;
//            cout << "倒数第二个："<<pMap_other->special_kf_inOpti.front().size()<< endl;
            assert(false);//20 38
        }

        //下面代码为把当前关键帧it之后的关键帧的位姿通过求解的偏移量转换到world坐标系下
        for (; it_other != pMap_other->keyFrameList.end(); it_other++)
        {
            Vector3d P;
            Matrix3d R;
            (*it_other)->getOriginPose(P, R);
            P = pMap_other->r_drift * P + pMap_other->t_drift;
            R = pMap_other->r_drift * R;
            (*it_other)-> updatePose(P, R);
        }
        pMap_other->lastKF_index.push(pMap_other->keyFrameList.back()->global_index);
    }
    
    
    
    //---------------------------------------第2个数据的更新
    //优化完成，使用优化后的位姿来更新关键帧列表中index大于等于earliest_loop_index的所有关键帧的位姿
    i_main = 0;
    Vector3d t_drift_it_main = Vector3d::Zero();
    Matrix3d r_drift_it_main = Matrix3d::Identity();
    
    vector<Matrix3d> r_global_main;
    vector<Vector3d> t_global_main;
    for (it_main = pMainMap->keyFrameList.begin(); it_main != pMainMap->keyFrameList.end(); it_main++)
    {
        if ((*it_main)->global_index < earliest_loop_index_main)
            continue;

        Quaterniond tmp_q;
        //向量转换为矩阵
        tmp_q = Utility::ypr2R(Vector3d(euler_array_main[i_main][0], euler_array_main[i_main][1], euler_array_main[i_main][2]));
        Vector3d tmp_w1_t = Vector3d(t_array_main[i_main][0], t_array_main[i_main][1], t_array_main[i_main][2]);
        Matrix3d tmp_w1_r = tmp_q.toRotationMatrix();

//                cout<<"测试 优化完成 更新哪里变了："<<euler_array_main[i_main][0]<<" "<<euler_array_main[i_main][1]<<" "<<euler_array_main[i_main][2]<<" "<<t_array_main[i_main][0]<<" "<<t_array_main[i_main][1]<<" "<<t_array_main[i_main][2]<<" "<<i_main<<endl;
        if(need_resample_main[i_main])
        {
            (*it_main)-> updatePose(r_drift_it_main * tmp_w1_t + t_drift_it_main, r_drift_it_main * tmp_w1_r);
        }
        else
        {
            Vector3d origin_t_it;
            Matrix3d origin_r_it;
            (*it_main)->getOriginPose(origin_t_it, origin_r_it);
            r_drift_it_main = tmp_w1_r * origin_r_it.transpose();
            t_drift_it_main = tmp_w1_t - r_drift_it_main * origin_t_it;
            (*it_main)-> updatePose(tmp_w1_t, tmp_w1_r);
            
//            pMainMap->add2_r_global_multiClient(tmp_w1_r);
//            pMainMap->add2_t_global_multiClient(tmp_w1_t);
            r_global_main.push_back(tmp_w1_r);
            t_global_main.push_back(tmp_w1_t);

        }
        if ((*it_main)->global_index == latest_loop_index_main)
            break;
        i_main++;

    }
    //根据计算出当前帧的drift，更新全部关键帧位姿
    Vector3d cur_t_main, origin_t_main;
    Matrix3d cur_r_main, origin_r_main;
    //获取优化后当前帧的位姿cur_t,cur_r
    (*it_main)->getPose(cur_t_main, cur_r_main);
    //获取优化前有漂移的当前帧的位姿vio_t,vio_r
    (*it_main)->getOriginPose(origin_t_main, origin_r_main);
    pMainMap->yaw_drift = Utility::R2ypr(cur_r_main).x() - Utility::R2ypr(origin_r_main).x();
    pMainMap->r_drift = Utility::ypr2R(Vector3d(pMainMap->yaw_drift, 0, 0));
    pMainMap->t_drift = cur_t_main - pMainMap->r_drift * origin_t_main;
    
//    pMainMap->add2_r_global_multiClient(pMainMap->r_drift);
//    pMainMap->add2_t_global_multiClient(pMainMap->t_drift);
    r_global_main.push_back(pMainMap->r_drift);
    t_global_main.push_back(pMainMap->t_drift);
    pMainMap->add2_r_global_multiClient(r_global_main);
    pMainMap->add2_t_global_multiClient(t_global_main);
    
    if((r_global_main.size()-1)!=pMainMap->special_kf_inOpti.back().size()  && (r_global_main.size()-1)!=(t_global_main.size()-1)){
        cout<<"当前地图id"<<pMainMap->c->id<<" , "<<latest_loop_index_main<<endl;
        cout<<"resample_main下标数量不一致："<<r_global_main.size()<<" , "<<pMainMap->special_kf_inOpti.back().size()<<" , "<<t_global_main.size()<<endl;
//        while (pMainMap->special_kf_inOpti.size()!=2)
//        {
//            cout << pMainMap->special_kf_inOpti.front().size()<< " "; // Output the 1st element
//            pMainMap->special_kf_inOpti.pop();  // Delete the 1st element
//        }
//        std::cout << std::endl;
//        cout << "倒数第二个："<<pMainMap->special_kf_inOpti.front().size()<< endl;
        assert(false);//20 38
    }
    

    //下面代码为把当前关键帧it之后的关键帧的位姿通过求解的偏移量转换到world坐标系下
    for (; it_main != pMainMap->keyFrameList.end(); it_main++)
    {
        Vector3d P;
        Matrix3d R;
        (*it_main)->getOriginPose(P, R);
        P = pMainMap->r_drift * P + pMainMap->t_drift;
        R = pMainMap->r_drift * R;
        (*it_main)-> updatePose(P, R);
    }
    
//    pCurMap->isFirstFusion_globalMutex.unlock();
    
    
    
    
    
    pMainMap->lastKF_index.push(pMainMap->keyFrameList.back()->global_index);
//            位姿更新都留到显示那里
    pMainMap->updateVisualization();
    
    readWriteLock.readLock();
    PoseGraph* pMainMap_0=PoseGraphGloabl_map[0];
    readWriteLock.readUnLock();
    
   
    pAddKfMap->refine_path_mutex.lock();
    if(isUpdateFusionDraw){
        pMainMap_0->fusion_relative_isUpdate[pMainMap->c->id]=0;
        pMainMap_0->fusion_poseGraph_mutex.lock();
        pMainMap_0->fusion_otherGraph[pMainMap->c->id]=pMainMap;
        pMainMap_0->fusion_poseGraph_mutex.unlock();
    }
    pAddKfMap->refine_path_mutex.unlock();
    
    
    
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
        pMap_other->updateVisualization();
        pMap_other->isSendGloablData_multiClient=true;
        
        pAddKfMap->refine_path_mutex.lock();
        if(isUpdateFusionDraw){
            pMainMap_0->fusion_relative_isUpdate[pMap_other->c->id]=0;
            pMainMap_0->fusion_poseGraph_mutex.lock();
            pMainMap_0->fusion_otherGraph[pMap_other->c->id]=pMap_other;
            pMainMap_0->fusion_poseGraph_mutex.unlock();
        }
        pAddKfMap->refine_path_mutex.unlock();
        
        
        delete [](t_other_all[flag_start][0]);
        delete [](t_other_all[flag_start][1]);
        delete [](t_other_all[flag_start][2]);
        delete [](t_other_all[flag_start]);
        delete [](euler_other_all[flag_start][0]);
        delete [](euler_other_all[flag_start][1]);
        delete [](euler_other_all[flag_start][2]);
        delete [](euler_other_all[flag_start]);
        
//        for(int i=0;i<3;i++){
//            delete [](t_global_all[flag_start][i]);
//        }
//        delete [](t_global_all[flag_start]);
//        for(int i=0;i<4;i++){
//            delete [](r_global_all[flag_start][i]);
//        }
//        delete [](r_global_all[flag_start]);
              
    }
    //发送数据
    pMainMap->isSendGloablData_multiClient=true;
    
    //    TODO 用来多用户ar 发送ar位姿的
        pAddKfMap->isFirstFusion_globalMutex.lock();
        isFusion[i]=1;
        pAddKfMap->isFirstFusion_globalMutex.unlock();

    cout<<"最终的全局优化结束"<<i<<endl;
//    cout<<"测试 偏移对不对"<<pCurMap->t_drift[0]<<" "<<pCurMap->t_drift[1]<<" "<<pCurMap->t_drift[2]<<endl;
//    cout<<"主地图为："<<pMainMap->c->id<<endl;
//    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
//        cout<<"t:"<<t_global_all[flag_start][0]<<" , "<<t_global_all[flag_start][1]<<" , "<<t_global_all[flag_start][2]<<endl;
//        // roll (x-axis rotation)
//            double sinr_cosp = 2 * (r_global_all[flag_start][3] * r_global_all[flag_start][0] + r_global_all[flag_start][1] * r_global_all[flag_start][2]);
//            double cosr_cosp = 1 - 2 * (r_global_all[flag_start][0] * r_global_all[flag_start][0] + r_global_all[flag_start][1] * r_global_all[flag_start][1]);
//            double roll = std::atan2(sinr_cosp, cosr_cosp);
//
//            // pitch (y-axis rotation)
//            double sinp = 2 * (r_global_all[flag_start][3] * r_global_all[flag_start][1] - r_global_all[flag_start][2] * r_global_all[flag_start][0]);
//            double pitch;
//            if (std::abs(sinp) >= 1)
//                pitch = std::copysign(M_PI / 2, sinp); // use 90 degrees if out of range
//            else
//                pitch = std::asin(sinp);
//
//            // yaw (z-axis rotation)
//            double siny_cosp = 2 * (r_global_all[flag_start][3]* r_global_all[flag_start][2] + r_global_all[flag_start][0] * r_global_all[flag_start][1]);
//            double cosy_cosp = 1 - 2 * (r_global_all[flag_start][1] * r_global_all[flag_start][1] + r_global_all[flag_start][2] * r_global_all[flag_start][2]);
//            double yaw = std::atan2(siny_cosp, cosy_cosp);
//
//        cout<<"r:"<< yaw <<" , " <<pitch<<" , " <<roll<<endl;
//    }
    
}
 
//告诉先验相对位姿 都优化
void PoseGraphGlobal::GlobalFuse_11(int i)
{
    cout<<"最终的全局优化"<<i<<endl;
    bool isUpdateFusionDraw=false;
//    cout<<"死锁没"<<endl;
    //因为现在写的都是和主地图发生地图融合 所以其中一个地图直接这么获取了
//    poseGraphGlobal_mutex.lock();
    readWriteLock.readLock();
    map<int,PoseGraph*>::iterator iter_map = PoseGraphGloabl_map.find(i);
    if(iter_map==PoseGraphGloabl_map.end())
    {
//        poseGraphGlobal_mutex.unlock();
        readWriteLock.readUnLock();
        assert(false);//都已经发生回环了，却找不到地图 说明数据插错
    }
    PoseGraph* pAddKfMap= iter_map->second;
    int len = PoseGraphGloabl_map.size();
    readWriteLock.readUnLock();
    
    vector<std::unique_lock<std::mutex>* > lock_all;
    std::unique_lock<std::mutex> lock(pAddKfMap->keyFrameList_global_fusion_mutex, std::defer_lock);
    if (lock.try_lock()) {
        cout<<"加锁："<<pAddKfMap->c->id<<endl;
        lock_all.push_back(&lock);
    } else {
        cout<<"最终的全局优化中断"<<i<<endl;
        return;
    }
    if(i==mainClientID){
        isUpdateFusionDraw=true;
    }


    
    double total_lenth_other=0.0;
    vector< double> length_other;
    PoseGraph* pMainMap;//id最小的
    vector<PoseGraph *> vMap_all;//除id最小,也就是匹配上的全部其它地图
    map<int,int> vMapId_all;//int表示clientId 后面表示存放在vMap_all的下标
    //找其它融合的地图 一起参与优化
    bool isFindMinClient=true;
    readWriteLock.readLock();
    if(PoseGraphGloabl_map.size()>1){
        readWriteLock.readUnLock();
        for(int client_id=0;client_id<len;client_id++){//这里的i其实代表的就是 ClientId
            if(client_id==i){
                continue;
            }
            if(uf.isConnected(i, client_id)){
                readWriteLock.readLock();
                map<int,PoseGraph*>::iterator iter_map_other = PoseGraphGloabl_map.find(client_id);
                if(iter_map_other==PoseGraphGloabl_map.end()){
                    readWriteLock.readUnLock();
                    continue;
                }
                PoseGraph* pOtherMap= iter_map_other->second;//新的地图 小的地图
                readWriteLock.readUnLock();
                
                
                std::unique_lock<std::mutex> lock(pOtherMap->keyFrameList_global_fusion_mutex, std::defer_lock);
                if (lock.try_lock()) {
                    cout<<"加锁："<<pOtherMap->c->id<<endl;
                    lock_all.push_back(&lock);
                } else {
                    //                    把之前锁住了的解锁了
                    cout<<"最终的全局优化中断"<<pOtherMap->c->id<<endl;
                    return;
                }
         
                
                if(isFindMinClient){
                    isFindMinClient=false;
                    if(i>client_id){
//                        这里就是id最小的地图
                        pMainMap=pOtherMap;
//                        cout<<"主地图大小："<<pMainMap->size()<<endl;
                      
                        vMap_all.push_back(pAddKfMap);
                        vMapId_all.insert(make_pair(pAddKfMap->c->id,vMap_all.size()-1));
                        total_lenth_other+=pAddKfMap->total_length;
                        length_other.push_back(pAddKfMap->total_length);
                        
                        if(client_id==mainClientID){
                            isUpdateFusionDraw=true;
                        }
                        continue;
                    }else{
                        pMainMap=pAddKfMap;
                    }
                }
                vMap_all.push_back(pOtherMap);
                vMapId_all.insert(make_pair(pOtherMap->c->id,vMap_all.size()-1));
                
                total_lenth_other+=pOtherMap->total_length;
                length_other.push_back(pOtherMap->total_length);
                
            }
            
        }
    }
    else{
        readWriteLock.readUnLock();
        assert(false);//都要发生全局优化了 却只有1个地图
    }
    
   
    
    //主地图从earliest_loop_index_main开始--当前帧结束
    //小地图从第一帧开始--当前发生回环的帧 这个有可能是回环帧，也有可能是融合帧
    ceres::Problem problem;
    ceres::Solver::Options options;
    //options.linear_solver_type = ceres::DENSE_NORMAL_CHOLESKY;
    options.linear_solver_type = ceres::DENSE_SCHUR;
    options.minimizer_progress_to_stdout = false;
    options.max_num_iterations = 10;
    ceres::Solver::Summary summary;
    ceres::LossFunction *loss_function;
    loss_function = new ceres::HuberLoss(1.0);
    //AngleLocalParameterization类的主要作用是指定yaw角优化变量的迭代更新，重载了括号运算
//    ceres::LocalParameterization* angle_local_parameterization =
//    AngleLocalParameterization::Create();
    ceres::LocalParameterization* local_parameterization = new ceres::QuaternionParameterization();

            
    
    double total_lenth_main=pMainMap->total_length;
    //总的位姿长度 除以总的帧数
    double total_lenth_sum=total_lenth_main+total_lenth_other;
    int max_frame_num_global_main=(total_lenth_main/total_lenth_sum)*max_frame_num_global;
    double min_dis_main=total_lenth_main/max_frame_num_global_main;
    
    //要优化的变量的最大个数 主地图
    int max_length_main=pMainMap->size()+1;
    double t_array_main[max_length_main][3];//平移数组，其中存放每个关键帧的平移向量
    Quaterniond q_array_main[max_length_main];
    double euler_array_main[max_length_main][3];
    double quaterniond_array_main[max_length_main][4];
    vector<bool> need_resample_main;
    
//    double rt_global_main[7]={0};//为单位矩阵
//    rt_global_main[6]=1;
    double t_global_main_relative[3]={0};//为单位矩阵
    double r_global_main_relative[4]={0};//为单位矩阵
    r_global_main_relative[3]=1;
    
    pMainMap->max_frame_num_global=max_frame_num_global_main;
    pMainMap->min_dis=min_dis_main;
    

    const int mapOther_sum=vMap_all.size();
    vector< double** > t_other_all;
    vector< vector<Quaterniond > > q_other_all;
    vector< double** > euler_other_all;//里面存储的是度数  不是弧度
    vector< double** > quaterniond_other_all;
    vector< vector<bool> > resample_other_all;
    
//    vector< double > pitch_other_all;
//    vector< double > roll_other_all;
//    这个后续记录在帧内部
//    vector< double** > rt_global_all;
    
//    这个是每一帧都有一个rt
//    vector< double** > t_global_all;
//    vector< double** > r_global_all;
    
//    这个是每一地图都有一个rt
    vector< double* > t_global_all;
    vector< double* > r_global_all;
    
    int main_clientId=pMainMap->c->id;
    
    pMainMap->loop_index_mutex.lock();
    int earliest_loop_index_main=pMainMap->earliest_loop_index;
    int earliest_global_looped_index_main=earliest_globalLoop_index[pMainMap->c->id];
    int latest_loop_index_main=pMainMap->latest_loop_index;
    int latest_global_looped_index_main=latest_globalLoop_index[pMainMap->c->id];
    pMainMap->loop_index_mutex.unlock();
    
    if (earliest_loop_index_main > earliest_global_looped_index_main || earliest_loop_index_main == -1  )
        earliest_loop_index_main=earliest_global_looped_index_main;
    
    
    if (latest_global_looped_index_main > latest_loop_index_main)
        latest_loop_index_main=latest_global_looped_index_main;
//    pMainMap->loop_index_multiClient.push(earliest_loop_index_main);
//    pMainMap->curKF_loop_index_multiClient.push(latest_loop_index_main);//这个是要发回客户端 用来更新位姿的 TODO 后面要改改
    vector<int> latest_loop_index_other_correct;
    vector<int> earliest_loopIndex_other_all;
    vector<int> latest_loopIndex_other_all;
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
        
        pMap_other->loop_index_mutex.lock();
        int earliest_loop_index_other=pMap_other->earliest_loop_index;
        int earliest_global_looped_index_other=earliest_globalLoop_index[pMap_other->c->id];
        int latest_loop_index_other=pMap_other->latest_loop_index;
        int latest_global_looped_index_other=latest_globalLoop_index[pMap_other->c->id];
        pMap_other->loop_index_mutex.unlock();
        
        if (earliest_loop_index_other > earliest_global_looped_index_other || earliest_loop_index_other == -1  )
            earliest_loop_index_other=earliest_global_looped_index_other;
        earliest_loopIndex_other_all.push_back(earliest_loop_index_other);
        
        
        if (latest_global_looped_index_other > latest_loop_index_other)
            latest_loop_index_other=latest_global_looped_index_other;
        latest_loopIndex_other_all.push_back(latest_loop_index_other);
        
//        pMap_other->isFirstFusion_globalMutex.lock();
//        pMap_other->loop_index_multiClient.push(0);
//        pMap_other->curKF_loop_index_multiClient.push(latest_loop_index_other);
//        pMap_other->isFirstFusion_globalMutex.unlock();
        latest_loop_index_other_correct.push_back(latest_loop_index_other);
        
        double total_length_otherMap=length_other[flag_start];
        int max_frame_num_global_other=(total_length_otherMap/total_lenth_sum)*max_frame_num_global;
        double min_dis_other=total_length_otherMap/max_frame_num_global_other;
        pMap_other->max_frame_num_global=max_frame_num_global_other;
        pMap_other->min_dis=min_dis_other;
        
        //要优化的变量的最大个数 小地图
        int max_length_other=pMap_other->keyFrameList.size()+1;
        double** t_test=new double*[max_length_other];
        for(int index_flag=0;index_flag<max_length_other;index_flag++) t_test[index_flag] = new double[3];
        t_other_all.push_back(t_test);
        
        vector<Quaterniond > q_array_other(max_length_other);
        q_other_all.push_back(q_array_other);
        
        double** euler_test=new double*[max_length_other];
        for(int index_flag=0;index_flag<max_length_other;index_flag++) euler_test[index_flag] = new double[3];
        euler_other_all.push_back(euler_test);
        
        double** quaterniond_test=new double*[max_length_other];
        for(int index_flag=0;index_flag<max_length_other;index_flag++) quaterniond_test[index_flag] = new double[4];
        quaterniond_other_all.push_back(quaterniond_test);
        
        vector<bool> need_resample_other;
        resample_other_all.push_back(need_resample_other);
        
//        double** t_global_test=new double*[max_length_other];
//        double** r_global_test=new double*[max_length_other];
//        for(int index_flag=0;index_flag<max_length_other;index_flag++){
//            t_global_test[index_flag] = new double[3];
//            r_global_test[index_flag] = new double[4];
//            r_global_test[index_flag][3]=1;
//
//            for(int hh=0;hh<3;hh++){
//                t_global_test[index_flag][hh]=0;
//                r_global_test[index_flag][hh]=0;
//            }
//        }
//        t_global_all.push_back(t_global_test);
//        r_global_all.push_back(r_global_test);
        
        double t_global_test[3]={0};
        double r_global_test[4]={0};
        r_global_test[3]=1;
        t_global_all.push_back(t_global_test);
        r_global_all.push_back(r_global_test);
    }
   
    //*************************************遍历数据 记录要参与优化的

    vector<int> special_kf_inOpti_main;
    vector<int> kf_id_hasComPlace_main;
    //遍历关键帧列表
    list<KeyFrame*>::iterator it_main = pMainMap->keyFrameList.begin();
    Vector3d last_P_main = Vector3d(0, 0, 0);
    double dis_main = 0;
    int resample_id=0;
    for(;it_main!=pMainMap->keyFrameList.end();it_main++){
        if((*it_main)->global_index < earliest_loop_index_main){
            continue;
        }
        (*it_main)->resample_globalIndex = resample_id;
        Vector3d tmp_t;
        Matrix3d tmp_r;
        //获取关键帧it的位姿
        (*it_main)->getPose(tmp_t, tmp_r);
        dis_main += (tmp_t - last_P_main).norm();
        //全局优化 还是要加序列边 不然太长了 判断条件 再加个两个地图之间发生了融合
        if((*it_main)->global_index == earliest_loop_index_main || dis_main > min_dis_main || (*it_main)->is_get_loop_info || (*it_main)->is_looped || (*it_main)->has_global_loop || (*it_main)->is_global_looped || pMainMap->keyFrameList.size() < max_frame_num_global_main)
        {
            dis_main = 0;
            last_P_main = tmp_t;
            need_resample_main.push_back(0);
            
//            pMainMap->special_kf_inOpti.push_back((*it_main)->global_index);
            special_kf_inOpti_main.push_back((*it_main)->global_index);
            
            if(((*it_main)->has_global_loop || (*it_main)->is_global_looped) && (*it_main)->is_Send==false ){
                kf_id_hasComPlace_main.push_back((*it_main)->global_index);
//                pMainMap->add2_kf_id_hasComPlace_withOtherMap((*it_main)->global_index);
                (*it_main)->is_Send=true;
            }
            
        }
        else
        {
            last_P_main = tmp_t;
            need_resample_main.push_back(1);
        }
        
        Quaterniond tmp_q;
        Matrix3d tmp_r_origin;
        Vector3d tmp_t_origin;
        (*it_main)->getOriginPose(tmp_t_origin, tmp_r_origin);
//                (*it_main)->getPose(tmp_t, tmp_r);
        tmp_q = tmp_r_origin;
        t_array_main[resample_id][0] = tmp_t_origin(0);
        t_array_main[resample_id][1] = tmp_t_origin(1);
        t_array_main[resample_id][2] = tmp_t_origin(2);
        q_array_main[resample_id] = tmp_q;
        //将矩阵转换为向量
        Vector3d euler_angle = Utility::R2ypr(tmp_r_origin);
        euler_array_main[resample_id][0] = euler_angle.x();
        euler_array_main[resample_id][1] = euler_angle.y();
        euler_array_main[resample_id][2] = euler_angle.z();
        
        quaterniond_array_main[resample_id][0]=tmp_q.w();
        quaterniond_array_main[resample_id][1]=tmp_q.x();
        quaterniond_array_main[resample_id][2]=tmp_q.y();
        quaterniond_array_main[resample_id][3]=tmp_q.z();
        
        resample_id++;
        
        if ((*it_main)->global_index == latest_loop_index_main)
            break;
    }
    
//    pMainMap->special_kf_mutex.lock();
//    pMainMap->add2_kf_id_hasComPlace_withOtherMap(kf_id_hasComPlace_main);
//   pMainMap->special_kf_inOpti.push(special_kf_inOpti_main);
//   pMainMap->special_kf_mutex.unlock();
    
    vector<vector<int> > special_kf_inOpti_cur_all;
    vector<vector<int> > kf_id_hasCom_cur_all;
    
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
        //遍历关键帧列表
        list<KeyFrame*>::iterator it_other = pMap_other->keyFrameList.begin();

//        Vector3d last_P_other = Vector3d(0, 0, 0);
        Vector3d last_P_other =pMap_other->fromI2OtherClient_t[main_clientId];
        double dis_other = 0;
        
        vector<int> special_kf_inOpti_cur;
        vector<int> kf_id_hasCom_cur;
        resample_id=0;
        resample_other_all[flag_start].clear();
       
        int temp_opti=0;
        //小地图是从第一个帧开始优化
        for(;it_other!=pMap_other->keyFrameList.end();it_other++){
            (*it_other)->resample_globalIndex = resample_id;
            
            Vector3d tmp_t;
            Matrix3d tmp_r;
            //获取关键帧it的位姿
            (*it_other)->getPose(tmp_t, tmp_r);
            dis_other += (tmp_t - last_P_other).norm();
            
            
            //全局优化 还是要加序列边 不然太长了 判断条件 再加个两个地图之间发生了融合
            //第一个地图融合位置，超过长度了，发生过回环，被回环了，总共的帧长度比最大值小
            //还要再加一个 发生了融合，被融合了
            if((*it_other)->global_index == 0 || dis_other > pMap_other->min_dis || (*it_other)->is_get_loop_info || (*it_other)->is_looped || (*it_other)->has_global_loop || (*it_other)->is_global_looped || pMap_other->keyFrameList.size() < pMap_other->max_frame_num_global)
            {
                dis_other = 0;
                last_P_other = tmp_t;
                resample_other_all[flag_start].push_back(0);
                
    //            pCurMap->special_kf_inOpti.push_back((*it_other)->global_index);
                special_kf_inOpti_cur.push_back((*it_other)->global_index);
                
                if(((*it_other)->has_global_loop || (*it_other)->is_global_looped) && (*it_other)->is_Send==false ){
                    kf_id_hasCom_cur.push_back((*it_other)->global_index);
    //                pCurMap->add2_kf_id_hasComPlace_withOtherMap((*it_other)->global_index);
                    (*it_other)->is_Send=true;
                }
                
                temp_opti++;
                
            }
            else
            {
                last_P_other = tmp_t;
                resample_other_all[flag_start].push_back(1);
            }
            
            Quaterniond tmp_q;
            Matrix3d tmp_r_origin;
            Vector3d tmp_t_origin;
            (*it_other)->getOriginPose(tmp_t_origin, tmp_r_origin);
    //                (*it_main)->getPose(tmp_t, tmp_r);
//            更新到主地图所在坐标系
            Matrix3d r_w1_w2;
            Vector3d t_w1_w2;
            r_w1_w2=pMap_other->fromI2OtherClient_r[main_clientId];
            t_w1_w2=pMap_other->fromI2OtherClient_t[main_clientId];
            tmp_r_origin=r_w1_w2*tmp_r_origin;
            tmp_t_origin=r_w1_w2*tmp_t_origin+t_w1_w2;
//            cout<<"main_clientId="<<main_clientId<<" , "<<r_w1_w2<<" , "<<t_w1_w2<<endl;
            
            
            tmp_q = tmp_r_origin;
            (t_other_all[flag_start])[resample_id][0] = tmp_t_origin(0);
            (t_other_all[flag_start])[resample_id][1] = tmp_t_origin(1);
            (t_other_all[flag_start])[resample_id][2] = tmp_t_origin(2);
            q_other_all[flag_start][resample_id] = tmp_q;
            //将矩阵转换为向量
            Vector3d euler_angle = Utility::R2ypr(tmp_r_origin);
            euler_other_all[flag_start][resample_id][0] = euler_angle.x();
            euler_other_all[flag_start][resample_id][1] = euler_angle.y();
            euler_other_all[flag_start][resample_id][2] = euler_angle.z();
            
            quaterniond_other_all[flag_start][resample_id][0]=tmp_q.w();
            quaterniond_other_all[flag_start][resample_id][1]=tmp_q.x();
            quaterniond_other_all[flag_start][resample_id][2]=tmp_q.y();
            quaterniond_other_all[flag_start][resample_id][3]=tmp_q.z();
           
            
            resample_id++;
            
            if ((*it_other)->global_index == latest_loopIndex_other_all[flag_start])
                break;
        }
        
//        cout<<"temp_opti="<<temp_opti<<" , "<<latest_loopIndex_other_all[flag_start]<<endl;
        
//        pMap_other->special_kf_mutex.lock();
//        pMap_other->add2_kf_id_hasComPlace_withOtherMap(kf_id_hasCom_cur);
//        pMap_other->special_kf_inOpti.push(special_kf_inOpti_cur);
//        pMap_other->special_kf_mutex.unlock();
        special_kf_inOpti_cur_all.push_back(special_kf_inOpti_cur);
        kf_id_hasCom_cur_all.push_back(kf_id_hasCom_cur);
        
    }
    
    //*************************************第一个数据
//    if(pMainMap->relativeOtherMap_clientId!=-1){
//        assert(false);//因为最小的地图 那他没有和更小的地图融合 relativeOtherMap_clientId这个记录它融合的所有地图的最小id
//    }

//    暂时注释 后面会求导那些了 再改
//        ceres::LocalParameterization *local_parameterization = new PoseQ_LocalParameterization();
//        problem.AddParameterBlock(r_global_main_relative, 4, local_parameterization);
//        problem.SetParameterBlockConstant(r_global_main_relative);
//
//        problem.AddParameterBlock(t_global_main_relative, 3);
//        problem.SetParameterBlockConstant(t_global_main_relative);

    int i_main = 0;
    for (it_main = pMainMap->keyFrameList.begin(); it_main != pMainMap->keyFrameList.end(); it_main++)
    {
        if ((*it_main)->global_index < earliest_loop_index_main)
            continue;

        
        //将关键帧列表中所有index>=earliest_loop_index的关键帧的位姿加入到参数块当中
//        problem.AddParameterBlock(euler_array_main[i_main], 1, angle_local_parameterization);
        problem.AddParameterBlock(quaterniond_array_main[i_main], 4, local_parameterization);
        problem.AddParameterBlock(t_array_main[i_main], 3);
        //设置约束：如果该帧是最早的闭环帧的情况下，则固定它的位姿
        if ((*it_main)->global_index == earliest_loop_index_main)
        {
//            problem.SetParameterBlockConstant(euler_array_main[i_main]);
            problem.SetParameterBlockConstant(quaterniond_array_main[i_main]);
            problem.SetParameterBlockConstant(t_array_main[i_main]);
        }
        
//        problem.SetParameterBlockConstant(quaterniond_array_main[i_main]);
        
        if(need_resample_main[i_main])
        {
            i_main++;
            continue;
        }
        
        
        int j = 1, sequence_link_cnt = 0;
        while(sequence_link_cnt < 5)
        {
            if (i_main - j >= 0)
            {
//                        list<KeyFrame*>::iterator tmp = it_main;
//                        std::advance (tmp, -j);
                if(need_resample_main[i_main-j])
                {
                    j++;
                    continue;
                }
                else
                {
                    sequence_link_cnt++;
                }
                Vector3d euler_conncected = Utility::R2ypr(q_array_main[i_main-j].toRotationMatrix());
                //p̂_j^w - p̂_i^w 计算平移量的偏差
                Vector3d relative_t(t_array_main[i_main][0] - t_array_main[i_main-j][0], t_array_main[i_main][1] - t_array_main[i_main-j][1], t_array_main[i_main][2] - t_array_main[i_main-j][2]);
                //p̂_{ij}^{i} = {R̂_i^w}^{-1} (p̂_j^w - p̂_i^w)
                //p̂ ij= (R̂ iw ) (p̂ jw − p̂ iw )
                relative_t = q_array_main[i_main-j].inverse() * relative_t;
                //ψ̂ _ij = ψ̂ _j − ψ̂ _i
                double relative_yaw = euler_array_main[i_main][0] - euler_array_main[i_main-j][0];
//                cout<<"主地图序列帧relative_t："<<relative_t[0]<<" , "<<relative_t[1]<<" , "<<relative_t[2]<<endl;
//                cout<<"主地图序列帧euler_conncected："<<euler_conncected[0]<<" , "<<euler_conncected[1]<<" , "<<euler_conncected[2]<<endl;
//                cout<<"主地图序列帧relative_yaw："<<relative_yaw<<endl;
//                ceres::CostFunction* cost_function = FourDOFError_another::Create( relative_t.x(), relative_t.y(), relative_t.z(), relative_yaw, euler_conncected.y(), euler_conncected.z());
//                problem.AddResidualBlock(cost_function, loss_function, euler_array_main[i_main-j], t_array_main[i_main-j], euler_array_main[i_main], t_array_main[i_main]);
                
                Quaterniond relative_q=q_array_main[i_main-j].inverse()*q_array_main[i_main];
//                cout<<"relative_q 12658 seq_kf="<<relative_q.w()<<" , "<<relative_q.x()<<" , "<<relative_q.y()<<" , "<<relative_q.z()<<endl;
                
                double w_q_i[4],i_q_w[4],w_q_j[4],q_i_j[4];
                w_q_i[0]=q_array_main[i_main-j].w();
                w_q_i[1]=q_array_main[i_main-j].x();
                w_q_i[2]=q_array_main[i_main-j].y();
                w_q_i[3]=q_array_main[i_main-j].z();
                QuaternionInverse(w_q_i, i_q_w);
                w_q_j[0]=q_array_main[i_main].w();
                w_q_j[1]=q_array_main[i_main].x();
                w_q_j[2]=q_array_main[i_main].y();
                w_q_j[3]=q_array_main[i_main].z();
                ceres::QuaternionProduct(i_q_w, w_q_j, q_i_j);
//                    cout<<"relative_q 12862 q_i_j="<<q_i_j[0]<<" , "<<q_i_j[1]<<" , "<<q_i_j[2]<<" , "<<q_i_j[3]<<endl;
//
//                    cout<<"relative_q 12862 seq_kf="<<relative_q.w()<<" , "<<relative_q.x()<<" , "<<relative_q.y()<<" , "<<relative_q.z()<<endl;
                double relative_q_double[4],relative_q_inv[4],error_q[4];
                relative_q_double[0]=relative_q.w();
                relative_q_double[1]=relative_q.x();
                relative_q_double[2]=relative_q.y();
                relative_q_double[3]=relative_q.z();
                QuaternionInverse(relative_q_double, relative_q_inv);
                ceres::QuaternionProduct(relative_q_inv, q_i_j, error_q);
               
                
                if(error_q[1]>0.000001 || error_q[1]<-0.000001){
                    cout<<"relative_q 12721 error_q="<<error_q[0]<<" , "<<error_q[1]<<" , "<<error_q[2]<<" , "<<error_q[3]<<endl;
                    cout<<"数据不规范序列帧"<<endl;
                }
                
                
                ceres::CostFunction* cost_function = RelativeRTError::Create(relative_t.x(), relative_t.y(), relative_t.z(),relative_q.w(), relative_q.x(), relative_q.y(), relative_q.z(),1.0,1.0);
                problem.AddResidualBlock(cost_function, loss_function, quaterniond_array_main[i_main-j],
                                         t_array_main[i_main-j],
                                         quaterniond_array_main[i_main],
                                         t_array_main[i_main]);
            }
            else
            {
                break;
            }
            j++;
        }

        //        添加的是闭环边，是指检测到闭环的两帧
        if((*it_main)->is_get_loop_info   )
        {
            if((*it_main)->loop_index >= earliest_loop_index_main)
            {
                int connected_index = pMainMap->getKeyframe((*it_main)->loop_index)->resample_globalIndex;

                Vector3d euler_conncected = Utility::R2ypr(q_array_main[connected_index].toRotationMatrix());
                Vector3d relative_t((*it_main)->loop_info_better(0), (*it_main)->loop_info_better(1), (*it_main)->loop_info_better(2));
                double relative_yaw = (*it_main)->loop_info_better(3);
//                cout<<"主地图回环relative_t："<<relative_t[0]<<" , "<<relative_t[1]<<" , "<<relative_t[2]<<endl;
//                cout<<"主地图回环euler_conncected："<<euler_conncected[0]<<" , "<<euler_conncected[1]<<" , "<<euler_conncected[2]<<endl;
//                cout<<"主地图回环relative_yaw："<<relative_yaw<<endl;
                
//                ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),
//                                                                                relative_yaw, euler_conncected.y(), euler_conncected.z());
//                problem.AddResidualBlock(cost_function, NULL, euler_array_main[connected_index], t_array_main[connected_index],  euler_array_main[i_main],  t_array_main[i_main]);
                
                Quaterniond relative_q=(*it_main)->loop_info_better_q;
//                cout<<"relative_q 12691 loop_kf="<<relative_q.w()<<" , "<<relative_q.x()<<" , "<<relative_q.y()<<" , "<<relative_q.z()<<endl;
                ceres::CostFunction* cost_function = RelativeRTError::Create(relative_t.x(), relative_t.y(), relative_t.z(),relative_q.w(), relative_q.x(), relative_q.y(), relative_q.z(),10.0,1.0);
                problem.AddResidualBlock(cost_function, NULL, quaterniond_array_main[connected_index],
                                         t_array_main[connected_index],
                                         quaterniond_array_main[i_main],
                                         t_array_main[i_main]);
            }else{
                cout<<"主地图回环id:"<<(*it_main)->global_index<<" , "<<(*it_main)->loop_index<<" , "<<earliest_loop_index_main<<endl;
                cout<<(*it_main)->has_global_loop<<endl;
//                猜测应该是这个帧 后面有发生了自身的回环，前面只是检测到 和其它地图的回环
//                并没有检测到和其它地图的回环 猜测是自身回环还没更新最早的id 或者更新错误之类的
                assert(false);//报错36 37, 6 8 20220530, 23 24
            }
        }

        
        if((*it_main)->has_global_loop)
       {
           //这里后面还要添加else
           if((*it_main)->global_loop_index < 0)
           {
               //因为这意味着数据保存出错了 发生了融合的帧的id小于最早发生融合的id
               assert(false);
               return;
           }
//           获取是和哪个其它地图发生了回环
           (*it_main)->readWriteLock_loop.readLock();
           int loop_index_flag_end=(*it_main)->clientId.size();
           (*it_main)->readWriteLock_loop.readUnLock();
//           遍历该帧的 所有回环帧
           for(int loop_index_flag=0;loop_index_flag<loop_index_flag_end;loop_index_flag++){
               (*it_main)->readWriteLock_loop.readLock();
               int matching_clientId=(*it_main)->clientId[loop_index_flag];
               int matching_kfId=(*it_main)->kfId[loop_index_flag];
               std::pair<Matrix3d , Vector3d > matching_rt=(*it_main)->relativePose[loop_index_flag];
               (*it_main)->readWriteLock_loop.readUnLock();
               
//               找到这个对应的其它地图
               int vmap_index=vMapId_all[matching_clientId];
               PoseGraph * pMap_other=vMap_all[vmap_index];
               //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束 会出现空指针的问题
               int connected_index = pMap_other->getKeyframe(matching_kfId)->resample_globalIndex;//这里可能多个
               
               if(matching_kfId < earliest_loopIndex_other_all[vmap_index])
               {
                   //因为这意味着数据保存出错了 发生了融合的帧的id小于最早发生融合的id
                   assert(false);
                   return;
               }
               
               Vector3d euler_conncected = Utility::R2ypr(q_other_all[vmap_index][connected_index].toRotationMatrix());
               Vector3d relative_t((*it_main)->relative_global_loop_info_multiClient[loop_index_flag](0), (*it_main)->relative_global_loop_info_multiClient[loop_index_flag](1), (*it_main)->relative_global_loop_info_multiClient[loop_index_flag](2));
               double relative_yaw = (*it_main)->relative_global_loop_info_multiClient[loop_index_flag](7);
               
               //这里到时候 再写一个求导的
//               ceres::CostFunction* cost_function1 = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z());
//               problem.AddResidualBlock(cost_function1, NULL, euler_other_all[vmap_index][connected_index] ,
//                                       t_other_all[vmap_index][connected_index] ,
//                                        euler_array_main[i_main],
//                                        t_array_main[i_main]);
               
               double  qw=(*it_main)->relative_global_loop_info_multiClient[loop_index_flag](3),qx=(*it_main)->relative_global_loop_info_multiClient[loop_index_flag](4),qy=(*it_main)->relative_global_loop_info_multiClient[loop_index_flag](5),qz=(*it_main)->relative_global_loop_info_multiClient[loop_index_flag](6);
               Quaterniond relative_q(qw, qx, qy, qz);
//               cout<<"relative_q 12751 globalloop_kf="<<relative_q.w()<<" , "<<relative_q.x()<<" , "<<relative_q.y()<<" , "<<relative_q.z()<<endl;
               ceres::CostFunction* cost_function1 = RelativeRTError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_q.w(), relative_q.x(), relative_q.y(), relative_q.z(),10.0,1.0);
               problem.AddResidualBlock(cost_function1, NULL, quaterniond_other_all[vmap_index][connected_index] ,
                                       t_other_all[vmap_index][connected_index] ,
                                        quaterniond_array_main[i_main],
                                        t_array_main[i_main]);
               
//               MultiClientFactor_merge *f = new MultiClientFactor_merge(relative_t, euler_conncected.y(), euler_conncected.z());
//               problem.AddResidualBlock(f, NULL, euler_other_all[vmap_index][connected_index] ,
//                                        t_other_all[vmap_index][connected_index] , t_array_main[i_main] ,t_global_all[vmap_index][connected_index],r_global_all[vmap_index][connected_index],t_global_main_relative,r_global_main_relative);
//
//               Vector3d euler_conncected_j = Utility::R2ypr(q_array_main[i_main].toRotationMatrix());
//               ceres::CostFunction* cost_function = EightDOFWeightError_yaw::Create( relative_yaw, euler_conncected.y(), euler_conncected.z(),euler_conncected_j.y(),euler_conncected_j.z());
//             problem.AddResidualBlock(cost_function, NULL, euler_other_all[vmap_index][connected_index] ,euler_array_main[i_main] , r_global_all[vmap_index][connected_index] ,r_global_main_relative);
               
//               同上暂时注释的
//               MultiClientFactor_merge *f = new MultiClientFactor_merge(relative_t, euler_conncected.y(), euler_conncected.z());
//               problem.AddResidualBlock(f, NULL, euler_other_all[vmap_index][connected_index] ,
//                                        t_other_all[vmap_index][connected_index] , t_array_main[i_main] ,t_global_all[vmap_index],r_global_all[vmap_index],t_global_main_relative,r_global_main_relative);
//
//               Vector3d euler_conncected_j = Utility::R2ypr(q_array_main[i_main].toRotationMatrix());
//               ceres::CostFunction* cost_function = EightDOFWeightError_yaw::Create( relative_yaw, euler_conncected.y(), euler_conncected.z(),euler_conncected_j.y(),euler_conncected_j.z());
//             problem.AddResidualBlock(cost_function, NULL, euler_other_all[vmap_index][connected_index] ,euler_array_main[i_main] , r_global_all[vmap_index] ,r_global_main_relative);
           }
          
           
           
       }
        
        
        if ((*it_main)->global_index == latest_loop_index_main)
            break;
        i_main++;
    }
    
    int i_other = 0;
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
//        problem.AddParameterBlock(&pitch_other_all[flag_start], 1);
//        problem.AddParameterBlock(&roll_other_all[flag_start], 1);
        i_other = 0;
//        同上暂时注释的
//        problem.AddParameterBlock(r_global_all[flag_start], 4, local_parameterization);
////        problem.SetParameterBlockConstant(r_global_all[flag_start]);
//        problem.AddParameterBlock(t_global_all[flag_start], 3);
////        problem.SetParameterBlockConstant(t_global_all[flag_start]);
        for (auto it_other = pMap_other->keyFrameList.begin(); it_other != pMap_other->keyFrameList.end(); it_other++)
        {
            //将关键帧列表中所有index>=earliest_loop_index的关键帧的位姿加入到参数块当中
            problem.AddParameterBlock(quaterniond_other_all[flag_start][i_other], 4, local_parameterization);
//            problem.AddParameterBlock(euler_other_all[flag_start][i_other], 1, angle_local_parameterization);
            problem.AddParameterBlock(t_other_all[flag_start][i_other], 3);
            
//            problem.SetParameterBlockConstant(quaterniond_other_all[flag_start][i_other]);

//            ceres::LocalParameterization *local_parameterization = new PoseQ_LocalParameterization();
//            problem.AddParameterBlock(r_global_all[flag_start][i_other], 4, local_parameterization);
//            problem.AddParameterBlock(t_global_all[flag_start][i_other], 3);
            
            if(resample_other_all[flag_start][i_other])
            {
               
                i_other++;
                continue;
            }
            
//            if(i_other>0){
//
//                ceres::CostFunction* cost_function = SixDOFWeightError_relativeR::Create( );
//                problem.AddResidualBlock(cost_function, NULL, r_global_all[flag_start][i_other-1],
//                                       r_global_all[flag_start][i_other]);
//
//
//                ceres::CostFunction* cost_function_t = SixDOFWeightError_relativet::Create( );
//                problem.AddResidualBlock(cost_function_t, NULL, t_global_all[flag_start][i_other-1],
//                                       t_global_all[flag_start][i_other]);
//            }


            int j = 1, sequence_link_cnt = 0;
            while(sequence_link_cnt < 5)
            {
                if (i_other - j >= 0)
                {

                    if(resample_other_all[flag_start][i_other-j])
                    {
                        j++;
                        continue;
                    }
                    else
                    {
                        sequence_link_cnt++;
                    }
                    Vector3d euler_conncected = Utility::R2ypr(q_other_all[flag_start][i_other-j].toRotationMatrix());
                    //p̂_j^w - p̂_i^w 计算平移量的偏差
                    Vector3d relative_t(t_other_all[flag_start][i_other][0] - t_other_all[flag_start][i_other-j][0], t_other_all[flag_start][i_other][1] - t_other_all[flag_start][i_other-j][1], t_other_all[flag_start][i_other][2] - t_other_all[flag_start][i_other-j][2]);
                    //p̂_{ij}^{i} = {R̂_i^w}^{-1} (p̂_j^w - p̂_i^w)
                    //p̂ ij= (R̂ iw ) (p̂ jw − p̂ iw )
                    relative_t = q_other_all[flag_start][i_other-j].inverse() * relative_t;
                    //ψ̂ _ij = ψ̂ _j − ψ̂ _i
                    double relative_yaw = euler_other_all[flag_start][i_other][0] - euler_other_all[flag_start][i_other-j][0];
//                    cout<<"其它地图序列帧relative_t："<<relative_t[0]<<" , "<<relative_t[1]<<" , "<<relative_t[2]<<endl;
//                    cout<<"其它地图序列帧euler_conncected："<<euler_conncected[0]<<" , "<<euler_conncected[1]<<" , "<<euler_conncected[2]<<endl;
//                    cout<<"其它地图序列帧relative_yaw："<<relative_yaw<<endl;
//                    ceres::CostFunction* cost_function = FourDOFError_another::Create( relative_t.x(), relative_t.y(), relative_t.z(),
//                                                                              relative_yaw, euler_conncected.y(), euler_conncected.z());
//                    problem.AddResidualBlock(cost_function, loss_function, euler_other_all[flag_start][i_other-j],
//                                             t_other_all[flag_start][i_other-j],
//                                             euler_other_all[flag_start][i_other],
//                                             t_other_all[flag_start][i_other]);
                    
                    Quaterniond relative_q=q_other_all[flag_start][i_other-j].inverse()*q_other_all[flag_start][i_other];
                    
                    double w_q_i[4],i_q_w[4],w_q_j[4],q_i_j[4];
                    w_q_i[0]=q_other_all[flag_start][i_other-j].w();
                    w_q_i[1]=q_other_all[flag_start][i_other-j].x();
                    w_q_i[2]=q_other_all[flag_start][i_other-j].y();
                    w_q_i[3]=q_other_all[flag_start][i_other-j].z();
                    QuaternionInverse(w_q_i, i_q_w);
                    w_q_j[0]=q_other_all[flag_start][i_other].w();
                    w_q_j[1]=q_other_all[flag_start][i_other].x();
                    w_q_j[2]=q_other_all[flag_start][i_other].y();
                    w_q_j[3]=q_other_all[flag_start][i_other].z();
                    ceres::QuaternionProduct(i_q_w, w_q_j, q_i_j);
//                    cout<<"relative_q 12862 q_i_j="<<q_i_j[0]<<" , "<<q_i_j[1]<<" , "<<q_i_j[2]<<" , "<<q_i_j[3]<<endl;
//
//                    cout<<"relative_q 12862 seq_kf="<<relative_q.w()<<" , "<<relative_q.x()<<" , "<<relative_q.y()<<" , "<<relative_q.z()<<endl;
                    double relative_q_double[4],relative_q_inv[4],error_q[4];
                    relative_q_double[0]=relative_q.w();
                    relative_q_double[1]=relative_q.x();
                    relative_q_double[2]=relative_q.y();
                    relative_q_double[3]=relative_q.z();
                    QuaternionInverse(relative_q_double, relative_q_inv);
                    ceres::QuaternionProduct(relative_q_inv, q_i_j, error_q);
                   
                    
                    if(fabs(error_q[1])>0.000001 || fabs(error_q[2])>0.000001 || fabs(error_q[3])>0.000001){
                        cout<<"relative_q 12862 error_q="<<error_q[0]<<" , "<<error_q[1]<<" , "<<error_q[2]<<" , "<<error_q[3]<<endl;
                        cout<<"数据不规范序列帧"<<endl;
                    }
                    
                    ceres::CostFunction* cost_function = RelativeRTError::Create(relative_t.x(), relative_t.y(), relative_t.z(),relative_q.w(), relative_q.x(), relative_q.y(), relative_q.z(),1.0,1.0);
                    problem.AddResidualBlock(cost_function, loss_function, quaterniond_other_all[flag_start][i_other-j], t_other_all[flag_start][i_other-j], quaterniond_other_all[flag_start][i_other],  t_other_all[flag_start][i_other]);
                }
                else
                {
                    break;
                }
                j++;
            }
          
            //        添加的是闭环边，是指检测到闭环的两帧 一个数据拆成两份 这个注释掉了
            if((*it_other)->is_get_loop_info)
            {
                //这里后面还要添加else
                if((*it_other)->loop_index <0)
                {
                    assert(false);
                }
                //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束
                int connected_index = pMap_other->getKeyframe((*it_other)->loop_index)->resample_globalIndex;

                Vector3d euler_conncected = Utility::R2ypr(q_other_all[flag_start][connected_index].toRotationMatrix());
                Vector3d relative_t((*it_other)->loop_info_better(0), (*it_other)->loop_info_better(1), (*it_other)->loop_info_better(2));
                double relative_yaw = (*it_other)->loop_info_better(3);
                
//                ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z());
//                problem.AddResidualBlock(cost_function, NULL, euler_other_all[flag_start][connected_index],
//                                         t_other_all[flag_start][connected_index],
//                                         euler_other_all[flag_start][i_other],
//                                         t_other_all[flag_start][i_other]);
                
                Quaterniond relative_q=(*it_other)->loop_info_better_q;
//                cout<<"relative_q 12895 loop_kf="<<relative_q.w()<<" , "<<relative_q.x()<<" , "<<relative_q.y()<<" , "<<relative_q.z()<<endl;
                ceres::CostFunction* cost_function = RelativeRTError::Create(relative_t.x(), relative_t.y(), relative_t.z(),relative_q.w(), relative_q.x(), relative_q.y(), relative_q.z(),10.0,1.0);
                problem.AddResidualBlock(cost_function, NULL, quaterniond_other_all[flag_start][connected_index],
                                         t_other_all[flag_start][connected_index],
                                         quaterniond_other_all[flag_start][i_other],
                                         t_other_all[flag_start][i_other]);
                
            }
           
            if((*it_other)->has_global_loop)
           {
    //           获取是和哪个其它地图发生了回环
              (*it_other)->readWriteLock_loop.readLock();
              int loop_index_flag_end=(*it_other)->clientId.size();
              (*it_other)->readWriteLock_loop.readUnLock();
    //           遍历该帧的 所有回环帧
              for(int loop_index_flag=0;loop_index_flag<loop_index_flag_end;loop_index_flag++){
                  (*it_other)->readWriteLock_loop.readLock();
                  int matching_clientId=(*it_other)->clientId[loop_index_flag];
                  int matching_kfId=(*it_other)->kfId[loop_index_flag];
                  std::pair<Matrix3d , Vector3d > matching_rt=(*it_other)->relativePose[loop_index_flag];
                  (*it_other)->readWriteLock_loop.readUnLock();
                  
//                  Vector3d euler_conncected = Utility::R2ypr(matching_rt.first);
//                  Vector3d relative_t=matching_rt.second;
//                  double relative_yaw = euler_conncected[0];
                  
                  if(matching_clientId==pMainMap->c->id){
                      if(matching_kfId < earliest_loop_index_main)
                      {
                          //因为这意味着数据保存出错了 发生了融合的帧的id小于最早发生融合的id
                          assert(false);
                          return;
                      }
                      //说明是和此次新增地图 发生匹配
                      //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束
                      int connected_index = pMainMap->getKeyframe(matching_kfId)->resample_globalIndex;
                      
//                      double relative_yaw =euler_conncected[0]-euler_array_main[connected_index][0];
                      
                      Vector3d euler_conncected = Utility::R2ypr(q_array_main[connected_index].toRotationMatrix());
                      Vector3d relative_t((*it_other)->relative_global_loop_info_multiClient[loop_index_flag](0), (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](1), (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](2));
                      double relative_yaw = (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](7);

                      //这里到时候 再写一个求导的
//                      ceres::CostFunction* cost_function1 = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z());
//                      problem.AddResidualBlock(cost_function1, NULL, euler_array_main[connected_index],
//                                               t_array_main[connected_index],
//                                               euler_other_all[flag_start][i_other],
//                                               t_other_all[flag_start][i_other]);
                      
//                      cout<<"relative_q="<<(*it_other)->relative_global_loop_info_multiClient[loop_index_flag](3)<<" , "<<(*it_other)->relative_global_loop_info_multiClient[loop_index_flag](4)<<" , "<<(*it_other)->relative_global_loop_info_multiClient[loop_index_flag](5)<<" , "<<(*it_other)->relative_global_loop_info_multiClient[loop_index_flag](6)<<endl;
//                      Eigen::Matrix<double, 8, 1 > relative_loop=(*it_other)->relative_global_loop_info_multiClient[loop_index_flag];
//                      cout<<"relative_loop="<<relative_loop<<endl;
                      double qw=(*it_other)->relative_global_loop_info_multiClient[loop_index_flag](3),qx=(*it_other)->relative_global_loop_info_multiClient[loop_index_flag](4),qy=(*it_other)->relative_global_loop_info_multiClient[loop_index_flag](5),qz=(*it_other)->relative_global_loop_info_multiClient[loop_index_flag](6);
                      Quaterniond relative_q(qw,qx ,qy ,qz );
//                      cout<<"relative_q 12951 globalloop_kf="<<relative_q.w()<<" , "<<relative_q.x()<<" , "<<relative_q.y()<<" , "<<relative_q.z()<<endl;
                      ceres::CostFunction* cost_function1 = RelativeRTError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_q.w(), relative_q.x(), relative_q.y(), relative_q.z(),10.0,1.0);
                      problem.AddResidualBlock(cost_function1, NULL, quaterniond_array_main[connected_index], t_array_main[connected_index], quaterniond_other_all[flag_start][i_other], t_other_all[flag_start][i_other]);
                      
//                      测试相对位姿对不对
//                      Quaterniond r_w2d_i(quaterniond_array_main[connected_index][0],quaterniond_array_main[connected_index][1],quaterniond_array_main[connected_index][2],quaterniond_array_main[connected_index][3]);
//                      Vector3d t_w2d_i(t_array_main[connected_index][0],t_array_main[connected_index][1],t_array_main[connected_index][2]);
//                      Matrix3d r_w2d_j=r_w2d_i*relative_q.toRotationMatrix();
//                      Vector3d t_w2d_j=r_w2d_i*relative_t+t_w2d_i;
//                      Vector3d r_ypr=Utility::R2ypr(r_w2d_j);
//                      cout<<"hope="<<t_w2d_j<<" , "<< r_w2d_j<<endl;
//                      cout<<"r_ypr="<<r_ypr<<endl;
//                      Quaterniond q_hope;
//                      q_hope=r_w2d_j;
//                      cout<<"q_hope="<<q_hope.w()<<" , "<<q_hope.x()<<" , "<<q_hope.y()<<" , "<<q_hope.z()<<endl;
//                      cout<<"real="<<t_other_all[flag_start][i_other][0]<<" , "<<t_other_all[flag_start][i_other][1]<<" , "<<t_other_all[flag_start][i_other][2]<<" , "<< quaterniond_other_all[flag_start][i_other][0]<<" ,"<<quaterniond_other_all[flag_start][i_other][1]<<" ,"<<quaterniond_other_all[flag_start][i_other][2]<<" ,"<<quaterniond_other_all[flag_start][i_other][3]<<endl;
//
//                      cout<<"r_ypr="<<euler_other_all[flag_start][i_other][0]<<" ," <<euler_other_all[flag_start][i_other][1]<<" ," <<euler_other_all[flag_start][i_other][2]<<endl;

                      
//                      MultiClientFactor_merge *f = new MultiClientFactor_merge(relative_t, euler_conncected.y(), euler_conncected.z());
//                      problem.AddResidualBlock(f, NULL, euler_array_main[connected_index],
//                                               t_array_main[connected_index],t_other_all[flag_start][i_other] ,t_global_main_relative,r_global_main_relative ,t_global_all[flag_start][i_other] ,r_global_all[flag_start][i_other]);
//
//                      Vector3d euler_conncected_j = Utility::R2ypr(q_other_all[flag_start][i_other].toRotationMatrix());
//                      ceres::CostFunction* cost_function = EightDOFWeightError_yaw::Create( relative_yaw, euler_conncected.y(), euler_conncected.z(),euler_conncected_j.y(),euler_conncected_j.z());
//                    problem.AddResidualBlock(cost_function, NULL, euler_array_main[connected_index],euler_other_all[flag_start][i_other],r_global_main_relative ,r_global_all[flag_start][i_other]);
                      
//                      同上暂时注释的
//                      MultiClientFactor_merge *f = new MultiClientFactor_merge(relative_t, euler_conncected.y(), euler_conncected.z());
//                      problem.AddResidualBlock(f, NULL, euler_array_main[connected_index],
//                                               t_array_main[connected_index],t_other_all[flag_start][i_other] ,t_global_main_relative,r_global_main_relative ,t_global_all[flag_start] ,r_global_all[flag_start]);
//
//                      Vector3d euler_conncected_j = Utility::R2ypr(q_other_all[flag_start][i_other].toRotationMatrix());
//                      ceres::CostFunction* cost_function = EightDOFWeightError_yaw::Create( relative_yaw, euler_conncected.y(), euler_conncected.z(),euler_conncected_j.y(),euler_conncected_j.z());
//                    problem.AddResidualBlock(cost_function, NULL, euler_array_main[connected_index],euler_other_all[flag_start][i_other],r_global_main_relative ,r_global_all[flag_start]);
                      
                  }else{
                      int vmap_index=vMapId_all[matching_clientId];
                      if(matching_kfId < earliest_loopIndex_other_all[vmap_index])
                      {
                          //因为这意味着数据保存出错了 发生了融合的帧的id小于最早发生融合的id
                          assert(false);
                          return;
                      }
                      
        //               找到这个对应的其它地图
                      PoseGraph * pMap_fuse=vMap_all[vmap_index];
                      //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束 会出现空指针的问题
                      int connected_index = pMap_fuse->getKeyframe(matching_kfId)->resample_globalIndex;//这里可能多个
                        
    //                  double relative_yaw =euler_conncected[0]-euler_other_all[vmap_index][connected_index][0];
                      
                      Vector3d euler_conncected = Utility::R2ypr(q_other_all[vmap_index][connected_index].toRotationMatrix());
                      Vector3d relative_t((*it_other)->relative_global_loop_info_multiClient[loop_index_flag](0), (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](1), (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](2));
                      double relative_yaw = (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](7);

                       //这里到时候 再写一个求导的
//                       ceres::CostFunction* cost_function1 = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z());
//                       problem.AddResidualBlock(cost_function1, NULL, euler_other_all[vmap_index][connected_index],
//                                            t_other_all[vmap_index][connected_index],
//                                            euler_other_all[flag_start][i_other],
//                                            t_other_all[flag_start][i_other]);
                      double qw=(*it_other)->relative_global_loop_info_multiClient[loop_index_flag](3),qx=(*it_other)->relative_global_loop_info_multiClient[loop_index_flag](4),qy=(*it_other)->relative_global_loop_info_multiClient[loop_index_flag](5),qz=(*it_other)->relative_global_loop_info_multiClient[loop_index_flag](6);
                      Quaterniond relative_q(qw,qx , qy, qz);
//                      cout<<"relative_q 13000 globalloop_kf="<<relative_q.w()<<" , "<<relative_q.x()<<" , "<<relative_q.y()<<" , "<<relative_q.z()<<endl;
                      ceres::CostFunction* cost_function1 = RelativeRTError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_q.w(), relative_q.x(), relative_q.y(), relative_q.z(),10.0,1.0);
                      problem.AddResidualBlock(cost_function1, NULL, quaterniond_other_all[vmap_index][connected_index],  t_other_all[vmap_index][connected_index],  quaterniond_other_all[flag_start][i_other], t_other_all[flag_start][i_other]);
                      
                      
//                      MultiClientFactor_merge *f = new MultiClientFactor_merge(relative_t, euler_conncected.y(), euler_conncected.z());
//                      problem.AddResidualBlock(f, NULL, euler_other_all[vmap_index][connected_index],
//                                                 t_other_all[vmap_index][connected_index] ,t_other_all[flag_start][i_other],t_global_all[vmap_index][connected_index],r_global_all[vmap_index][connected_index] ,t_global_all[flag_start][i_other],r_global_all[flag_start][i_other]);
//
//                      Vector3d euler_conncected_j = Utility::R2ypr(q_other_all[flag_start][i_other].toRotationMatrix());
//                      ceres::CostFunction* cost_function = EightDOFWeightError_yaw::Create( relative_yaw, euler_conncected.y(), euler_conncected.z(),euler_conncected_j.y(),euler_conncected_j.z());
//                    problem.AddResidualBlock(cost_function, NULL, euler_other_all[vmap_index][connected_index] ,euler_other_all[flag_start][i_other] , r_global_all[vmap_index][connected_index] ,r_global_all[flag_start][i_other]);
                      
//                      同上暂时注释的
//                      MultiClientFactor_merge *f = new MultiClientFactor_merge(relative_t, euler_conncected.y(), euler_conncected.z());
//                      problem.AddResidualBlock(f, NULL, euler_other_all[vmap_index][connected_index],
//                                                 t_other_all[vmap_index][connected_index] ,t_other_all[flag_start][i_other],t_global_all[vmap_index] ,r_global_all[vmap_index] ,t_global_all[flag_start] ,r_global_all[flag_start] );
//
//                      Vector3d euler_conncected_j = Utility::R2ypr(q_other_all[flag_start][i_other].toRotationMatrix());
//                      ceres::CostFunction* cost_function = EightDOFWeightError_yaw::Create( relative_yaw, euler_conncected.y(), euler_conncected.z(),euler_conncected_j.y(),euler_conncected_j.z());
//                    problem.AddResidualBlock(cost_function, NULL, euler_other_all[vmap_index][connected_index] ,euler_other_all[flag_start][i_other] , r_global_all[vmap_index]  ,r_global_all[flag_start] );
                  }
                  
                  
              }
           }
            if ((*it_other)->global_index == latest_loopIndex_other_all[flag_start])
                break;
            i_other++;
          
        }

    }
    
    ceres::Solve(options, &problem, &summary);
    
    std::cout << "global fuse: "<<summary.BriefReport() << "\n";
    if(summary.termination_type!=ceres::CONVERGENCE){
        
        return;
    }
    
    pMainMap->special_kf_mutex.lock();
    pMainMap->add2_kf_id_hasComPlace_withOtherMap(kf_id_hasComPlace_main);
    pMainMap->special_kf_inOpti.push(special_kf_inOpti_main);
    pMainMap->special_kf_mutex.unlock();
    pMainMap->loop_index_multiClient.push(earliest_loop_index_main);
    pMainMap->curKF_loop_index_multiClient.push(latest_loop_index_main);//这个是要发回客户端 用来更新位姿的 TODO 后面要改改
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
        vector<int> special_kf_inOpti_cur=special_kf_inOpti_cur_all[flag_start];
        vector<int> kf_id_hasCom_cur=kf_id_hasCom_cur_all[flag_start];
        pMap_other->special_kf_mutex.lock();
        pMap_other->add2_kf_id_hasComPlace_withOtherMap(kf_id_hasCom_cur);
        pMap_other->special_kf_inOpti.push(special_kf_inOpti_cur);
        pMap_other->special_kf_mutex.unlock();
        
        int latest_loop_index=latest_loop_index_other_correct[flag_start];
        pMap_other->isFirstFusion_globalMutex.lock();
        pMap_other->loop_index_multiClient.push(0);
        pMap_other->curKF_loop_index_multiClient.push(latest_loop_index);
        pMap_other->isFirstFusion_globalMutex.unlock();
    }
    //------------------------------------------第一个数据优化后更新
    //优化完成，使用优化后的位姿来更新关键帧列表中index大于等于earliest_loop_index的所有关键帧的位姿
    
    Vector3d t_drift_it_other = Vector3d::Zero();
    Matrix3d r_drift_it_other = Matrix3d::Identity();
    
    vector<Matrix3d> r_global_cur;
    vector<Vector3d> t_global_cur;
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
        list<KeyFrame*>::iterator it_other = pMap_other->keyFrameList.begin();
        i_other = 0;
        r_global_cur.clear();
        t_global_cur.clear();
        for (; it_other != pMap_other->keyFrameList.end(); it_other++)
        {
            
//            Quaterniond tmp_q;
//            //向量转换为矩阵
//            tmp_q = Utility::ypr2R(Vector3d(euler_other_all[flag_start][i_other][0], euler_other_all[flag_start][i_other][1], euler_other_all[flag_start][i_other][2]));
            Quaterniond tmp_q(quaterniond_other_all[flag_start][i_other][0],quaterniond_other_all[flag_start][i_other][1],quaterniond_other_all[flag_start][i_other][2],quaterniond_other_all[flag_start][i_other][3]);
            Vector3d tmp_w1_t = Vector3d(t_other_all[flag_start][i_other][0], t_other_all[flag_start][i_other][1], t_other_all[flag_start][i_other][2]);
            Matrix3d tmp_w1_r = tmp_q.toRotationMatrix();
            
         
           
            if(resample_other_all[flag_start][i_other])
            {
//有先验的位姿更新
                Vector3d origin_t_it;
                Matrix3d origin_r_it;
                (*it_other)->getOriginPose(origin_t_it, origin_r_it);
                (*it_other)-> updatePose(r_drift_it_other * origin_t_it + t_drift_it_other, r_drift_it_other * origin_r_it);
                
//                无先验的位姿更新
//                (*it_other)-> updatePose(r_drift_it_other * tmp_w1_t + t_drift_it_other, r_drift_it_other * tmp_w1_r);
            }
            else
            {
                Vector3d origin_t_it;
                Matrix3d origin_r_it;
                (*it_other)->getOriginPose(origin_t_it, origin_r_it);
                
                
                r_drift_it_other = tmp_w1_r * origin_r_it.transpose();
                t_drift_it_other = tmp_w1_t - r_drift_it_other * origin_t_it;
                (*it_other)->updatePose(tmp_w1_t, tmp_w1_r);
                
    //            pCurMap->add2_r_global_multiClient(tmp_w1_r);
    //            pCurMap->add2_t_global_multiClient(tmp_w1_t);
                r_global_cur.push_back(tmp_w1_r);
                t_global_cur.push_back(tmp_w1_t);
            }
            if ((*it_other)->global_index == latest_loopIndex_other_all[flag_start])
                break;
            i_other++;
            
        }
        //如果将地图建模成可变形的呢
        //根据计算出当前帧的drift，更新全部关键帧位姿
        Vector3d cur_t_other, origin_t_other;
        Matrix3d cur_r_other, origin_r_other;
        //获取优化后当前帧的位姿cur_t,cur_r
        (*it_other)->getPose(cur_t_other, cur_r_other);
        //获取优化前有漂移的当前帧的位姿vio_t,vio_r
        (*it_other)->getOriginPose(origin_t_other, origin_r_other);
        pMap_other->yaw_drift = Utility::R2ypr(cur_r_other).x() - Utility::R2ypr(origin_r_other).x();
//        pMap_other->r_drift = Utility::ypr2R(Vector3d(pMap_other->yaw_drift, 0, 0));
        pMap_other->r_drift = cur_r_other*origin_r_other.transpose();
        pMap_other->t_drift = cur_t_other - pMap_other->r_drift * origin_t_other;
        
    //    pCurMap->add2_r_global_multiClient(pCurMap->r_drift);
    //    pCurMap->add2_t_global_multiClient(pCurMap->t_drift);
        r_global_cur.push_back(pMap_other->r_drift);
        t_global_cur.push_back(pMap_other->t_drift);
        pMap_other->add2_r_global_multiClient(r_global_cur);
        pMap_other->add2_t_global_multiClient(t_global_cur);
        if((r_global_cur.size()-1)!=pMap_other->special_kf_inOpti.back().size() && (r_global_cur.size()-1)!=(t_global_cur.size()-1)){
            cout<<"当前地图id"<<pMap_other->c->id<<" , "<<latest_loopIndex_other_all[flag_start]<<endl;
            cout<<"resample下标数量不一致："<<r_global_cur.size()<<" , "<<pMap_other->special_kf_inOpti.back().size()<<" , "<<t_global_cur.size()<<endl;
//            while (pMap_other->special_kf_inOpti.size()!=2)
//            {
//                cout << pMap_other->special_kf_inOpti.front().size()<< " "; // Output the 1st element
//                pMap_other->special_kf_inOpti.pop();  // Delete the 1st element
//            }
//            std::cout << std::endl;
//            cout << "倒数第二个："<<pMap_other->special_kf_inOpti.front().size()<< endl;
            assert(false);//20 38
        }

        //下面代码为把当前关键帧it之后的关键帧的位姿通过求解的偏移量转换到world坐标系下
        for (; it_other != pMap_other->keyFrameList.end(); it_other++)
        {
            Vector3d P;
            Matrix3d R;
            (*it_other)->getOriginPose(P, R);
            P = pMap_other->r_drift * P + pMap_other->t_drift;
            R = pMap_other->r_drift * R;
            (*it_other)-> updatePose(P, R);
        }
        pMap_other->lastKF_index.push(pMap_other->keyFrameList.back()->global_index);
    }
    
    
    
    //---------------------------------------第2个数据的更新
    //优化完成，使用优化后的位姿来更新关键帧列表中index大于等于earliest_loop_index的所有关键帧的位姿
    i_main = 0;
    Vector3d t_drift_it_main = Vector3d::Zero();
    Matrix3d r_drift_it_main = Matrix3d::Identity();
    
    vector<Matrix3d> r_global_main;
    vector<Vector3d> t_global_main;
    for (it_main = pMainMap->keyFrameList.begin(); it_main != pMainMap->keyFrameList.end(); it_main++)
    {
        if ((*it_main)->global_index < earliest_loop_index_main)
            continue;

//        Quaterniond tmp_q;
//        //向量转换为矩阵
//        tmp_q = Utility::ypr2R(Vector3d(euler_array_main[i_main][0], euler_array_main[i_main][1], euler_array_main[i_main][2]));
        Quaterniond tmp_q(quaterniond_array_main[i_main][0],quaterniond_array_main[i_main][1],quaterniond_array_main[i_main][2],quaterniond_array_main[i_main][3]);
        
        Vector3d tmp_w1_t = Vector3d(t_array_main[i_main][0], t_array_main[i_main][1], t_array_main[i_main][2]);
        Matrix3d tmp_w1_r = tmp_q.toRotationMatrix();

//                cout<<"测试 优化完成 更新哪里变了："<<euler_array_main[i_main][0]<<" "<<euler_array_main[i_main][1]<<" "<<euler_array_main[i_main][2]<<" "<<t_array_main[i_main][0]<<" "<<t_array_main[i_main][1]<<" "<<t_array_main[i_main][2]<<" "<<i_main<<endl;
        if(need_resample_main[i_main])
        {
            (*it_main)-> updatePose(r_drift_it_main * tmp_w1_t + t_drift_it_main, r_drift_it_main * tmp_w1_r);
        }
        else
        {
            Vector3d origin_t_it;
            Matrix3d origin_r_it;
            (*it_main)->getOriginPose(origin_t_it, origin_r_it);
            r_drift_it_main = tmp_w1_r * origin_r_it.transpose();
            t_drift_it_main = tmp_w1_t - r_drift_it_main * origin_t_it;
            (*it_main)-> updatePose(tmp_w1_t, tmp_w1_r);
            
//            pMainMap->add2_r_global_multiClient(tmp_w1_r);
//            pMainMap->add2_t_global_multiClient(tmp_w1_t);
            r_global_main.push_back(tmp_w1_r);
            t_global_main.push_back(tmp_w1_t);

        }
        if ((*it_main)->global_index == latest_loop_index_main)
            break;
        i_main++;

    }
    //根据计算出当前帧的drift，更新全部关键帧位姿
    Vector3d cur_t_main, origin_t_main;
    Matrix3d cur_r_main, origin_r_main;
    //获取优化后当前帧的位姿cur_t,cur_r
    (*it_main)->getPose(cur_t_main, cur_r_main);
    //获取优化前有漂移的当前帧的位姿vio_t,vio_r
    (*it_main)->getOriginPose(origin_t_main, origin_r_main);
    pMainMap->yaw_drift = Utility::R2ypr(cur_r_main).x() - Utility::R2ypr(origin_r_main).x();
//    pMainMap->r_drift = Utility::ypr2R(Vector3d(pMainMap->yaw_drift, 0, 0));
    pMainMap->r_drift = cur_r_main*origin_r_main.transpose();
    pMainMap->t_drift = cur_t_main - pMainMap->r_drift * origin_t_main;
    
//    pMainMap->add2_r_global_multiClient(pMainMap->r_drift);
//    pMainMap->add2_t_global_multiClient(pMainMap->t_drift);
    r_global_main.push_back(pMainMap->r_drift);
    t_global_main.push_back(pMainMap->t_drift);
    pMainMap->add2_r_global_multiClient(r_global_main);
    pMainMap->add2_t_global_multiClient(t_global_main);
    
    if((r_global_main.size()-1)!=pMainMap->special_kf_inOpti.back().size()  && (r_global_main.size()-1)!=(t_global_main.size()-1)){
        cout<<"当前地图id"<<pMainMap->c->id<<" , "<<latest_loop_index_main<<endl;
        cout<<"resample_main下标数量不一致："<<r_global_main.size()<<" , "<<pMainMap->special_kf_inOpti.back().size()<<" , "<<t_global_main.size()<<endl;
//        while (pMainMap->special_kf_inOpti.size()!=2)
//        {
//            cout << pMainMap->special_kf_inOpti.front().size()<< " "; // Output the 1st element
//            pMainMap->special_kf_inOpti.pop();  // Delete the 1st element
//        }
//        std::cout << std::endl;
//        cout << "倒数第二个："<<pMainMap->special_kf_inOpti.front().size()<< endl;
        assert(false);//20 38
    }
    

    //下面代码为把当前关键帧it之后的关键帧的位姿通过求解的偏移量转换到world坐标系下
    for (; it_main != pMainMap->keyFrameList.end(); it_main++)
    {
        Vector3d P;
        Matrix3d R;
        (*it_main)->getOriginPose(P, R);
        P = pMainMap->r_drift * P + pMainMap->t_drift;
        R = pMainMap->r_drift * R;
        (*it_main)-> updatePose(P, R);
    }
    
//    pCurMap->isFirstFusion_globalMutex.unlock();
    
    
    
    
    
    pMainMap->lastKF_index.push(pMainMap->keyFrameList.back()->global_index);
//            位姿更新都留到显示那里
    pMainMap->updateVisualization();
    
    readWriteLock.readLock();
    PoseGraph* pMainMap_0=PoseGraphGloabl_map[0];
    readWriteLock.readUnLock();
    
   
    pAddKfMap->refine_path_mutex.lock();
    if(isUpdateFusionDraw){
        pMainMap_0->fusion_relative_isUpdate[pMainMap->c->id]=0;
        pMainMap_0->fusion_poseGraph_mutex.lock();
        pMainMap_0->fusion_otherGraph[pMainMap->c->id]=pMainMap;
        pMainMap_0->fusion_poseGraph_mutex.unlock();
    }
    pAddKfMap->refine_path_mutex.unlock();
    
    
    
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
        pMap_other->updateVisualization();
        pMap_other->isSendGloablData_multiClient=true;
        
        pAddKfMap->refine_path_mutex.lock();
        if(isUpdateFusionDraw){
            pMainMap_0->fusion_relative_isUpdate[pMap_other->c->id]=0;
            pMainMap_0->fusion_poseGraph_mutex.lock();
            pMainMap_0->fusion_otherGraph[pMap_other->c->id]=pMap_other;
            pMainMap_0->fusion_poseGraph_mutex.unlock();
        }
        pAddKfMap->refine_path_mutex.unlock();
        
        
        delete [](t_other_all[flag_start][0]);
        delete [](t_other_all[flag_start][1]);
        delete [](t_other_all[flag_start][2]);
        delete [](t_other_all[flag_start]);
        delete [](euler_other_all[flag_start][0]);
        delete [](euler_other_all[flag_start][1]);
        delete [](euler_other_all[flag_start][2]);
        delete [](euler_other_all[flag_start]);
        delete [](quaterniond_other_all[flag_start][0]);
        delete [](quaterniond_other_all[flag_start][1]);
        delete [](quaterniond_other_all[flag_start][2]);
        delete [](quaterniond_other_all[flag_start][3]);
        delete [](quaterniond_other_all[flag_start]);
        
//        for(int i=0;i<3;i++){
//            delete [](t_global_all[flag_start][i]);
//        }
//        delete [](t_global_all[flag_start]);
//        for(int i=0;i<4;i++){
//            delete [](r_global_all[flag_start][i]);
//        }
//        delete [](r_global_all[flag_start]);
              
    }
    //发送数据
    pMainMap->isSendGloablData_multiClient=true;
    
    //    TODO 用来多用户ar 发送ar位姿的
        pAddKfMap->isFirstFusion_globalMutex.lock();
        isFusion[i]=1;
        pAddKfMap->isFirstFusion_globalMutex.unlock();

    cout<<"最终的全局优化结束"<<i<<endl;
//    cout<<"测试 偏移对不对"<<pCurMap->t_drift[0]<<" "<<pCurMap->t_drift[1]<<" "<<pCurMap->t_drift[2]<<endl;
//    cout<<"主地图为："<<pMainMap->c->id<<endl;
//    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
//        cout<<"t:"<<t_global_all[flag_start][0]<<" , "<<t_global_all[flag_start][1]<<" , "<<t_global_all[flag_start][2]<<endl;
//        // roll (x-axis rotation)
//            double sinr_cosp = 2 * (r_global_all[flag_start][3] * r_global_all[flag_start][0] + r_global_all[flag_start][1] * r_global_all[flag_start][2]);
//            double cosr_cosp = 1 - 2 * (r_global_all[flag_start][0] * r_global_all[flag_start][0] + r_global_all[flag_start][1] * r_global_all[flag_start][1]);
//            double roll = std::atan2(sinr_cosp, cosr_cosp);
//
//            // pitch (y-axis rotation)
//            double sinp = 2 * (r_global_all[flag_start][3] * r_global_all[flag_start][1] - r_global_all[flag_start][2] * r_global_all[flag_start][0]);
//            double pitch;
//            if (std::abs(sinp) >= 1)
//                pitch = std::copysign(M_PI / 2, sinp); // use 90 degrees if out of range
//            else
//                pitch = std::asin(sinp);
//
//            // yaw (z-axis rotation)
//            double siny_cosp = 2 * (r_global_all[flag_start][3]* r_global_all[flag_start][2] + r_global_all[flag_start][0] * r_global_all[flag_start][1]);
//            double cosy_cosp = 1 - 2 * (r_global_all[flag_start][1] * r_global_all[flag_start][1] + r_global_all[flag_start][2] * r_global_all[flag_start][2]);
//            double yaw = std::atan2(siny_cosp, cosy_cosp);
//
//        cout<<"r:"<< yaw <<" , " <<pitch<<" , " <<roll<<endl;
//    }
    
}

//把相对位姿当作优化变量
void PoseGraphGlobal::GlobalFuse_12(int i)
{
    cout<<"最终的全局优化"<<i<<endl;
    bool isUpdateFusionDraw=false;
//    cout<<"死锁没"<<endl;
    //因为现在写的都是和主地图发生地图融合 所以其中一个地图直接这么获取了
//    poseGraphGlobal_mutex.lock();
    readWriteLock.readLock();
    map<int,PoseGraph*>::iterator iter_map = PoseGraphGloabl_map.find(i);
    if(iter_map==PoseGraphGloabl_map.end())
    {
//        poseGraphGlobal_mutex.unlock();
        readWriteLock.readUnLock();
        assert(false);//都已经发生回环了，却找不到地图 说明数据插错
    }
    PoseGraph* pAddKfMap= iter_map->second;
    int len = PoseGraphGloabl_map.size();
    readWriteLock.readUnLock();
    
    vector<std::unique_lock<std::mutex>* > lock_all;
    std::unique_lock<std::mutex> lock(pAddKfMap->keyFrameList_global_fusion_mutex, std::defer_lock);
    if (lock.try_lock()) {
        cout<<"加锁："<<pAddKfMap->c->id<<endl;
        lock_all.push_back(&lock);
    } else {
        cout<<"最终的全局优化中断"<<i<<endl;
        return;
    }
    if(i==mainClientID){
        isUpdateFusionDraw=true;
    }


    
    double total_lenth_other=0.0;
    vector< double> length_other;
    PoseGraph* pMainMap;//id最小的
    vector<PoseGraph *> vMap_all;//除id最小,也就是匹配上的全部其它地图
    map<int,int> vMapId_all;//int表示clientId 后面表示存放在vMap_all的下标
    //找其它融合的地图 一起参与优化
    bool isFindMinClient=true;
    readWriteLock.readLock();
    if(PoseGraphGloabl_map.size()>1){
        readWriteLock.readUnLock();
        for(int client_id=0;client_id<len;client_id++){//这里的i其实代表的就是 ClientId
            if(client_id==i){
                continue;
            }
            if(uf.isConnected(i, client_id)){
                readWriteLock.readLock();
                map<int,PoseGraph*>::iterator iter_map_other = PoseGraphGloabl_map.find(client_id);
                if(iter_map_other==PoseGraphGloabl_map.end()){
                    readWriteLock.readUnLock();
                    continue;
                }
                PoseGraph* pOtherMap= iter_map_other->second;//新的地图 小的地图
                readWriteLock.readUnLock();
                
                
                std::unique_lock<std::mutex> lock(pOtherMap->keyFrameList_global_fusion_mutex, std::defer_lock);
                if (lock.try_lock()) {
                    cout<<"加锁："<<pOtherMap->c->id<<endl;
                    lock_all.push_back(&lock);
                } else {
                    //                    把之前锁住了的解锁了
                    cout<<"最终的全局优化中断"<<pOtherMap->c->id<<endl;
                    return;
                }
         
                
                if(isFindMinClient){
                    isFindMinClient=false;
                    if(i>client_id){
//                        这里就是id最小的地图
                        pMainMap=pOtherMap;
//                        cout<<"主地图大小："<<pMainMap->size()<<endl;
                      
                        vMap_all.push_back(pAddKfMap);
                        vMapId_all.insert(make_pair(pAddKfMap->c->id,vMap_all.size()-1));
                        total_lenth_other+=pAddKfMap->total_length;
                        length_other.push_back(pAddKfMap->total_length);
                        
                        if(client_id==mainClientID){
                            isUpdateFusionDraw=true;
                        }
                        continue;
                    }else{
                        pMainMap=pAddKfMap;
                    }
                }
                vMap_all.push_back(pOtherMap);
                vMapId_all.insert(make_pair(pOtherMap->c->id,vMap_all.size()-1));
                
                total_lenth_other+=pOtherMap->total_length;
                length_other.push_back(pOtherMap->total_length);
                
            }
            
        }
    }
    else{
        readWriteLock.readUnLock();
        assert(false);//都要发生全局优化了 却只有1个地图
    }
    
   
    
    //主地图从earliest_loop_index_main开始--当前帧结束
    //小地图从第一帧开始--当前发生回环的帧 这个有可能是回环帧，也有可能是融合帧
    ceres::Problem problem;
    ceres::Solver::Options options;
    //options.linear_solver_type = ceres::DENSE_NORMAL_CHOLESKY;
    options.linear_solver_type = ceres::DENSE_SCHUR;
    options.minimizer_progress_to_stdout = false;
    options.max_num_iterations = 10;
    ceres::Solver::Summary summary;
    ceres::LossFunction *loss_function;
    loss_function = new ceres::HuberLoss(1.0);
    //AngleLocalParameterization类的主要作用是指定yaw角优化变量的迭代更新，重载了括号运算
//    ceres::LocalParameterization* angle_local_parameterization =
//    AngleLocalParameterization::Create();
    ceres::LocalParameterization* local_parameterization = new ceres::QuaternionParameterization();

            
    
    double total_lenth_main=pMainMap->total_length;
    //总的位姿长度 除以总的帧数
    double total_lenth_sum=total_lenth_main+total_lenth_other;
    int max_frame_num_global_main=(total_lenth_main/total_lenth_sum)*max_frame_num_global;
    double min_dis_main=total_lenth_main/max_frame_num_global_main;
    
    //要优化的变量的最大个数 主地图
    int max_length_main=pMainMap->size()+1;
    double t_array_main[max_length_main][3];//平移数组，其中存放每个关键帧的平移向量
    Quaterniond q_array_main[max_length_main];
    double euler_array_main[max_length_main][3];
    double quaterniond_array_main[max_length_main][4];
    vector<bool> need_resample_main;
    
//    double rt_global_main[7]={0};//为单位矩阵
//    rt_global_main[6]=1;
    double t_global_main_relative[3]={0};//为单位矩阵
    double r_global_main_relative[4]={0};//为单位矩阵
    r_global_main_relative[3]=1;
    
    pMainMap->max_frame_num_global=max_frame_num_global_main;
    pMainMap->min_dis=min_dis_main;
    

    const int mapOther_sum=vMap_all.size();
    vector< double** > t_other_all;
    vector< vector<Quaterniond > > q_other_all;
    vector< double** > euler_other_all;//里面存储的是度数  不是弧度
    vector< double** > quaterniond_other_all;
    vector< vector<bool> > resample_other_all;
    
    double t_relativeCurMain[mapOther_sum][3];//从当前帧 到主地图
    double quaterniond_relativeCurMain[mapOther_sum][4];
    
//    vector< double > pitch_other_all;
//    vector< double > roll_other_all;
//    这个后续记录在帧内部
//    vector< double** > rt_global_all;
    
//    这个是每一帧都有一个rt
//    vector< double** > t_global_all;
//    vector< double** > r_global_all;
    
//    这个是每一地图都有一个rt
//    double t_global_all[mapOther_sum][3];
//    double r_global_all[mapOther_sum][4];
    
    
    int main_clientId=pMainMap->c->id;
    
    pMainMap->loop_index_mutex.lock();
    int earliest_loop_index_main=pMainMap->earliest_loop_index;
    int earliest_global_looped_index_main=earliest_globalLoop_index[pMainMap->c->id];
    int latest_loop_index_main=pMainMap->latest_loop_index;
    int latest_global_looped_index_main=latest_globalLoop_index[pMainMap->c->id];
    pMainMap->loop_index_mutex.unlock();
    
    if (earliest_loop_index_main > earliest_global_looped_index_main || earliest_loop_index_main == -1  )
        earliest_loop_index_main=earliest_global_looped_index_main;
    
    
    if (latest_global_looped_index_main > latest_loop_index_main)
        latest_loop_index_main=latest_global_looped_index_main;
//    pMainMap->loop_index_multiClient.push(earliest_loop_index_main);
//    pMainMap->curKF_loop_index_multiClient.push(latest_loop_index_main);//这个是要发回客户端 用来更新位姿的 TODO 后面要改改
    vector<int> latest_loop_index_other_correct;
    vector<int> earliest_loopIndex_other_all;
    vector<int> latest_loopIndex_other_all;
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
        
        pMap_other->loop_index_mutex.lock();
        int earliest_loop_index_other=pMap_other->earliest_loop_index;
        int earliest_global_looped_index_other=earliest_globalLoop_index[pMap_other->c->id];
        int latest_loop_index_other=pMap_other->latest_loop_index;
        int latest_global_looped_index_other=latest_globalLoop_index[pMap_other->c->id];
        pMap_other->loop_index_mutex.unlock();
        
        if (earliest_loop_index_other > earliest_global_looped_index_other || earliest_loop_index_other == -1  )
            earliest_loop_index_other=earliest_global_looped_index_other;
        earliest_loopIndex_other_all.push_back(earliest_loop_index_other);
        
        
        if (latest_global_looped_index_other > latest_loop_index_other)
            latest_loop_index_other=latest_global_looped_index_other;
        latest_loopIndex_other_all.push_back(latest_loop_index_other);
        
//        pMap_other->isFirstFusion_globalMutex.lock();
//        pMap_other->loop_index_multiClient.push(0);
//        pMap_other->curKF_loop_index_multiClient.push(latest_loop_index_other);
//        pMap_other->isFirstFusion_globalMutex.unlock();
        latest_loop_index_other_correct.push_back(latest_loop_index_other);
        
        double total_length_otherMap=length_other[flag_start];
        int max_frame_num_global_other=(total_length_otherMap/total_lenth_sum)*max_frame_num_global;
        double min_dis_other=total_length_otherMap/max_frame_num_global_other;
        pMap_other->max_frame_num_global=max_frame_num_global_other;
        pMap_other->min_dis=min_dis_other;
        
        //要优化的变量的最大个数 小地图
        int max_length_other=pMap_other->keyFrameList.size()+1;
        double** t_test=new double*[max_length_other];
        for(int index_flag=0;index_flag<max_length_other;index_flag++) t_test[index_flag] = new double[3];
        t_other_all.push_back(t_test);
        
        vector<Quaterniond > q_array_other(max_length_other);
        q_other_all.push_back(q_array_other);
        
        double** euler_test=new double*[max_length_other];
        for(int index_flag=0;index_flag<max_length_other;index_flag++) euler_test[index_flag] = new double[3];
        euler_other_all.push_back(euler_test);
        
        double** quaterniond_test=new double*[max_length_other];
        for(int index_flag=0;index_flag<max_length_other;index_flag++) quaterniond_test[index_flag] = new double[4];
        quaterniond_other_all.push_back(quaterniond_test);
        
        vector<bool> need_resample_other;
        resample_other_all.push_back(need_resample_other);
        
//        double** t_global_test=new double*[max_length_other];
//        double** r_global_test=new double*[max_length_other];
//        for(int index_flag=0;index_flag<max_length_other;index_flag++){
//            t_global_test[index_flag] = new double[3];
//            r_global_test[index_flag] = new double[4];
//            r_global_test[index_flag][3]=1;
//
//            for(int hh=0;hh<3;hh++){
//                t_global_test[index_flag][hh]=0;
//                r_global_test[index_flag][hh]=0;
//            }
//        }
//        t_global_all.push_back(t_global_test);
//        r_global_all.push_back(r_global_test);
        
//        double t_global_test[3]={0};
//        double r_global_test[4]={0};
//        r_global_test[3]=1;
//        t_global_all.push_back(t_global_test);
//        r_global_all.push_back(r_global_test);
        
        Matrix3d r_w1_w2;
        Vector3d t_w1_w2;
        Quaterniond q_w1_w2;
        r_w1_w2=pMap_other->fromI2OtherClient_r[main_clientId];
        t_w1_w2=pMap_other->fromI2OtherClient_t[main_clientId];
        q_w1_w2=r_w1_w2;
        t_relativeCurMain[flag_start][0]=t_w1_w2[0];
        t_relativeCurMain[flag_start][1]=t_w1_w2[1];
        t_relativeCurMain[flag_start][2]=t_w1_w2[2];
        quaterniond_relativeCurMain[flag_start][0] = q_w1_w2.w();
        quaterniond_relativeCurMain[flag_start][1] = q_w1_w2.x();
        quaterniond_relativeCurMain[flag_start][2] = q_w1_w2.y();
        quaterniond_relativeCurMain[flag_start][3] = q_w1_w2.z();
        
    }
   
    //*************************************遍历数据 记录要参与优化的

    vector<int> special_kf_inOpti_main;
    vector<int> kf_id_hasComPlace_main;
    //遍历关键帧列表
    list<KeyFrame*>::iterator it_main = pMainMap->keyFrameList.begin();
    Vector3d last_P_main = Vector3d(0, 0, 0);
    double dis_main = 0;
    int resample_id=0;
    for(;it_main!=pMainMap->keyFrameList.end();it_main++){
        if((*it_main)->global_index < earliest_loop_index_main){
            continue;
        }
        (*it_main)->resample_globalIndex = resample_id;
        Vector3d tmp_t;
        Matrix3d tmp_r;
        //获取关键帧it的位姿
        (*it_main)->getPose(tmp_t, tmp_r);
        dis_main += (tmp_t - last_P_main).norm();
        //全局优化 还是要加序列边 不然太长了 判断条件 再加个两个地图之间发生了融合
        if((*it_main)->global_index == earliest_loop_index_main || dis_main > min_dis_main || (*it_main)->is_get_loop_info || (*it_main)->is_looped || (*it_main)->has_global_loop || (*it_main)->is_global_looped || pMainMap->keyFrameList.size() < max_frame_num_global_main)
        {
            dis_main = 0;
            last_P_main = tmp_t;
            need_resample_main.push_back(0);
            
//            pMainMap->special_kf_inOpti.push_back((*it_main)->global_index);
            special_kf_inOpti_main.push_back((*it_main)->global_index);
            
            if(((*it_main)->has_global_loop || (*it_main)->is_global_looped) && (*it_main)->is_Send==false ){
                kf_id_hasComPlace_main.push_back((*it_main)->global_index);
//                pMainMap->add2_kf_id_hasComPlace_withOtherMap((*it_main)->global_index);
                (*it_main)->is_Send=true;
            }
            
        }
        else
        {
            last_P_main = tmp_t;
            need_resample_main.push_back(1);
        }
        
        Quaterniond tmp_q;
        Matrix3d tmp_r_origin;
        Vector3d tmp_t_origin;
        (*it_main)->getOriginPose(tmp_t_origin, tmp_r_origin);
//                (*it_main)->getPose(tmp_t, tmp_r);
        tmp_q = tmp_r_origin;
        t_array_main[resample_id][0] = tmp_t_origin(0);
        t_array_main[resample_id][1] = tmp_t_origin(1);
        t_array_main[resample_id][2] = tmp_t_origin(2);
        q_array_main[resample_id] = tmp_q;
        //将矩阵转换为向量
        Vector3d euler_angle = Utility::R2ypr(tmp_r_origin);
        euler_array_main[resample_id][0] = euler_angle.x();
        euler_array_main[resample_id][1] = euler_angle.y();
        euler_array_main[resample_id][2] = euler_angle.z();
        
        quaterniond_array_main[resample_id][0]=tmp_q.w();
        quaterniond_array_main[resample_id][1]=tmp_q.x();
        quaterniond_array_main[resample_id][2]=tmp_q.y();
        quaterniond_array_main[resample_id][3]=tmp_q.z();
        
        resample_id++;
        
        if ((*it_main)->global_index == latest_loop_index_main)
            break;
    }
    
//    pMainMap->special_kf_mutex.lock();
//    pMainMap->add2_kf_id_hasComPlace_withOtherMap(kf_id_hasComPlace_main);
//   pMainMap->special_kf_inOpti.push(special_kf_inOpti_main);
//   pMainMap->special_kf_mutex.unlock();
    
    
    
    
    
    vector<vector<int> > special_kf_inOpti_cur_all;
    vector<vector<int> > kf_id_hasCom_cur_all;
    
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
        //遍历关键帧列表
        list<KeyFrame*>::iterator it_other = pMap_other->keyFrameList.begin();

//        Vector3d last_P_other = Vector3d(0, 0, 0);
        Vector3d last_P_other =pMap_other->fromI2OtherClient_t[main_clientId];
        double dis_other = 0;
        
        vector<int> special_kf_inOpti_cur;
        vector<int> kf_id_hasCom_cur;
        resample_id=0;
        resample_other_all[flag_start].clear();
       
        int temp_opti=0;
        //小地图是从第一个帧开始优化
        for(;it_other!=pMap_other->keyFrameList.end();it_other++){
            (*it_other)->resample_globalIndex = resample_id;
            
            Vector3d tmp_t;
            Matrix3d tmp_r;
            //获取关键帧it的位姿
            (*it_other)->getPose(tmp_t, tmp_r);
            dis_other += (tmp_t - last_P_other).norm();
            
            
            //全局优化 还是要加序列边 不然太长了 判断条件 再加个两个地图之间发生了融合
            //第一个地图融合位置，超过长度了，发生过回环，被回环了，总共的帧长度比最大值小
            //还要再加一个 发生了融合，被融合了
            if((*it_other)->global_index == 0 || dis_other > pMap_other->min_dis || (*it_other)->is_get_loop_info || (*it_other)->is_looped || (*it_other)->has_global_loop || (*it_other)->is_global_looped || pMap_other->keyFrameList.size() < pMap_other->max_frame_num_global)
            {
                dis_other = 0;
                last_P_other = tmp_t;
                resample_other_all[flag_start].push_back(0);
                
    //            pCurMap->special_kf_inOpti.push_back((*it_other)->global_index);
                special_kf_inOpti_cur.push_back((*it_other)->global_index);
                
                if(((*it_other)->has_global_loop || (*it_other)->is_global_looped) && (*it_other)->is_Send==false ){
                    kf_id_hasCom_cur.push_back((*it_other)->global_index);
    //                pCurMap->add2_kf_id_hasComPlace_withOtherMap((*it_other)->global_index);
                    (*it_other)->is_Send=true;
                }
                
                temp_opti++;
                
            }
            else
            {
                last_P_other = tmp_t;
                resample_other_all[flag_start].push_back(1);
            }
            
            Quaterniond tmp_q;
            Matrix3d tmp_r_origin;
            Vector3d tmp_t_origin;
            (*it_other)->getOriginPose(tmp_t_origin, tmp_r_origin);
    //                (*it_main)->getPose(tmp_t, tmp_r);
//            更新到主地图所在坐标系
//            Matrix3d r_w1_w2;
//            Vector3d t_w1_w2;
//            r_w1_w2=pMap_other->fromI2OtherClient_r[main_clientId];
//            t_w1_w2=pMap_other->fromI2OtherClient_t[main_clientId];
//            tmp_r_origin=r_w1_w2*tmp_r_origin;
//            tmp_t_origin=r_w1_w2*tmp_t_origin+t_w1_w2;
//            cout<<"main_clientId="<<main_clientId<<" , "<<r_w1_w2<<" , "<<t_w1_w2<<endl;
            
            
            tmp_q = tmp_r_origin;
            (t_other_all[flag_start])[resample_id][0] = tmp_t_origin(0);
            (t_other_all[flag_start])[resample_id][1] = tmp_t_origin(1);
            (t_other_all[flag_start])[resample_id][2] = tmp_t_origin(2);
            q_other_all[flag_start][resample_id] = tmp_q;
            //将矩阵转换为向量
            Vector3d euler_angle = Utility::R2ypr(tmp_r_origin);
            euler_other_all[flag_start][resample_id][0] = euler_angle.x();
            euler_other_all[flag_start][resample_id][1] = euler_angle.y();
            euler_other_all[flag_start][resample_id][2] = euler_angle.z();
            
            quaterniond_other_all[flag_start][resample_id][0]=tmp_q.w();
            quaterniond_other_all[flag_start][resample_id][1]=tmp_q.x();
            quaterniond_other_all[flag_start][resample_id][2]=tmp_q.y();
            quaterniond_other_all[flag_start][resample_id][3]=tmp_q.z();
           
            
            resample_id++;
            
            if ((*it_other)->global_index == latest_loopIndex_other_all[flag_start])
                break;
        }
        
//        cout<<"temp_opti="<<temp_opti<<" , "<<latest_loopIndex_other_all[flag_start]<<endl;
        
//        pMap_other->special_kf_mutex.lock();
//        pMap_other->add2_kf_id_hasComPlace_withOtherMap(kf_id_hasCom_cur);
//        pMap_other->special_kf_inOpti.push(special_kf_inOpti_cur);
//        pMap_other->special_kf_mutex.unlock();
        special_kf_inOpti_cur_all.push_back(special_kf_inOpti_cur);
        kf_id_hasCom_cur_all.push_back(kf_id_hasCom_cur);
        
    }
    
    //*************************************第一个数据
//    if(pMainMap->relativeOtherMap_clientId!=-1){
//        assert(false);//因为最小的地图 那他没有和更小的地图融合 relativeOtherMap_clientId这个记录它融合的所有地图的最小id
//    }

//    暂时注释 后面会求导那些了 再改
//        ceres::LocalParameterization *local_parameterization = new PoseQ_LocalParameterization();
//        problem.AddParameterBlock(r_global_main_relative, 4, local_parameterization);
//        problem.SetParameterBlockConstant(r_global_main_relative);
//
//        problem.AddParameterBlock(t_global_main_relative, 3);
//        problem.SetParameterBlockConstant(t_global_main_relative);

    int i_main = 0;
    for (it_main = pMainMap->keyFrameList.begin(); it_main != pMainMap->keyFrameList.end(); it_main++)
    {
        if ((*it_main)->global_index < earliest_loop_index_main)
            continue;

        
        //将关键帧列表中所有index>=earliest_loop_index的关键帧的位姿加入到参数块当中
//        problem.AddParameterBlock(euler_array_main[i_main], 1, angle_local_parameterization);
        problem.AddParameterBlock(quaterniond_array_main[i_main], 4, local_parameterization);
        problem.AddParameterBlock(t_array_main[i_main], 3);
        //设置约束：如果该帧是最早的闭环帧的情况下，则固定它的位姿
        if ((*it_main)->global_index == earliest_loop_index_main)
        {
//            problem.SetParameterBlockConstant(euler_array_main[i_main]);
            problem.SetParameterBlockConstant(quaterniond_array_main[i_main]);
            problem.SetParameterBlockConstant(t_array_main[i_main]);
        }
        
//        problem.SetParameterBlockConstant(quaterniond_array_main[i_main]);
        
        if(need_resample_main[i_main])
        {
            i_main++;
            continue;
        }
        
        
        int j = 1, sequence_link_cnt = 0;
        while(sequence_link_cnt < 5)
        {
            if (i_main - j >= 0)
            {
//                        list<KeyFrame*>::iterator tmp = it_main;
//                        std::advance (tmp, -j);
                if(need_resample_main[i_main-j])
                {
                    j++;
                    continue;
                }
                else
                {
                    sequence_link_cnt++;
                }
                Vector3d euler_conncected = Utility::R2ypr(q_array_main[i_main-j].toRotationMatrix());
                //p̂_j^w - p̂_i^w 计算平移量的偏差
                Vector3d relative_t(t_array_main[i_main][0] - t_array_main[i_main-j][0], t_array_main[i_main][1] - t_array_main[i_main-j][1], t_array_main[i_main][2] - t_array_main[i_main-j][2]);
                //p̂_{ij}^{i} = {R̂_i^w}^{-1} (p̂_j^w - p̂_i^w)
                //p̂ ij= (R̂ iw ) (p̂ jw − p̂ iw )
                relative_t = q_array_main[i_main-j].inverse() * relative_t;
                //ψ̂ _ij = ψ̂ _j − ψ̂ _i
                double relative_yaw = euler_array_main[i_main][0] - euler_array_main[i_main-j][0];
//                cout<<"主地图序列帧relative_t："<<relative_t[0]<<" , "<<relative_t[1]<<" , "<<relative_t[2]<<endl;
//                cout<<"主地图序列帧euler_conncected："<<euler_conncected[0]<<" , "<<euler_conncected[1]<<" , "<<euler_conncected[2]<<endl;
//                cout<<"主地图序列帧relative_yaw："<<relative_yaw<<endl;
//                ceres::CostFunction* cost_function = FourDOFError_another::Create( relative_t.x(), relative_t.y(), relative_t.z(), relative_yaw, euler_conncected.y(), euler_conncected.z());
//                problem.AddResidualBlock(cost_function, loss_function, euler_array_main[i_main-j], t_array_main[i_main-j], euler_array_main[i_main], t_array_main[i_main]);
                
                Quaterniond relative_q=q_array_main[i_main-j].inverse()*q_array_main[i_main];
//                cout<<"relative_q 12658 seq_kf="<<relative_q.w()<<" , "<<relative_q.x()<<" , "<<relative_q.y()<<" , "<<relative_q.z()<<endl;
                
                double w_q_i[4],i_q_w[4],w_q_j[4],q_i_j[4];
                w_q_i[0]=q_array_main[i_main-j].w();
                w_q_i[1]=q_array_main[i_main-j].x();
                w_q_i[2]=q_array_main[i_main-j].y();
                w_q_i[3]=q_array_main[i_main-j].z();
                QuaternionInverse(w_q_i, i_q_w);
                w_q_j[0]=q_array_main[i_main].w();
                w_q_j[1]=q_array_main[i_main].x();
                w_q_j[2]=q_array_main[i_main].y();
                w_q_j[3]=q_array_main[i_main].z();
                ceres::QuaternionProduct(i_q_w, w_q_j, q_i_j);
//                    cout<<"relative_q 12862 q_i_j="<<q_i_j[0]<<" , "<<q_i_j[1]<<" , "<<q_i_j[2]<<" , "<<q_i_j[3]<<endl;
//
//                    cout<<"relative_q 12862 seq_kf="<<relative_q.w()<<" , "<<relative_q.x()<<" , "<<relative_q.y()<<" , "<<relative_q.z()<<endl;
                double relative_q_double[4],relative_q_inv[4],error_q[4];
                relative_q_double[0]=relative_q.w();
                relative_q_double[1]=relative_q.x();
                relative_q_double[2]=relative_q.y();
                relative_q_double[3]=relative_q.z();
                QuaternionInverse(relative_q_double, relative_q_inv);
                ceres::QuaternionProduct(relative_q_inv, q_i_j, error_q);
               
                
                if(error_q[1]>0.000001 || error_q[1]<-0.000001){
                    cout<<"relative_q 12721 error_q="<<error_q[0]<<" , "<<error_q[1]<<" , "<<error_q[2]<<" , "<<error_q[3]<<endl;
                    cout<<"数据不规范序列帧"<<endl;
                }
                
                
                ceres::CostFunction* cost_function = RelativeRTError::Create(relative_t.x(), relative_t.y(), relative_t.z(),relative_q.w(), relative_q.x(), relative_q.y(), relative_q.z(),1.0,1.0);
                problem.AddResidualBlock(cost_function, loss_function, quaterniond_array_main[i_main-j],
                                         t_array_main[i_main-j],
                                         quaterniond_array_main[i_main],
                                         t_array_main[i_main]);
            }
            else
            {
                break;
            }
            j++;
        }

        //        添加的是闭环边，是指检测到闭环的两帧
        if((*it_main)->is_get_loop_info   )
        {
            if((*it_main)->loop_index >= earliest_loop_index_main)
            {
                int connected_index = pMainMap->getKeyframe((*it_main)->loop_index)->resample_globalIndex;

                Vector3d euler_conncected = Utility::R2ypr(q_array_main[connected_index].toRotationMatrix());
                Vector3d relative_t((*it_main)->loop_info_better(0), (*it_main)->loop_info_better(1), (*it_main)->loop_info_better(2));
                double relative_yaw = (*it_main)->loop_info_better(3);
//                cout<<"主地图回环relative_t："<<relative_t[0]<<" , "<<relative_t[1]<<" , "<<relative_t[2]<<endl;
//                cout<<"主地图回环euler_conncected："<<euler_conncected[0]<<" , "<<euler_conncected[1]<<" , "<<euler_conncected[2]<<endl;
//                cout<<"主地图回环relative_yaw："<<relative_yaw<<endl;
                
//                ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),
//                                                                                relative_yaw, euler_conncected.y(), euler_conncected.z());
//                problem.AddResidualBlock(cost_function, NULL, euler_array_main[connected_index], t_array_main[connected_index],  euler_array_main[i_main],  t_array_main[i_main]);
                
                Quaterniond relative_q=(*it_main)->loop_info_better_q;
//                cout<<"relative_q 12691 loop_kf="<<relative_q.w()<<" , "<<relative_q.x()<<" , "<<relative_q.y()<<" , "<<relative_q.z()<<endl;
                ceres::CostFunction* cost_function = RelativeRTError::Create(relative_t.x(), relative_t.y(), relative_t.z(),relative_q.w(), relative_q.x(), relative_q.y(), relative_q.z(),10.0,1.0);
                problem.AddResidualBlock(cost_function, NULL, quaterniond_array_main[connected_index],
                                         t_array_main[connected_index],
                                         quaterniond_array_main[i_main],
                                         t_array_main[i_main]);
            }else{
                cout<<"主地图回环id:"<<(*it_main)->global_index<<" , "<<(*it_main)->loop_index<<" , "<<earliest_loop_index_main<<endl;
                cout<<(*it_main)->has_global_loop<<endl;
//                猜测应该是这个帧 后面有发生了自身的回环，前面只是检测到 和其它地图的回环
//                并没有检测到和其它地图的回环 猜测是自身回环还没更新最早的id 或者更新错误之类的
                assert(false);//报错36 37, 6 8 20220530, 23 24
            }
        }

        
        if((*it_main)->has_global_loop)
       {
           //这里后面还要添加else
           if((*it_main)->global_loop_index < 0)
           {
               //因为这意味着数据保存出错了 发生了融合的帧的id小于最早发生融合的id
               assert(false);
               return;
           }
//           获取是和哪个其它地图发生了回环
           (*it_main)->readWriteLock_loop.readLock();
           int loop_index_flag_end=(*it_main)->clientId.size();
           (*it_main)->readWriteLock_loop.readUnLock();
//           遍历该帧的 所有回环帧
           for(int loop_index_flag=0;loop_index_flag<loop_index_flag_end;loop_index_flag++){
               (*it_main)->readWriteLock_loop.readLock();
               int matching_clientId=(*it_main)->clientId[loop_index_flag];
               int matching_kfId=(*it_main)->kfId[loop_index_flag];
               std::pair<Matrix3d , Vector3d > matching_rt=(*it_main)->relativePose[loop_index_flag];
               (*it_main)->readWriteLock_loop.readUnLock();
               
//               找到这个对应的其它地图
               int vmap_index=vMapId_all[matching_clientId];
               PoseGraph * pMap_other=vMap_all[vmap_index];
               //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束 会出现空指针的问题
               int connected_index = pMap_other->getKeyframe(matching_kfId)->resample_globalIndex;//这里可能多个
               
               if(matching_kfId < earliest_loopIndex_other_all[vmap_index])
               {
                   //因为这意味着数据保存出错了 发生了融合的帧的id小于最早发生融合的id
                   assert(false);
                   return;
               }
               
               Vector3d euler_conncected = Utility::R2ypr(q_other_all[vmap_index][connected_index].toRotationMatrix());
               Vector3d relative_t((*it_main)->relative_global_loop_info_multiClient[loop_index_flag](0), (*it_main)->relative_global_loop_info_multiClient[loop_index_flag](1), (*it_main)->relative_global_loop_info_multiClient[loop_index_flag](2));
               double relative_yaw = (*it_main)->relative_global_loop_info_multiClient[loop_index_flag](7);
               
               //这里到时候 再写一个求导的
//               ceres::CostFunction* cost_function1 = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z());
//               problem.AddResidualBlock(cost_function1, NULL, euler_other_all[vmap_index][connected_index] ,
//                                       t_other_all[vmap_index][connected_index] ,
//                                        euler_array_main[i_main],
//                                        t_array_main[i_main]);
               
               double  qw=(*it_main)->relative_global_loop_info_multiClient[loop_index_flag](3),qx=(*it_main)->relative_global_loop_info_multiClient[loop_index_flag](4),qy=(*it_main)->relative_global_loop_info_multiClient[loop_index_flag](5),qz=(*it_main)->relative_global_loop_info_multiClient[loop_index_flag](6);
               Quaterniond relative_q(qw, qx, qy, qz);
//               cout<<"relative_q 12751 globalloop_kf="<<relative_q.w()<<" , "<<relative_q.x()<<" , "<<relative_q.y()<<" , "<<relative_q.z()<<endl;
               ceres::CostFunction* cost_function1 = RelativeRTError_3opti_main::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_q.w(), relative_q.x(), relative_q.y(), relative_q.z(),10.0,1.0);
               problem.AddResidualBlock(cost_function1, NULL, quaterniond_other_all[vmap_index][connected_index] ,
                                       t_other_all[vmap_index][connected_index] ,
                                        quaterniond_array_main[i_main],
                                        t_array_main[i_main], quaterniond_relativeCurMain[vmap_index], t_relativeCurMain[vmap_index]);
               
//               MultiClientFactor_merge *f = new MultiClientFactor_merge(relative_t, euler_conncected.y(), euler_conncected.z());
//               problem.AddResidualBlock(f, NULL, euler_other_all[vmap_index][connected_index] ,
//                                        t_other_all[vmap_index][connected_index] , t_array_main[i_main] ,t_global_all[vmap_index][connected_index],r_global_all[vmap_index][connected_index],t_global_main_relative,r_global_main_relative);
//
//               Vector3d euler_conncected_j = Utility::R2ypr(q_array_main[i_main].toRotationMatrix());
//               ceres::CostFunction* cost_function = EightDOFWeightError_yaw::Create( relative_yaw, euler_conncected.y(), euler_conncected.z(),euler_conncected_j.y(),euler_conncected_j.z());
//             problem.AddResidualBlock(cost_function, NULL, euler_other_all[vmap_index][connected_index] ,euler_array_main[i_main] , r_global_all[vmap_index][connected_index] ,r_global_main_relative);
               
//               同上暂时注释的
//               MultiClientFactor_merge *f = new MultiClientFactor_merge(relative_t, euler_conncected.y(), euler_conncected.z());
//               problem.AddResidualBlock(f, NULL, euler_other_all[vmap_index][connected_index] ,
//                                        t_other_all[vmap_index][connected_index] , t_array_main[i_main] ,t_global_all[vmap_index],r_global_all[vmap_index],t_global_main_relative,r_global_main_relative);
//
//               Vector3d euler_conncected_j = Utility::R2ypr(q_array_main[i_main].toRotationMatrix());
//               ceres::CostFunction* cost_function = EightDOFWeightError_yaw::Create( relative_yaw, euler_conncected.y(), euler_conncected.z(),euler_conncected_j.y(),euler_conncected_j.z());
//             problem.AddResidualBlock(cost_function, NULL, euler_other_all[vmap_index][connected_index] ,euler_array_main[i_main] , r_global_all[vmap_index] ,r_global_main_relative);
           }
          
           
           
       }
        
        
        if ((*it_main)->global_index == latest_loop_index_main)
            break;
        i_main++;
    }
    
    int i_other = 0;
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
//        problem.AddParameterBlock(&pitch_other_all[flag_start], 1);
//        problem.AddParameterBlock(&roll_other_all[flag_start], 1);
        i_other = 0;
//        同上暂时注释的
//        problem.AddParameterBlock(r_global_all[flag_start], 4, local_parameterization);
////        problem.SetParameterBlockConstant(r_global_all[flag_start]);
//        problem.AddParameterBlock(t_global_all[flag_start], 3);
////        problem.SetParameterBlockConstant(t_global_all[flag_start]);
        ///
        problem.AddParameterBlock(quaterniond_relativeCurMain[flag_start], 4, local_parameterization);
        problem.AddParameterBlock(t_relativeCurMain[flag_start], 3);
        ceres::CostFunction* cost_function_relative = RelativeRTError_relative::Create(t_relativeCurMain[flag_start][0], t_relativeCurMain[flag_start][1], t_relativeCurMain[flag_start][2],quaterniond_relativeCurMain[flag_start][0],quaterniond_relativeCurMain[flag_start][1], quaterniond_relativeCurMain[flag_start][2], quaterniond_relativeCurMain[flag_start][3],10.0,1.0);
        problem.AddResidualBlock(cost_function_relative, NULL, quaterniond_relativeCurMain[flag_start],
                                 t_relativeCurMain[flag_start]);
        
        for (auto it_other = pMap_other->keyFrameList.begin(); it_other != pMap_other->keyFrameList.end(); it_other++)
        {
            //将关键帧列表中所有index>=earliest_loop_index的关键帧的位姿加入到参数块当中
            problem.AddParameterBlock(quaterniond_other_all[flag_start][i_other], 4, local_parameterization);
//            problem.AddParameterBlock(euler_other_all[flag_start][i_other], 1, angle_local_parameterization);
            problem.AddParameterBlock(t_other_all[flag_start][i_other], 3);
            
//            problem.SetParameterBlockConstant(quaterniond_other_all[flag_start][i_other]);

//            ceres::LocalParameterization *local_parameterization = new PoseQ_LocalParameterization();
//            problem.AddParameterBlock(r_global_all[flag_start][i_other], 4, local_parameterization);
//            problem.AddParameterBlock(t_global_all[flag_start][i_other], 3);
            
            if(resample_other_all[flag_start][i_other])
            {
               
                i_other++;
                continue;
            }
            
//            if(i_other>0){
//
//                ceres::CostFunction* cost_function = SixDOFWeightError_relativeR::Create( );
//                problem.AddResidualBlock(cost_function, NULL, r_global_all[flag_start][i_other-1],
//                                       r_global_all[flag_start][i_other]);
//
//
//                ceres::CostFunction* cost_function_t = SixDOFWeightError_relativet::Create( );
//                problem.AddResidualBlock(cost_function_t, NULL, t_global_all[flag_start][i_other-1],
//                                       t_global_all[flag_start][i_other]);
//            }


            int j = 1, sequence_link_cnt = 0;
            while(sequence_link_cnt < 5)
            {
                if (i_other - j >= 0)
                {

                    if(resample_other_all[flag_start][i_other-j])
                    {
                        j++;
                        continue;
                    }
                    else
                    {
                        sequence_link_cnt++;
                    }
                    Vector3d euler_conncected = Utility::R2ypr(q_other_all[flag_start][i_other-j].toRotationMatrix());
                    //p̂_j^w - p̂_i^w 计算平移量的偏差
                    Vector3d relative_t(t_other_all[flag_start][i_other][0] - t_other_all[flag_start][i_other-j][0], t_other_all[flag_start][i_other][1] - t_other_all[flag_start][i_other-j][1], t_other_all[flag_start][i_other][2] - t_other_all[flag_start][i_other-j][2]);
                    //p̂_{ij}^{i} = {R̂_i^w}^{-1} (p̂_j^w - p̂_i^w)
                    //p̂ ij= (R̂ iw ) (p̂ jw − p̂ iw )
                    relative_t = q_other_all[flag_start][i_other-j].inverse() * relative_t;
                    //ψ̂ _ij = ψ̂ _j − ψ̂ _i
                    double relative_yaw = euler_other_all[flag_start][i_other][0] - euler_other_all[flag_start][i_other-j][0];
//                    cout<<"其它地图序列帧relative_t："<<relative_t[0]<<" , "<<relative_t[1]<<" , "<<relative_t[2]<<endl;
//                    cout<<"其它地图序列帧euler_conncected："<<euler_conncected[0]<<" , "<<euler_conncected[1]<<" , "<<euler_conncected[2]<<endl;
//                    cout<<"其它地图序列帧relative_yaw："<<relative_yaw<<endl;
//                    ceres::CostFunction* cost_function = FourDOFError_another::Create( relative_t.x(), relative_t.y(), relative_t.z(),
//                                                                              relative_yaw, euler_conncected.y(), euler_conncected.z());
//                    problem.AddResidualBlock(cost_function, loss_function, euler_other_all[flag_start][i_other-j],
//                                             t_other_all[flag_start][i_other-j],
//                                             euler_other_all[flag_start][i_other],
//                                             t_other_all[flag_start][i_other]);
                    
                    Quaterniond relative_q=q_other_all[flag_start][i_other-j].inverse()*q_other_all[flag_start][i_other];
                    
                    double w_q_i[4],i_q_w[4],w_q_j[4],q_i_j[4];
                    w_q_i[0]=q_other_all[flag_start][i_other-j].w();
                    w_q_i[1]=q_other_all[flag_start][i_other-j].x();
                    w_q_i[2]=q_other_all[flag_start][i_other-j].y();
                    w_q_i[3]=q_other_all[flag_start][i_other-j].z();
                    QuaternionInverse(w_q_i, i_q_w);
                    w_q_j[0]=q_other_all[flag_start][i_other].w();
                    w_q_j[1]=q_other_all[flag_start][i_other].x();
                    w_q_j[2]=q_other_all[flag_start][i_other].y();
                    w_q_j[3]=q_other_all[flag_start][i_other].z();
                    ceres::QuaternionProduct(i_q_w, w_q_j, q_i_j);
//                    cout<<"relative_q 12862 q_i_j="<<q_i_j[0]<<" , "<<q_i_j[1]<<" , "<<q_i_j[2]<<" , "<<q_i_j[3]<<endl;
//
//                    cout<<"relative_q 12862 seq_kf="<<relative_q.w()<<" , "<<relative_q.x()<<" , "<<relative_q.y()<<" , "<<relative_q.z()<<endl;
                    double relative_q_double[4],relative_q_inv[4],error_q[4];
                    relative_q_double[0]=relative_q.w();
                    relative_q_double[1]=relative_q.x();
                    relative_q_double[2]=relative_q.y();
                    relative_q_double[3]=relative_q.z();
                    QuaternionInverse(relative_q_double, relative_q_inv);
                    ceres::QuaternionProduct(relative_q_inv, q_i_j, error_q);
                   
                    
                    if(fabs(error_q[1])>0.000001 || fabs(error_q[2])>0.000001 || fabs(error_q[3])>0.000001){
                        cout<<"relative_q 12862 error_q="<<error_q[0]<<" , "<<error_q[1]<<" , "<<error_q[2]<<" , "<<error_q[3]<<endl;
                        cout<<"数据不规范序列帧"<<endl;
                    }
                    
                    ceres::CostFunction* cost_function = RelativeRTError::Create(relative_t.x(), relative_t.y(), relative_t.z(),relative_q.w(), relative_q.x(), relative_q.y(), relative_q.z(),1.0,1.0);
                    problem.AddResidualBlock(cost_function, loss_function, quaterniond_other_all[flag_start][i_other-j], t_other_all[flag_start][i_other-j], quaterniond_other_all[flag_start][i_other],  t_other_all[flag_start][i_other]);
                }
                else
                {
                    break;
                }
                j++;
            }
          
            //        添加的是闭环边，是指检测到闭环的两帧 一个数据拆成两份 这个注释掉了
            if((*it_other)->is_get_loop_info)
            {
                //这里后面还要添加else
                if((*it_other)->loop_index <0)
                {
                    assert(false);
                }
                //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束
                int connected_index = pMap_other->getKeyframe((*it_other)->loop_index)->resample_globalIndex;

                Vector3d euler_conncected = Utility::R2ypr(q_other_all[flag_start][connected_index].toRotationMatrix());
                Vector3d relative_t((*it_other)->loop_info_better(0), (*it_other)->loop_info_better(1), (*it_other)->loop_info_better(2));
                double relative_yaw = (*it_other)->loop_info_better(3);
                
//                ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z());
//                problem.AddResidualBlock(cost_function, NULL, euler_other_all[flag_start][connected_index],
//                                         t_other_all[flag_start][connected_index],
//                                         euler_other_all[flag_start][i_other],
//                                         t_other_all[flag_start][i_other]);
                
                Quaterniond relative_q=(*it_other)->loop_info_better_q;
//                cout<<"relative_q 12895 loop_kf="<<relative_q.w()<<" , "<<relative_q.x()<<" , "<<relative_q.y()<<" , "<<relative_q.z()<<endl;
                ceres::CostFunction* cost_function = RelativeRTError::Create(relative_t.x(), relative_t.y(), relative_t.z(),relative_q.w(), relative_q.x(), relative_q.y(), relative_q.z(),10.0,1.0);
                problem.AddResidualBlock(cost_function, NULL, quaterniond_other_all[flag_start][connected_index],
                                         t_other_all[flag_start][connected_index],
                                         quaterniond_other_all[flag_start][i_other],
                                         t_other_all[flag_start][i_other]);
                
            }
           
            if((*it_other)->has_global_loop)
           {
    //           获取是和哪个其它地图发生了回环
              (*it_other)->readWriteLock_loop.readLock();
              int loop_index_flag_end=(*it_other)->clientId.size();
              (*it_other)->readWriteLock_loop.readUnLock();
    //           遍历该帧的 所有回环帧
              for(int loop_index_flag=0;loop_index_flag<loop_index_flag_end;loop_index_flag++){
                  (*it_other)->readWriteLock_loop.readLock();
                  int matching_clientId=(*it_other)->clientId[loop_index_flag];
                  int matching_kfId=(*it_other)->kfId[loop_index_flag];
                  std::pair<Matrix3d , Vector3d > matching_rt=(*it_other)->relativePose[loop_index_flag];
                  (*it_other)->readWriteLock_loop.readUnLock();
                  
//                  Vector3d euler_conncected = Utility::R2ypr(matching_rt.first);
//                  Vector3d relative_t=matching_rt.second;
//                  double relative_yaw = euler_conncected[0];
                  
                  if(matching_clientId==pMainMap->c->id){
                      if(matching_kfId < earliest_loop_index_main)
                      {
                          //因为这意味着数据保存出错了 发生了融合的帧的id小于最早发生融合的id
                          assert(false);
                          return;
                      }
                      //说明是和此次新增地图 发生匹配
                      //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束
                      int connected_index = pMainMap->getKeyframe(matching_kfId)->resample_globalIndex;
                      
//                      double relative_yaw =euler_conncected[0]-euler_array_main[connected_index][0];
                      
                      Vector3d euler_conncected = Utility::R2ypr(q_array_main[connected_index].toRotationMatrix());
                      Vector3d relative_t((*it_other)->relative_global_loop_info_multiClient[loop_index_flag](0), (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](1), (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](2));
                      double relative_yaw = (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](7);

                      //这里到时候 再写一个求导的
//                      ceres::CostFunction* cost_function1 = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z());
//                      problem.AddResidualBlock(cost_function1, NULL, euler_array_main[connected_index],
//                                               t_array_main[connected_index],
//                                               euler_other_all[flag_start][i_other],
//                                               t_other_all[flag_start][i_other]);
                      
//                      cout<<"relative_q="<<(*it_other)->relative_global_loop_info_multiClient[loop_index_flag](3)<<" , "<<(*it_other)->relative_global_loop_info_multiClient[loop_index_flag](4)<<" , "<<(*it_other)->relative_global_loop_info_multiClient[loop_index_flag](5)<<" , "<<(*it_other)->relative_global_loop_info_multiClient[loop_index_flag](6)<<endl;
//                      Eigen::Matrix<double, 8, 1 > relative_loop=(*it_other)->relative_global_loop_info_multiClient[loop_index_flag];
//                      cout<<"relative_loop="<<relative_loop<<endl;
                      double qw=(*it_other)->relative_global_loop_info_multiClient[loop_index_flag](3),qx=(*it_other)->relative_global_loop_info_multiClient[loop_index_flag](4),qy=(*it_other)->relative_global_loop_info_multiClient[loop_index_flag](5),qz=(*it_other)->relative_global_loop_info_multiClient[loop_index_flag](6);
                      Quaterniond relative_q(qw,qx ,qy ,qz );
//                      cout<<"relative_q 12951 globalloop_kf="<<relative_q.w()<<" , "<<relative_q.x()<<" , "<<relative_q.y()<<" , "<<relative_q.z()<<endl;
                      
                      
                        ceres::CostFunction* cost_function1 = RelativeRTError_3opti::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_q.w(), relative_q.x(), relative_q.y(), relative_q.z(),10.0,1.0);
                        problem.AddResidualBlock(cost_function1, NULL, quaterniond_array_main[connected_index], t_array_main[connected_index], quaterniond_other_all[flag_start][i_other], t_other_all[flag_start][i_other], quaterniond_relativeCurMain[flag_start], t_relativeCurMain[flag_start]);
                      
                      
//                      相对位姿当作先验乘进去
//                      ceres::CostFunction* cost_function1 = RelativeRTError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_q.w(), relative_q.x(), relative_q.y(), relative_q.z(),10.0,1.0);
//                      problem.AddResidualBlock(cost_function1, NULL, quaterniond_array_main[connected_index], t_array_main[connected_index], quaterniond_other_all[flag_start][i_other], t_other_all[flag_start][i_other]);
               

                      
//                      MultiClientFactor_merge *f = new MultiClientFactor_merge(relative_t, euler_conncected.y(), euler_conncected.z());
//                      problem.AddResidualBlock(f, NULL, euler_array_main[connected_index],
//                                               t_array_main[connected_index],t_other_all[flag_start][i_other] ,t_global_main_relative,r_global_main_relative ,t_global_all[flag_start][i_other] ,r_global_all[flag_start][i_other]);
//
//                      Vector3d euler_conncected_j = Utility::R2ypr(q_other_all[flag_start][i_other].toRotationMatrix());
//                      ceres::CostFunction* cost_function = EightDOFWeightError_yaw::Create( relative_yaw, euler_conncected.y(), euler_conncected.z(),euler_conncected_j.y(),euler_conncected_j.z());
//                    problem.AddResidualBlock(cost_function, NULL, euler_array_main[connected_index],euler_other_all[flag_start][i_other],r_global_main_relative ,r_global_all[flag_start][i_other]);
                      
//                      同上暂时注释的
//                      MultiClientFactor_merge *f = new MultiClientFactor_merge(relative_t, euler_conncected.y(), euler_conncected.z());
//                      problem.AddResidualBlock(f, NULL, euler_array_main[connected_index],
//                                               t_array_main[connected_index],t_other_all[flag_start][i_other] ,t_global_main_relative,r_global_main_relative ,t_global_all[flag_start] ,r_global_all[flag_start]);
//
//                      Vector3d euler_conncected_j = Utility::R2ypr(q_other_all[flag_start][i_other].toRotationMatrix());
//                      ceres::CostFunction* cost_function = EightDOFWeightError_yaw::Create( relative_yaw, euler_conncected.y(), euler_conncected.z(),euler_conncected_j.y(),euler_conncected_j.z());
//                    problem.AddResidualBlock(cost_function, NULL, euler_array_main[connected_index],euler_other_all[flag_start][i_other],r_global_main_relative ,r_global_all[flag_start]);
                      
                  }else{
                      int vmap_index=vMapId_all[matching_clientId];
                      if(matching_kfId < earliest_loopIndex_other_all[vmap_index])
                      {
                          //因为这意味着数据保存出错了 发生了融合的帧的id小于最早发生融合的id
                          assert(false);
                          return;
                      }
                      
        //               找到这个对应的其它地图
                      PoseGraph * pMap_fuse=vMap_all[vmap_index];
                      //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束 会出现空指针的问题
                      int connected_index = pMap_fuse->getKeyframe(matching_kfId)->resample_globalIndex;//这里可能多个
                        
    //                  double relative_yaw =euler_conncected[0]-euler_other_all[vmap_index][connected_index][0];
                      
                      Vector3d euler_conncected = Utility::R2ypr(q_other_all[vmap_index][connected_index].toRotationMatrix());
                      Vector3d relative_t((*it_other)->relative_global_loop_info_multiClient[loop_index_flag](0), (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](1), (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](2));
                      double relative_yaw = (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](7);

                       //这里到时候 再写一个求导的
//                       ceres::CostFunction* cost_function1 = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z());
//                       problem.AddResidualBlock(cost_function1, NULL, euler_other_all[vmap_index][connected_index],
//                                            t_other_all[vmap_index][connected_index],
//                                            euler_other_all[flag_start][i_other],
//                                            t_other_all[flag_start][i_other]);
                      double qw=(*it_other)->relative_global_loop_info_multiClient[loop_index_flag](3),qx=(*it_other)->relative_global_loop_info_multiClient[loop_index_flag](4),qy=(*it_other)->relative_global_loop_info_multiClient[loop_index_flag](5),qz=(*it_other)->relative_global_loop_info_multiClient[loop_index_flag](6);
                      Quaterniond relative_q(qw,qx , qy, qz);
//                      cout<<"relative_q 13000 globalloop_kf="<<relative_q.w()<<" , "<<relative_q.x()<<" , "<<relative_q.y()<<" , "<<relative_q.z()<<endl;
                      ceres::CostFunction* cost_function1 = RelativeRTError_3opti::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_q.w(), relative_q.x(), relative_q.y(), relative_q.z(),10.0,1.0);
                      problem.AddResidualBlock(cost_function1, NULL, quaterniond_other_all[vmap_index][connected_index],  t_other_all[vmap_index][connected_index],  quaterniond_other_all[flag_start][i_other], t_other_all[flag_start][i_other], quaterniond_relativeCurMain[flag_start], t_relativeCurMain[flag_start]);
                      
                      
//                      MultiClientFactor_merge *f = new MultiClientFactor_merge(relative_t, euler_conncected.y(), euler_conncected.z());
//                      problem.AddResidualBlock(f, NULL, euler_other_all[vmap_index][connected_index],
//                                                 t_other_all[vmap_index][connected_index] ,t_other_all[flag_start][i_other],t_global_all[vmap_index][connected_index],r_global_all[vmap_index][connected_index] ,t_global_all[flag_start][i_other],r_global_all[flag_start][i_other]);
//
//                      Vector3d euler_conncected_j = Utility::R2ypr(q_other_all[flag_start][i_other].toRotationMatrix());
//                      ceres::CostFunction* cost_function = EightDOFWeightError_yaw::Create( relative_yaw, euler_conncected.y(), euler_conncected.z(),euler_conncected_j.y(),euler_conncected_j.z());
//                    problem.AddResidualBlock(cost_function, NULL, euler_other_all[vmap_index][connected_index] ,euler_other_all[flag_start][i_other] , r_global_all[vmap_index][connected_index] ,r_global_all[flag_start][i_other]);
                      
//                      同上暂时注释的
//                      MultiClientFactor_merge *f = new MultiClientFactor_merge(relative_t, euler_conncected.y(), euler_conncected.z());
//                      problem.AddResidualBlock(f, NULL, euler_other_all[vmap_index][connected_index],
//                                                 t_other_all[vmap_index][connected_index] ,t_other_all[flag_start][i_other],t_global_all[vmap_index] ,r_global_all[vmap_index] ,t_global_all[flag_start] ,r_global_all[flag_start] );
//
//                      Vector3d euler_conncected_j = Utility::R2ypr(q_other_all[flag_start][i_other].toRotationMatrix());
//                      ceres::CostFunction* cost_function = EightDOFWeightError_yaw::Create( relative_yaw, euler_conncected.y(), euler_conncected.z(),euler_conncected_j.y(),euler_conncected_j.z());
//                    problem.AddResidualBlock(cost_function, NULL, euler_other_all[vmap_index][connected_index] ,euler_other_all[flag_start][i_other] , r_global_all[vmap_index]  ,r_global_all[flag_start] );
                  }
                  
                  
              }
           }
            if ((*it_other)->global_index == latest_loopIndex_other_all[flag_start])
                break;
            i_other++;
          
        }

    }
    
    ceres::Solve(options, &problem, &summary);
    
    std::cout << "global fuse: "<<summary.BriefReport() << "\n";
    if(summary.termination_type!=ceres::CONVERGENCE){
        
        return;
    }
    
    pMainMap->special_kf_mutex.lock();
    pMainMap->add2_kf_id_hasComPlace_withOtherMap(kf_id_hasComPlace_main);
    pMainMap->special_kf_inOpti.push(special_kf_inOpti_main);
    pMainMap->special_kf_mutex.unlock();
    pMainMap->loop_index_multiClient.push(earliest_loop_index_main);
    pMainMap->curKF_loop_index_multiClient.push(latest_loop_index_main);//这个是要发回客户端 用来更新位姿的 TODO 后面要改改
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
        vector<int> special_kf_inOpti_cur=special_kf_inOpti_cur_all[flag_start];
        vector<int> kf_id_hasCom_cur=kf_id_hasCom_cur_all[flag_start];
        pMap_other->special_kf_mutex.lock();
        pMap_other->add2_kf_id_hasComPlace_withOtherMap(kf_id_hasCom_cur);
        pMap_other->special_kf_inOpti.push(special_kf_inOpti_cur);
        pMap_other->special_kf_mutex.unlock();
        
        int latest_loop_index=latest_loop_index_other_correct[flag_start];
        pMap_other->isFirstFusion_globalMutex.lock();
        pMap_other->loop_index_multiClient.push(0);
        pMap_other->curKF_loop_index_multiClient.push(latest_loop_index);
        pMap_other->isFirstFusion_globalMutex.unlock();
    }
    //------------------------------------------第一个数据优化后更新
    //优化完成，使用优化后的位姿来更新关键帧列表中index大于等于earliest_loop_index的所有关键帧的位姿
    
    Vector3d t_drift_it_other = Vector3d::Zero();
    Matrix3d r_drift_it_other = Matrix3d::Identity();
    
    vector<Matrix3d> r_global_cur;
    vector<Vector3d> t_global_cur;
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
        list<KeyFrame*>::iterator it_other = pMap_other->keyFrameList.begin();
        i_other = 0;
        r_global_cur.clear();
        t_global_cur.clear();
        for (; it_other != pMap_other->keyFrameList.end(); it_other++)
        {
            
//            Quaterniond tmp_q;
//            //向量转换为矩阵
//            tmp_q = Utility::ypr2R(Vector3d(euler_other_all[flag_start][i_other][0], euler_other_all[flag_start][i_other][1], euler_other_all[flag_start][i_other][2]));
            Quaterniond tmp_q(quaterniond_other_all[flag_start][i_other][0],quaterniond_other_all[flag_start][i_other][1],quaterniond_other_all[flag_start][i_other][2],quaterniond_other_all[flag_start][i_other][3]);
            Vector3d tmp_w1_t = Vector3d(t_other_all[flag_start][i_other][0], t_other_all[flag_start][i_other][1], t_other_all[flag_start][i_other][2]);
            Matrix3d tmp_w1_r = tmp_q.toRotationMatrix();
            
         
           
            if(resample_other_all[flag_start][i_other])
            {
//有先验的位姿更新
                Vector3d origin_t_it;
                Matrix3d origin_r_it;
                (*it_other)->getOriginPose(origin_t_it, origin_r_it);
                (*it_other)-> updatePose(r_drift_it_other * origin_t_it + t_drift_it_other, r_drift_it_other * origin_r_it);
                
//                无先验的位姿更新
//                (*it_other)-> updatePose(r_drift_it_other * tmp_w1_t + t_drift_it_other, r_drift_it_other * tmp_w1_r);
            }
            else
            {
                Vector3d origin_t_it;
                Matrix3d origin_r_it;
                (*it_other)->getOriginPose(origin_t_it, origin_r_it);
                
                
                r_drift_it_other = tmp_w1_r * origin_r_it.transpose();
                t_drift_it_other = tmp_w1_t - r_drift_it_other * origin_t_it;
                (*it_other)->updatePose(tmp_w1_t, tmp_w1_r);
                
    //            pCurMap->add2_r_global_multiClient(tmp_w1_r);
    //            pCurMap->add2_t_global_multiClient(tmp_w1_t);
                r_global_cur.push_back(tmp_w1_r);
                t_global_cur.push_back(tmp_w1_t);
            }
            if ((*it_other)->global_index == latest_loopIndex_other_all[flag_start])
                break;
            i_other++;
            
        }
        //如果将地图建模成可变形的呢
        //根据计算出当前帧的drift，更新全部关键帧位姿
        Vector3d cur_t_other, origin_t_other;
        Matrix3d cur_r_other, origin_r_other;
        //获取优化后当前帧的位姿cur_t,cur_r
        (*it_other)->getPose(cur_t_other, cur_r_other);
        //获取优化前有漂移的当前帧的位姿vio_t,vio_r
        (*it_other)->getOriginPose(origin_t_other, origin_r_other);
        pMap_other->yaw_drift = Utility::R2ypr(cur_r_other).x() - Utility::R2ypr(origin_r_other).x();
//        pMap_other->r_drift = Utility::ypr2R(Vector3d(pMap_other->yaw_drift, 0, 0));
        pMap_other->r_drift = cur_r_other*origin_r_other.transpose();
        pMap_other->t_drift = cur_t_other - pMap_other->r_drift * origin_t_other;
        
    //    pCurMap->add2_r_global_multiClient(pCurMap->r_drift);
    //    pCurMap->add2_t_global_multiClient(pCurMap->t_drift);
        r_global_cur.push_back(pMap_other->r_drift);
        t_global_cur.push_back(pMap_other->t_drift);
        pMap_other->add2_r_global_multiClient(r_global_cur);
        pMap_other->add2_t_global_multiClient(t_global_cur);
        if((r_global_cur.size()-1)!=pMap_other->special_kf_inOpti.back().size() && (r_global_cur.size()-1)!=(t_global_cur.size()-1)){
            cout<<"当前地图id"<<pMap_other->c->id<<" , "<<latest_loopIndex_other_all[flag_start]<<endl;
            cout<<"resample下标数量不一致："<<r_global_cur.size()<<" , "<<pMap_other->special_kf_inOpti.back().size()<<" , "<<t_global_cur.size()<<endl;
//            while (pMap_other->special_kf_inOpti.size()!=2)
//            {
//                cout << pMap_other->special_kf_inOpti.front().size()<< " "; // Output the 1st element
//                pMap_other->special_kf_inOpti.pop();  // Delete the 1st element
//            }
//            std::cout << std::endl;
//            cout << "倒数第二个："<<pMap_other->special_kf_inOpti.front().size()<< endl;
            assert(false);//20 38
        }

        //下面代码为把当前关键帧it之后的关键帧的位姿通过求解的偏移量转换到world坐标系下
        for (; it_other != pMap_other->keyFrameList.end(); it_other++)
        {
            Vector3d P;
            Matrix3d R;
            (*it_other)->getOriginPose(P, R);
            P = pMap_other->r_drift * P + pMap_other->t_drift;
            R = pMap_other->r_drift * R;
            (*it_other)-> updatePose(P, R);
        }
        pMap_other->lastKF_index.push(pMap_other->keyFrameList.back()->global_index);
    }
    
    
    
    //---------------------------------------第2个数据的更新
    //优化完成，使用优化后的位姿来更新关键帧列表中index大于等于earliest_loop_index的所有关键帧的位姿
    i_main = 0;
    Vector3d t_drift_it_main = Vector3d::Zero();
    Matrix3d r_drift_it_main = Matrix3d::Identity();
    
    vector<Matrix3d> r_global_main;
    vector<Vector3d> t_global_main;
    for (it_main = pMainMap->keyFrameList.begin(); it_main != pMainMap->keyFrameList.end(); it_main++)
    {
        if ((*it_main)->global_index < earliest_loop_index_main)
            continue;

//        Quaterniond tmp_q;
//        //向量转换为矩阵
//        tmp_q = Utility::ypr2R(Vector3d(euler_array_main[i_main][0], euler_array_main[i_main][1], euler_array_main[i_main][2]));
        Quaterniond tmp_q(quaterniond_array_main[i_main][0],quaterniond_array_main[i_main][1],quaterniond_array_main[i_main][2],quaterniond_array_main[i_main][3]);
        
        Vector3d tmp_w1_t = Vector3d(t_array_main[i_main][0], t_array_main[i_main][1], t_array_main[i_main][2]);
        Matrix3d tmp_w1_r = tmp_q.toRotationMatrix();

//                cout<<"测试 优化完成 更新哪里变了："<<euler_array_main[i_main][0]<<" "<<euler_array_main[i_main][1]<<" "<<euler_array_main[i_main][2]<<" "<<t_array_main[i_main][0]<<" "<<t_array_main[i_main][1]<<" "<<t_array_main[i_main][2]<<" "<<i_main<<endl;
        if(need_resample_main[i_main])
        {
            (*it_main)-> updatePose(r_drift_it_main * tmp_w1_t + t_drift_it_main, r_drift_it_main * tmp_w1_r);
        }
        else
        {
            Vector3d origin_t_it;
            Matrix3d origin_r_it;
            (*it_main)->getOriginPose(origin_t_it, origin_r_it);
            r_drift_it_main = tmp_w1_r * origin_r_it.transpose();
            t_drift_it_main = tmp_w1_t - r_drift_it_main * origin_t_it;
            (*it_main)-> updatePose(tmp_w1_t, tmp_w1_r);
            
//            pMainMap->add2_r_global_multiClient(tmp_w1_r);
//            pMainMap->add2_t_global_multiClient(tmp_w1_t);
            r_global_main.push_back(tmp_w1_r);
            t_global_main.push_back(tmp_w1_t);

        }
        if ((*it_main)->global_index == latest_loop_index_main)
            break;
        i_main++;

    }
    //根据计算出当前帧的drift，更新全部关键帧位姿
    Vector3d cur_t_main, origin_t_main;
    Matrix3d cur_r_main, origin_r_main;
    //获取优化后当前帧的位姿cur_t,cur_r
    (*it_main)->getPose(cur_t_main, cur_r_main);
    //获取优化前有漂移的当前帧的位姿vio_t,vio_r
    (*it_main)->getOriginPose(origin_t_main, origin_r_main);
    pMainMap->yaw_drift = Utility::R2ypr(cur_r_main).x() - Utility::R2ypr(origin_r_main).x();
//    pMainMap->r_drift = Utility::ypr2R(Vector3d(pMainMap->yaw_drift, 0, 0));
    pMainMap->r_drift = cur_r_main*origin_r_main.transpose();
    pMainMap->t_drift = cur_t_main - pMainMap->r_drift * origin_t_main;
    
//    pMainMap->add2_r_global_multiClient(pMainMap->r_drift);
//    pMainMap->add2_t_global_multiClient(pMainMap->t_drift);
    r_global_main.push_back(pMainMap->r_drift);
    t_global_main.push_back(pMainMap->t_drift);
    pMainMap->add2_r_global_multiClient(r_global_main);
    pMainMap->add2_t_global_multiClient(t_global_main);
    
    if((r_global_main.size()-1)!=pMainMap->special_kf_inOpti.back().size()  && (r_global_main.size()-1)!=(t_global_main.size()-1)){
        cout<<"当前地图id"<<pMainMap->c->id<<" , "<<latest_loop_index_main<<endl;
        cout<<"resample_main下标数量不一致："<<r_global_main.size()<<" , "<<pMainMap->special_kf_inOpti.back().size()<<" , "<<t_global_main.size()<<endl;
//        while (pMainMap->special_kf_inOpti.size()!=2)
//        {
//            cout << pMainMap->special_kf_inOpti.front().size()<< " "; // Output the 1st element
//            pMainMap->special_kf_inOpti.pop();  // Delete the 1st element
//        }
//        std::cout << std::endl;
//        cout << "倒数第二个："<<pMainMap->special_kf_inOpti.front().size()<< endl;
        assert(false);//20 38
    }
    

    //下面代码为把当前关键帧it之后的关键帧的位姿通过求解的偏移量转换到world坐标系下
    for (; it_main != pMainMap->keyFrameList.end(); it_main++)
    {
        Vector3d P;
        Matrix3d R;
        (*it_main)->getOriginPose(P, R);
        P = pMainMap->r_drift * P + pMainMap->t_drift;
        R = pMainMap->r_drift * R;
        (*it_main)-> updatePose(P, R);
    }
    
//    pCurMap->isFirstFusion_globalMutex.unlock();
    
    
    
    
    
    pMainMap->lastKF_index.push(pMainMap->keyFrameList.back()->global_index);
//            位姿更新都留到显示那里
    pMainMap->updateVisualization();
    
    readWriteLock.readLock();
    PoseGraph* pMainMap_0=PoseGraphGloabl_map[0];
    readWriteLock.readUnLock();
    
   
    pAddKfMap->refine_path_mutex.lock();
    if(isUpdateFusionDraw){
        pMainMap_0->fusion_relative_isUpdate[pMainMap->c->id]=0;
        pMainMap_0->fusion_poseGraph_mutex.lock();
        pMainMap_0->fusion_otherGraph[pMainMap->c->id]=pMainMap;
        pMainMap_0->fusion_poseGraph_mutex.unlock();
    }
    pAddKfMap->refine_path_mutex.unlock();
    
    
    
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
        pMap_other->updateVisualization();
        pMap_other->isSendGloablData_multiClient=true;
        
        pAddKfMap->refine_path_mutex.lock();
        if(isUpdateFusionDraw){
            pMainMap_0->fusion_relative_isUpdate[pMap_other->c->id]=0;
            pMainMap_0->fusion_poseGraph_mutex.lock();
            pMainMap_0->fusion_otherGraph[pMap_other->c->id]=pMap_other;
            pMainMap_0->fusion_poseGraph_mutex.unlock();
        }
        pAddKfMap->refine_path_mutex.unlock();
        
        
        delete [](t_other_all[flag_start][0]);
        delete [](t_other_all[flag_start][1]);
        delete [](t_other_all[flag_start][2]);
        delete [](t_other_all[flag_start]);
        delete [](euler_other_all[flag_start][0]);
        delete [](euler_other_all[flag_start][1]);
        delete [](euler_other_all[flag_start][2]);
        delete [](euler_other_all[flag_start]);
        delete [](quaterniond_other_all[flag_start][0]);
        delete [](quaterniond_other_all[flag_start][1]);
        delete [](quaterniond_other_all[flag_start][2]);
        delete [](quaterniond_other_all[flag_start][3]);
        delete [](quaterniond_other_all[flag_start]);
        
//        delete [](t_relativeCurMain[flag_start][0]);
//        delete [](t_relativeCurMain[flag_start][1]);
//        delete [](t_relativeCurMain[flag_start][2]);
//        delete [](t_relativeCurMain[flag_start]);
//        delete [](quaterniond_relativeCurMain[flag_start][0]);
//        delete [](quaterniond_relativeCurMain[flag_start][1]);
//        delete [](quaterniond_relativeCurMain[flag_start][2]);
//        delete [](quaterniond_relativeCurMain[flag_start][3]);
//        delete [](quaterniond_relativeCurMain[flag_start]);
        
//        for(int i=0;i<3;i++){
//            delete [](t_global_all[flag_start][i]);
//        }
//        delete [](t_global_all[flag_start]);
//        for(int i=0;i<4;i++){
//            delete [](r_global_all[flag_start][i]);
//        }
//        delete [](r_global_all[flag_start]);
              
    }
    //发送数据
    pMainMap->isSendGloablData_multiClient=true;
    
    //    TODO 用来多用户ar 发送ar位姿的
        pAddKfMap->isFirstFusion_globalMutex.lock();
        isFusion[i]=1;
        pAddKfMap->isFirstFusion_globalMutex.unlock();

    cout<<"最终的全局优化结束"<<i<<endl;
//    cout<<"测试 偏移对不对"<<pCurMap->t_drift[0]<<" "<<pCurMap->t_drift[1]<<" "<<pCurMap->t_drift[2]<<endl;
//    cout<<"主地图为："<<pMainMap->c->id<<endl;
//    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
//        cout<<"t:"<<t_global_all[flag_start][0]<<" , "<<t_global_all[flag_start][1]<<" , "<<t_global_all[flag_start][2]<<endl;
//        // roll (x-axis rotation)
//            double sinr_cosp = 2 * (r_global_all[flag_start][3] * r_global_all[flag_start][0] + r_global_all[flag_start][1] * r_global_all[flag_start][2]);
//            double cosr_cosp = 1 - 2 * (r_global_all[flag_start][0] * r_global_all[flag_start][0] + r_global_all[flag_start][1] * r_global_all[flag_start][1]);
//            double roll = std::atan2(sinr_cosp, cosr_cosp);
//
//            // pitch (y-axis rotation)
//            double sinp = 2 * (r_global_all[flag_start][3] * r_global_all[flag_start][1] - r_global_all[flag_start][2] * r_global_all[flag_start][0]);
//            double pitch;
//            if (std::abs(sinp) >= 1)
//                pitch = std::copysign(M_PI / 2, sinp); // use 90 degrees if out of range
//            else
//                pitch = std::asin(sinp);
//
//            // yaw (z-axis rotation)
//            double siny_cosp = 2 * (r_global_all[flag_start][3]* r_global_all[flag_start][2] + r_global_all[flag_start][0] * r_global_all[flag_start][1]);
//            double cosy_cosp = 1 - 2 * (r_global_all[flag_start][1] * r_global_all[flag_start][1] + r_global_all[flag_start][2] * r_global_all[flag_start][2]);
//            double yaw = std::atan2(siny_cosp, cosy_cosp);
//
//        cout<<"r:"<< yaw <<" , " <<pitch<<" , " <<roll<<endl;
//    }
    
}

//void PoseGraphGlobal::setFeatureMap(FeatureMap* _global_featureMap){
//    global_featureMap=_global_featureMap;
//}


void PoseGraphGlobal::GlobalFuse_13(int i){
    cout<<"最终的全局优化"<<i<<endl;
    bool isUpdateFusionDraw=false;
//    cout<<"死锁没"<<endl;
    //因为现在写的都是和主地图发生地图融合 所以其中一个地图直接这么获取了
//    poseGraphGlobal_mutex.lock();
    readWriteLock.readLock();
    map<int,PoseGraph*>::iterator iter_map = PoseGraphGloabl_map.find(i);
    if(iter_map==PoseGraphGloabl_map.end())
    {
//        poseGraphGlobal_mutex.unlock();
        readWriteLock.readUnLock();
        assert(false);//都已经发生回环了，却找不到地图 说明数据插错
    }
    PoseGraph* pAddKfMap= iter_map->second;
    int len = PoseGraphGloabl_map.size();
    readWriteLock.readUnLock();
    
    vector<std::unique_lock<std::mutex>* > lock_all;
    std::unique_lock<std::mutex> lock(pAddKfMap->keyFrameList_global_fusion_mutex, std::defer_lock);
    if (lock.try_lock()) {
        cout<<"加锁："<<pAddKfMap->c->id<<endl;
        lock_all.push_back(&lock);
    } else {
        cout<<"最终的全局优化中断"<<i<<endl;
        return;
    }
    if(i==mainClientID){
        isUpdateFusionDraw=true;
    }


    
    double total_lenth_other=0.0;
    vector< double> length_other;
    PoseGraph* pMainMap;//id最小的
    vector<PoseGraph *> vMap_all;//除id最小,也就是匹配上的全部其它地图
    map<int,int> vMapId_all;//int表示clientId 后面表示存放在vMap_all的下标
    //找其它融合的地图 一起参与优化
    bool isFindMinClient=true;
    readWriteLock.readLock();
    if(PoseGraphGloabl_map.size()>1){
        readWriteLock.readUnLock();
        for(int client_id=0;client_id<len;client_id++){//这里的i其实代表的就是 ClientId
            if(client_id==i){
                continue;
            }
            if(uf.isConnected(i, client_id)){
                readWriteLock.readLock();
                map<int,PoseGraph*>::iterator iter_map_other = PoseGraphGloabl_map.find(client_id);
                if(iter_map_other==PoseGraphGloabl_map.end()){
                    readWriteLock.readUnLock();
                    continue;
                }
                PoseGraph* pOtherMap= iter_map_other->second;//新的地图 小的地图
                readWriteLock.readUnLock();
                
                
                std::unique_lock<std::mutex> lock(pOtherMap->keyFrameList_global_fusion_mutex, std::defer_lock);
                if (lock.try_lock()) {
                    cout<<"加锁："<<pOtherMap->c->id<<endl;
                    lock_all.push_back(&lock);
                } else {
                    //                    把之前锁住了的解锁了
                    cout<<"最终的全局优化中断"<<pOtherMap->c->id<<endl;
                    return;
                }
         
                
                if(isFindMinClient){
                    isFindMinClient=false;
                    if(i>client_id){
//                        这里就是id最小的地图
                        pMainMap=pOtherMap;
//                        cout<<"主地图大小："<<pMainMap->size()<<endl;
                      
                        vMap_all.push_back(pAddKfMap);
                        vMapId_all.insert(make_pair(pAddKfMap->c->id,vMap_all.size()-1));
                        total_lenth_other+=pAddKfMap->total_length;
                        length_other.push_back(pAddKfMap->total_length);
                        
                        if(client_id==mainClientID){
                            isUpdateFusionDraw=true;
                        }
                        continue;
                    }else{
                        pMainMap=pAddKfMap;
                    }
                }
                vMap_all.push_back(pOtherMap);
                vMapId_all.insert(make_pair(pOtherMap->c->id,vMap_all.size()-1));
                
                total_lenth_other+=pOtherMap->total_length;
                length_other.push_back(pOtherMap->total_length);
                
            }
            
        }
    }
    else{
        readWriteLock.readUnLock();
        assert(false);//都要发生全局优化了 却只有1个地图
    }
    
   
    
    //主地图从earliest_loop_index_main开始--当前帧结束
    //小地图从第一帧开始--当前发生回环的帧 这个有可能是回环帧，也有可能是融合帧
    ceres::Problem problem;
    ceres::Solver::Options options;
    //options.linear_solver_type = ceres::DENSE_NORMAL_CHOLESKY;
    options.linear_solver_type = ceres::DENSE_SCHUR;
    options.minimizer_progress_to_stdout = false;
    options.max_num_iterations = 15;
    ceres::Solver::Summary summary;
    ceres::LossFunction *loss_function;
    loss_function = new ceres::HuberLoss(1.0);
    //AngleLocalParameterization类的主要作用是指定yaw角优化变量的迭代更新，重载了括号运算
    ceres::LocalParameterization* angle_local_parameterization =
    AngleLocalParameterization::Create();
            
    
    double total_lenth_main=pMainMap->total_length;
    //总的位姿长度 除以总的帧数
    double total_lenth_sum=total_lenth_main+total_lenth_other;
    int max_frame_num_global_main=(total_lenth_main/total_lenth_sum)*max_frame_num_global;
    double min_dis_main=total_lenth_main/max_frame_num_global_main;
    
    //要优化的变量的最大个数 主地图
    int max_length_main=pMainMap->size()+1;
    double t_array_main[max_length_main][3];//平移数组，其中存放每个关键帧的平移向量
    Quaterniond q_array_main[max_length_main];
    double euler_array_main[max_length_main][3];
    vector<bool> need_resample_main;
    
//    double rt_global_main[7]={0};//为单位矩阵
//    rt_global_main[6]=1;
    double t_global_main_relative[3]={0};//为单位矩阵
    double r_global_main_relative[4]={0};//为单位矩阵
    r_global_main_relative[3]=1;
    
    pMainMap->max_frame_num_global=max_frame_num_global_main;
    pMainMap->min_dis=min_dis_main;
    

    const int mapOther_sum=vMap_all.size();
    vector< double** > t_other_all;
    vector< vector<Quaterniond > > q_other_all;
    vector< double** > euler_other_all;//里面存储的是度数  不是弧度
    vector< vector<bool> > resample_other_all;
    
//    vector< double > pitch_other_all;
//    vector< double > roll_other_all;
//    这个后续记录在帧内部
//    vector< double** > rt_global_all;
    
//    这个是每一帧都有一个rt
//    vector< double** > t_global_all;
//    vector< double** > r_global_all;
    
//    这个是每一地图都有一个rt
    vector< double* > t_global_all;
    vector< double* > r_global_all;
    
    int main_clientId=pMainMap->c->id;
    
    pMainMap->loop_index_mutex.lock();
    int earliest_loop_index_main=pMainMap->earliest_loop_index;
    int earliest_global_looped_index_main=earliest_globalLoop_index[pMainMap->c->id];
    int latest_loop_index_main=pMainMap->latest_loop_index;
    int latest_global_looped_index_main=latest_globalLoop_index[pMainMap->c->id];
    pMainMap->loop_index_mutex.unlock();
    
    if (earliest_loop_index_main > earliest_global_looped_index_main || earliest_loop_index_main == -1  )
        earliest_loop_index_main=earliest_global_looped_index_main;
    
    
    if (latest_global_looped_index_main > latest_loop_index_main)
        latest_loop_index_main=latest_global_looped_index_main;
//    pMainMap->loop_index_multiClient.push(earliest_loop_index_main);
//    pMainMap->curKF_loop_index_multiClient.push(latest_loop_index_main);//这个是要发回客户端 用来更新位姿的 TODO 后面要改改
    vector<int> latest_loop_index_other_correct;
    vector<int> earliest_loopIndex_other_all;
    vector<int> latest_loopIndex_other_all;
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
        
        pMap_other->loop_index_mutex.lock();
        int earliest_loop_index_other=pMap_other->earliest_loop_index;
        int earliest_global_looped_index_other=earliest_globalLoop_index[pMap_other->c->id];
        int latest_loop_index_other=pMap_other->latest_loop_index;
        int latest_global_looped_index_other=latest_globalLoop_index[pMap_other->c->id];
        pMap_other->loop_index_mutex.unlock();
        
        if (earliest_loop_index_other > earliest_global_looped_index_other || earliest_loop_index_other == -1  )
            earliest_loop_index_other=earliest_global_looped_index_other;
        earliest_loopIndex_other_all.push_back(earliest_loop_index_other);
        
        
        if (latest_global_looped_index_other > latest_loop_index_other)
            latest_loop_index_other=latest_global_looped_index_other;
        latest_loopIndex_other_all.push_back(latest_loop_index_other);
        
//        pMap_other->isFirstFusion_globalMutex.lock();
//        pMap_other->loop_index_multiClient.push(0);
//        pMap_other->curKF_loop_index_multiClient.push(latest_loop_index_other);
//        pMap_other->isFirstFusion_globalMutex.unlock();
        latest_loop_index_other_correct.push_back(latest_loop_index_other);
        
        double total_length_otherMap=length_other[flag_start];
        int max_frame_num_global_other=(total_length_otherMap/total_lenth_sum)*max_frame_num_global;
        double min_dis_other=total_length_otherMap/max_frame_num_global_other;
        pMap_other->max_frame_num_global=max_frame_num_global_other;
        pMap_other->min_dis=min_dis_other;
        
        //要优化的变量的最大个数 小地图
        int max_length_other=pMap_other->keyFrameList.size()+1;
        double** t_test=new double*[max_length_other];
        for(int index_flag=0;index_flag<max_length_other;index_flag++) t_test[index_flag] = new double[3];
        t_other_all.push_back(t_test);
        
        vector<Quaterniond > q_array_other(max_length_other);
        q_other_all.push_back(q_array_other);
        
        double** euler_test=new double*[max_length_other];
        for(int index_flag=0;index_flag<max_length_other;index_flag++) euler_test[index_flag] = new double[3];
        euler_other_all.push_back(euler_test);
        
        vector<bool> need_resample_other;
        resample_other_all.push_back(need_resample_other);
        
//        double** t_global_test=new double*[max_length_other];
//        double** r_global_test=new double*[max_length_other];
//        for(int index_flag=0;index_flag<max_length_other;index_flag++){
//            t_global_test[index_flag] = new double[3];
//            r_global_test[index_flag] = new double[4];
//            r_global_test[index_flag][3]=1;
//
//            for(int hh=0;hh<3;hh++){
//                t_global_test[index_flag][hh]=0;
//                r_global_test[index_flag][hh]=0;
//            }
//        }
//        t_global_all.push_back(t_global_test);
//        r_global_all.push_back(r_global_test);
        
        double t_global_test[3]={0};
        double r_global_test[4]={0};
        r_global_test[3]=1;
        t_global_all.push_back(t_global_test);
        r_global_all.push_back(r_global_test);
    }
   
    //*************************************遍历数据 记录要参与优化的

    vector<int> special_kf_inOpti_main;
    vector<int> kf_id_hasComPlace_main;
    //遍历关键帧列表
    list<KeyFrame*>::iterator it_main = pMainMap->keyFrameList.begin();
    Vector3d last_P_main = Vector3d(0, 0, 0);
    double dis_main = 0;
    int resample_id=0;
    for(;it_main!=pMainMap->keyFrameList.end();it_main++){
        if((*it_main)->global_index < earliest_loop_index_main){
            continue;
        }
        (*it_main)->resample_globalIndex = resample_id;
        Vector3d tmp_t;
        Matrix3d tmp_r;
        //获取关键帧it的位姿
        (*it_main)->getPose(tmp_t, tmp_r);
        dis_main += (tmp_t - last_P_main).norm();
        //全局优化 还是要加序列边 不然太长了 判断条件 再加个两个地图之间发生了融合
        if((*it_main)->global_index == earliest_loop_index_main || dis_main > min_dis_main || (*it_main)->is_get_loop_info || (*it_main)->is_looped || (*it_main)->has_global_loop || (*it_main)->is_global_looped || pMainMap->keyFrameList.size() < max_frame_num_global_main)
        {
            dis_main = 0;
            last_P_main = tmp_t;
            need_resample_main.push_back(0);
            
//            pMainMap->special_kf_inOpti.push_back((*it_main)->global_index);
            special_kf_inOpti_main.push_back((*it_main)->global_index);
            
            if(((*it_main)->has_global_loop || (*it_main)->is_global_looped) && (*it_main)->is_Send==false ){
                kf_id_hasComPlace_main.push_back((*it_main)->global_index);
//                pMainMap->add2_kf_id_hasComPlace_withOtherMap((*it_main)->global_index);
                (*it_main)->is_Send=true;
            }
            
        }
        else
        {
            last_P_main = tmp_t;
            need_resample_main.push_back(1);
        }
        
        Quaterniond tmp_q;
        Matrix3d tmp_r_origin;
        Vector3d tmp_t_origin;
        (*it_main)->getOriginPose(tmp_t_origin, tmp_r_origin);
//                (*it_main)->getPose(tmp_t, tmp_r);
        tmp_q = tmp_r_origin;
        t_array_main[resample_id][0] = tmp_t_origin(0);
        t_array_main[resample_id][1] = tmp_t_origin(1);
        t_array_main[resample_id][2] = tmp_t_origin(2);
        q_array_main[resample_id] = tmp_q;
        //将矩阵转换为向量
        Vector3d euler_angle = Utility::R2ypr(tmp_r_origin);
        euler_array_main[resample_id][0] = euler_angle.x();
        euler_array_main[resample_id][1] = euler_angle.y();
        euler_array_main[resample_id][2] = euler_angle.z();
        
        resample_id++;
        
        if ((*it_main)->global_index == latest_loop_index_main)
            break;
    }
    
    
    int main_agent_indexInFeatureMap=global_featureMap->getIndex_fromAgentId(main_clientId);
    global_featureMap->mMutex_ml_submap[main_agent_indexInFeatureMap]->lock();
    list<FeatureSubMap*> featureMap_main=global_featureMap->ml_submap[main_agent_indexInFeatureMap];
    global_featureMap->mMutex_ml_submap[main_agent_indexInFeatureMap]->unlock();
    
    for(auto iter_fm_main=featureMap_main.begin();iter_fm_main!=featureMap_main.end();iter_fm_main++){
        list<KeyFrame*> ml1_kf=(*iter_fm_main)->ml_keyframe;
        list<KeyFrame*> ml2_kf=(*iter_fm_main)->ml2_kf;
        
        int l1_kf_id=ml1_kf.front()->global_index;
        int l2_kf_id=ml2_kf.front()->global_index;
        while(l1_kf_id< earliest_loop_index_main){
            ml1_kf.pop_front();
            l1_kf_id=ml1_kf.front()->global_index;
        }
        while(l2_kf_id< earliest_loop_index_main){
            ml2_kf.pop_front();
            l2_kf_id=ml2_kf.front()->global_index;
        }
        
        KeyFrame* cur_kf_main_fm;
        while(ml1_kf.size()!=0 || ml2_kf.size()!=0){
            
        
            
            if(l1_kf_id< l2_kf_id){
                cur_kf_main_fm=ml1_kf.front();
                ml1_kf.pop_front();
            }else{
                cur_kf_main_fm=ml2_kf.front();
                ml2_kf.pop_front();
            }
            
            cur_kf_main_fm->resample_globalIndex = resample_id;
            Vector3d tmp_t;
            Matrix3d tmp_r;
            //获取关键帧it的位姿
            cur_kf_main_fm->getPose(tmp_t, tmp_r);
            
            //全局优化 还是要加序列边 不然太长了 判断条件 再加个两个地图之间发生了融合
    //        if((*it_main)->global_index == earliest_loop_index_main || dis_main > min_dis_main || (*it_main)->is_get_loop_info || (*it_main)->is_looped || (*it_main)->has_global_loop || (*it_main)->is_global_looped || pMainMap->keyFrameList.size() < max_frame_num_global_main)
                
//            if((cur_kf_main_fm)->global_index == earliest_loop_index_main || (cur_kf_main_fm)->is_looped ||  (cur_kf_main_fm)->is_global_looped || pMainMap->keyFrameList.size() < max_frame_num_global_main)
//            {
                
                need_resample_main.push_back(0);
                
    //            pMainMap->special_kf_inOpti.push_back((*it_main)->global_index);
                special_kf_inOpti_main.push_back((cur_kf_main_fm)->global_index);
                
                if(((cur_kf_main_fm)->has_global_loop || (cur_kf_main_fm)->is_global_looped) && (cur_kf_main_fm)->is_Send==false ){
                    kf_id_hasComPlace_main.push_back((cur_kf_main_fm)->global_index);
    //                pMainMap->add2_kf_id_hasComPlace_withOtherMap((*it_main)->global_index);
                    (cur_kf_main_fm)->is_Send=true;
                }
                
//            }
//            else
//            {
//
//                need_resample_main.push_back(1);
//            }
            
            Quaterniond tmp_q;
            Matrix3d tmp_r_origin;
            Vector3d tmp_t_origin;
            (cur_kf_main_fm)->getOriginPose(tmp_t_origin, tmp_r_origin);
    //                (*it_main)->getPose(tmp_t, tmp_r);
            tmp_q = tmp_r_origin;
            t_array_main[resample_id][0] = tmp_t_origin(0);
            t_array_main[resample_id][1] = tmp_t_origin(1);
            t_array_main[resample_id][2] = tmp_t_origin(2);
            q_array_main[resample_id] = tmp_q;
            //将矩阵转换为向量
            Vector3d euler_angle = Utility::R2ypr(tmp_r_origin);
            euler_array_main[resample_id][0] = euler_angle.x();
            euler_array_main[resample_id][1] = euler_angle.y();
            euler_array_main[resample_id][2] = euler_angle.z();
            
            resample_id++;
            
            if ((cur_kf_main_fm)->global_index == latest_loop_index_main)
                break;
            
        }
        if ((cur_kf_main_fm)->global_index == latest_loop_index_main)
            break;
    }
    
    
    
    
//    pMainMap->special_kf_mutex.lock();
//    pMainMap->add2_kf_id_hasComPlace_withOtherMap(kf_id_hasComPlace_main);
//   pMainMap->special_kf_inOpti.push(special_kf_inOpti_main);
//   pMainMap->special_kf_mutex.unlock();
    
    vector<vector<int> > special_kf_inOpti_cur_all;
    vector<vector<int> > kf_id_hasCom_cur_all;
    
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
        //遍历关键帧列表
        list<KeyFrame*>::iterator it_other = pMap_other->keyFrameList.begin();

        Vector3d last_P_other = Vector3d(0, 0, 0);
        double dis_other = 0;
        
        vector<int> special_kf_inOpti_cur;
        vector<int> kf_id_hasCom_cur;
        resample_id=0;
        resample_other_all[flag_start].clear();
       
        //小地图是从第一个帧开始优化
        for(;it_other!=pMap_other->keyFrameList.end();it_other++){
            (*it_other)->resample_globalIndex = resample_id;
            
            Vector3d tmp_t;
            Matrix3d tmp_r;
            //获取关键帧it的位姿
            (*it_other)->getPose(tmp_t, tmp_r);
            dis_other += (tmp_t - last_P_other).norm();
            
            
            //全局优化 还是要加序列边 不然太长了 判断条件 再加个两个地图之间发生了融合
            //第一个地图融合位置，超过长度了，发生过回环，被回环了，总共的帧长度比最大值小
            //还要再加一个 发生了融合，被融合了
            if((*it_other)->global_index == 0 || dis_other > pMap_other->min_dis || (*it_other)->is_get_loop_info || (*it_other)->is_looped || (*it_other)->has_global_loop || (*it_other)->is_global_looped || pMap_other->keyFrameList.size() < pMap_other->max_frame_num_global)
            {
                dis_other = 0;
                last_P_other = tmp_t;
                resample_other_all[flag_start].push_back(0);
                
    //            pCurMap->special_kf_inOpti.push_back((*it_other)->global_index);
                special_kf_inOpti_cur.push_back((*it_other)->global_index);
                
                if(((*it_other)->has_global_loop || (*it_other)->is_global_looped) && (*it_other)->is_Send==false ){
                    kf_id_hasCom_cur.push_back((*it_other)->global_index);
    //                pCurMap->add2_kf_id_hasComPlace_withOtherMap((*it_other)->global_index);
                    (*it_other)->is_Send=true;
                }
                
            }
            else
            {
                last_P_other = tmp_t;
                resample_other_all[flag_start].push_back(1);
            }
            
            Quaterniond tmp_q;
            Matrix3d tmp_r_origin;
            Vector3d tmp_t_origin;
            (*it_other)->getOriginPose(tmp_t_origin, tmp_r_origin);
    //                (*it_main)->getPose(tmp_t, tmp_r);
            tmp_q = tmp_r_origin;
            (t_other_all[flag_start])[resample_id][0] = tmp_t_origin(0);
            (t_other_all[flag_start])[resample_id][1] = tmp_t_origin(1);
            (t_other_all[flag_start])[resample_id][2] = tmp_t_origin(2);
            q_other_all[flag_start][resample_id] = tmp_q;
            //将矩阵转换为向量
            Vector3d euler_angle = Utility::R2ypr(tmp_r_origin);
            euler_other_all[flag_start][resample_id][0] = euler_angle.x();
            euler_other_all[flag_start][resample_id][1] = euler_angle.y();
            euler_other_all[flag_start][resample_id][2] = euler_angle.z();
            
            resample_id++;
            
            if ((*it_other)->global_index == latest_loopIndex_other_all[flag_start])
                break;
        }
        
//        pMap_other->special_kf_mutex.lock();
//        pMap_other->add2_kf_id_hasComPlace_withOtherMap(kf_id_hasCom_cur);
//        pMap_other->special_kf_inOpti.push(special_kf_inOpti_cur);
//        pMap_other->special_kf_mutex.unlock();
        special_kf_inOpti_cur_all.push_back(special_kf_inOpti_cur);
        kf_id_hasCom_cur_all.push_back(kf_id_hasCom_cur);
        
    }
    
    //*************************************第一个数据
//    if(pMainMap->relativeOtherMap_clientId!=-1){
//        assert(false);//因为最小的地图 那他没有和更小的地图融合 relativeOtherMap_clientId这个记录它融合的所有地图的最小id
//    }

//    暂时注释 后面会求导那些了 再改
//        ceres::LocalParameterization *local_parameterization = new PoseQ_LocalParameterization();
//        problem.AddParameterBlock(r_global_main_relative, 4, local_parameterization);
//        problem.SetParameterBlockConstant(r_global_main_relative);
//
//        problem.AddParameterBlock(t_global_main_relative, 3);
//        problem.SetParameterBlockConstant(t_global_main_relative);

    int i_main = 0;
    for (it_main = pMainMap->keyFrameList.begin(); it_main != pMainMap->keyFrameList.end(); it_main++)
    {
        if ((*it_main)->global_index < earliest_loop_index_main)
            continue;

        
        //将关键帧列表中所有index>=earliest_loop_index的关键帧的位姿加入到参数块当中
        problem.AddParameterBlock(euler_array_main[i_main], 1, angle_local_parameterization);
        problem.AddParameterBlock(t_array_main[i_main], 3);
        //设置约束：如果该帧是最早的闭环帧的情况下，则固定它的位姿
        if ((*it_main)->global_index == earliest_loop_index_main)
        {
            problem.SetParameterBlockConstant(euler_array_main[i_main]);
            problem.SetParameterBlockConstant(t_array_main[i_main]);
        }
        
        if(need_resample_main[i_main])
        {
            i_main++;
            continue;
        }
        
        
        int j = 1, sequence_link_cnt = 0;
        while(sequence_link_cnt < 5)
        {
            if (i_main - j >= 0)
            {
//                        list<KeyFrame*>::iterator tmp = it_main;
//                        std::advance (tmp, -j);
                if(need_resample_main[i_main-j])
                {
                    j++;
                    continue;
                }
                else
                {
                    sequence_link_cnt++;
                }
                Vector3d euler_conncected = Utility::R2ypr(q_array_main[i_main-j].toRotationMatrix());
                //p̂_j^w - p̂_i^w 计算平移量的偏差
                Vector3d relative_t(t_array_main[i_main][0] - t_array_main[i_main-j][0], t_array_main[i_main][1] - t_array_main[i_main-j][1], t_array_main[i_main][2] - t_array_main[i_main-j][2]);
                //p̂_{ij}^{i} = {R̂_i^w}^{-1} (p̂_j^w - p̂_i^w)
                //p̂ ij= (R̂ iw ) (p̂ jw − p̂ iw )
                relative_t = q_array_main[i_main-j].inverse() * relative_t;
                //ψ̂ _ij = ψ̂ _j − ψ̂ _i
                double relative_yaw = euler_array_main[i_main][0] - euler_array_main[i_main-j][0];
//                cout<<"主地图序列帧relative_t："<<relative_t[0]<<" , "<<relative_t[1]<<" , "<<relative_t[2]<<endl;
//                cout<<"主地图序列帧euler_conncected："<<euler_conncected[0]<<" , "<<euler_conncected[1]<<" , "<<euler_conncected[2]<<endl;
//                cout<<"主地图序列帧relative_yaw："<<relative_yaw<<endl;
                ceres::CostFunction* cost_function = FourDOFError_another::Create( relative_t.x(), relative_t.y(), relative_t.z(),
                                                                          relative_yaw, euler_conncected.y(), euler_conncected.z());
                problem.AddResidualBlock(cost_function, loss_function, euler_array_main[i_main-j],
                                         t_array_main[i_main-j],
                                         euler_array_main[i_main],
                                         t_array_main[i_main]);
            }
            else
            {
                break;
            }
            j++;
        }

        //        添加的是闭环边，是指检测到闭环的两帧
        if((*it_main)->is_get_loop_info   )
        {
            if((*it_main)->loop_index >= earliest_loop_index_main)
            {
                int connected_index = pMainMap->getKeyframe((*it_main)->loop_index)->resample_globalIndex;

                Vector3d euler_conncected = Utility::R2ypr(q_array_main[connected_index].toRotationMatrix());
                Vector3d relative_t((*it_main)->loop_info_better(0), (*it_main)->loop_info_better(1), (*it_main)->loop_info_better(2));
                double relative_yaw = (*it_main)->loop_info_better(3);
//                cout<<"主地图回环relative_t："<<relative_t[0]<<" , "<<relative_t[1]<<" , "<<relative_t[2]<<endl;
//                cout<<"主地图回环euler_conncected："<<euler_conncected[0]<<" , "<<euler_conncected[1]<<" , "<<euler_conncected[2]<<endl;
//                cout<<"主地图回环relative_yaw："<<relative_yaw<<endl;
                ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),
                                                                                relative_yaw, euler_conncected.y(), euler_conncected.z(),10.0);
                problem.AddResidualBlock(cost_function, NULL, euler_array_main[connected_index],
                                         t_array_main[connected_index],
                                         euler_array_main[i_main],
                                         t_array_main[i_main]);
            }else{
                cout<<"主地图回环id:"<<(*it_main)->loop_index<<" , "<<earliest_loop_index_main<<endl;
                assert(false);//报错36 37
            }
        }

        
        if((*it_main)->has_global_loop)
       {
           //这里后面还要添加else
           if((*it_main)->global_loop_index < 0)
           {
               //因为这意味着数据保存出错了 发生了融合的帧的id小于最早发生融合的id
               assert(false);
               return;
           }
//           获取是和哪个其它地图发生了回环
           (*it_main)->readWriteLock_loop.readLock();
           int loop_index_flag_end=(*it_main)->clientId.size();
           (*it_main)->readWriteLock_loop.readUnLock();
//           遍历该帧的 所有回环帧
           for(int loop_index_flag=0;loop_index_flag<loop_index_flag_end;loop_index_flag++){
               (*it_main)->readWriteLock_loop.readLock();
               int matching_clientId=(*it_main)->clientId[loop_index_flag];
               int matching_kfId=(*it_main)->kfId[loop_index_flag];
               std::pair<Matrix3d , Vector3d > matching_rt=(*it_main)->relativePose[loop_index_flag];
               (*it_main)->readWriteLock_loop.readUnLock();
               
//               找到这个对应的其它地图
               int vmap_index=vMapId_all[matching_clientId];
               PoseGraph * pMap_other=vMap_all[vmap_index];
               //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束 会出现空指针的问题
               int connected_index = pMap_other->getKeyframe(matching_kfId)->resample_globalIndex;//这里可能多个
               
               if(matching_kfId < earliest_loopIndex_other_all[vmap_index])
               {
                   //因为这意味着数据保存出错了 发生了融合的帧的id小于最早发生融合的id
                   assert(false);
                   return;
               }
               
               Vector3d euler_conncected = Utility::R2ypr(q_other_all[vmap_index][connected_index].toRotationMatrix());
               Vector3d relative_t((*it_main)->relative_global_loop_info_multiClient[loop_index_flag](0), (*it_main)->relative_global_loop_info_multiClient[loop_index_flag](1), (*it_main)->relative_global_loop_info_multiClient[loop_index_flag](2));
               double relative_yaw = (*it_main)->relative_global_loop_info_multiClient[loop_index_flag](7);
               
               //这里到时候 再写一个求导的
               ceres::CostFunction* cost_function1 = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z(),10.0);
               problem.AddResidualBlock(cost_function1, NULL, euler_other_all[vmap_index][connected_index] ,
                                       t_other_all[vmap_index][connected_index] ,
                                        euler_array_main[i_main],
                                        t_array_main[i_main]);
               
//               MultiClientFactor_merge *f = new MultiClientFactor_merge(relative_t, euler_conncected.y(), euler_conncected.z());
//               problem.AddResidualBlock(f, NULL, euler_other_all[vmap_index][connected_index] ,
//                                        t_other_all[vmap_index][connected_index] , t_array_main[i_main] ,t_global_all[vmap_index][connected_index],r_global_all[vmap_index][connected_index],t_global_main_relative,r_global_main_relative);
//
//               Vector3d euler_conncected_j = Utility::R2ypr(q_array_main[i_main].toRotationMatrix());
//               ceres::CostFunction* cost_function = EightDOFWeightError_yaw::Create( relative_yaw, euler_conncected.y(), euler_conncected.z(),euler_conncected_j.y(),euler_conncected_j.z());
//             problem.AddResidualBlock(cost_function, NULL, euler_other_all[vmap_index][connected_index] ,euler_array_main[i_main] , r_global_all[vmap_index][connected_index] ,r_global_main_relative);
               
//               同上暂时注释的
//               MultiClientFactor_merge *f = new MultiClientFactor_merge(relative_t, euler_conncected.y(), euler_conncected.z());
//               problem.AddResidualBlock(f, NULL, euler_other_all[vmap_index][connected_index] ,
//                                        t_other_all[vmap_index][connected_index] , t_array_main[i_main] ,t_global_all[vmap_index],r_global_all[vmap_index],t_global_main_relative,r_global_main_relative);
//
//               Vector3d euler_conncected_j = Utility::R2ypr(q_array_main[i_main].toRotationMatrix());
//               ceres::CostFunction* cost_function = EightDOFWeightError_yaw::Create( relative_yaw, euler_conncected.y(), euler_conncected.z(),euler_conncected_j.y(),euler_conncected_j.z());
//             problem.AddResidualBlock(cost_function, NULL, euler_other_all[vmap_index][connected_index] ,euler_array_main[i_main] , r_global_all[vmap_index] ,r_global_main_relative);
           }
          
           
           
       }
        
        
        if ((*it_main)->global_index == latest_loop_index_main)
            break;
        i_main++;
    }
    
    int i_other = 0;
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
//        problem.AddParameterBlock(&pitch_other_all[flag_start], 1);
//        problem.AddParameterBlock(&roll_other_all[flag_start], 1);
        i_other = 0;
//        同上暂时注释的
//        problem.AddParameterBlock(r_global_all[flag_start], 4, local_parameterization);
////        problem.SetParameterBlockConstant(r_global_all[flag_start]);
//        problem.AddParameterBlock(t_global_all[flag_start], 3);
////        problem.SetParameterBlockConstant(t_global_all[flag_start]);
        for (auto it_other = pMap_other->keyFrameList.begin(); it_other != pMap_other->keyFrameList.end(); it_other++)
        {
            //将关键帧列表中所有index>=earliest_loop_index的关键帧的位姿加入到参数块当中
           
            problem.AddParameterBlock(euler_other_all[flag_start][i_other], 1, angle_local_parameterization);
            problem.AddParameterBlock(t_other_all[flag_start][i_other], 3);

//            ceres::LocalParameterization *local_parameterization = new PoseQ_LocalParameterization();
//            problem.AddParameterBlock(r_global_all[flag_start][i_other], 4, local_parameterization);
//            problem.AddParameterBlock(t_global_all[flag_start][i_other], 3);
            
            if(resample_other_all[flag_start][i_other])
            {
               
                i_other++;
                continue;
            }
            
//            if(i_other>0){
//
//                ceres::CostFunction* cost_function = SixDOFWeightError_relativeR::Create( );
//                problem.AddResidualBlock(cost_function, NULL, r_global_all[flag_start][i_other-1],
//                                       r_global_all[flag_start][i_other]);
//
//
//                ceres::CostFunction* cost_function_t = SixDOFWeightError_relativet::Create( );
//                problem.AddResidualBlock(cost_function_t, NULL, t_global_all[flag_start][i_other-1],
//                                       t_global_all[flag_start][i_other]);
//            }


            int j = 1, sequence_link_cnt = 0;
            while(sequence_link_cnt < 5)
            {
                if (i_other - j >= 0)
                {

                    if(resample_other_all[flag_start][i_other-j])
                    {
                        j++;
                        continue;
                    }
                    else
                    {
                        sequence_link_cnt++;
                    }
                    Vector3d euler_conncected = Utility::R2ypr(q_other_all[flag_start][i_other-j].toRotationMatrix());
                    //p̂_j^w - p̂_i^w 计算平移量的偏差
                    Vector3d relative_t(t_other_all[flag_start][i_other][0] - t_other_all[flag_start][i_other-j][0], t_other_all[flag_start][i_other][1] - t_other_all[flag_start][i_other-j][1], t_other_all[flag_start][i_other][2] - t_other_all[flag_start][i_other-j][2]);
                    //p̂_{ij}^{i} = {R̂_i^w}^{-1} (p̂_j^w - p̂_i^w)
                    //p̂ ij= (R̂ iw ) (p̂ jw − p̂ iw )
                    relative_t = q_other_all[flag_start][i_other-j].inverse() * relative_t;
                    //ψ̂ _ij = ψ̂ _j − ψ̂ _i
                    double relative_yaw = euler_other_all[flag_start][i_other][0] - euler_other_all[flag_start][i_other-j][0];
//                    cout<<"其它地图序列帧relative_t："<<relative_t[0]<<" , "<<relative_t[1]<<" , "<<relative_t[2]<<endl;
//                    cout<<"其它地图序列帧euler_conncected："<<euler_conncected[0]<<" , "<<euler_conncected[1]<<" , "<<euler_conncected[2]<<endl;
//                    cout<<"其它地图序列帧relative_yaw："<<relative_yaw<<endl;
                    ceres::CostFunction* cost_function = FourDOFError_another::Create( relative_t.x(), relative_t.y(), relative_t.z(),
                                                                              relative_yaw, euler_conncected.y(), euler_conncected.z());
                    problem.AddResidualBlock(cost_function, loss_function, euler_other_all[flag_start][i_other-j],
                                             t_other_all[flag_start][i_other-j],
                                             euler_other_all[flag_start][i_other],
                                             t_other_all[flag_start][i_other]);
                }
                else
                {
                    break;
                }
                j++;
            }
          
            //        添加的是闭环边，是指检测到闭环的两帧 一个数据拆成两份 这个注释掉了
            if((*it_other)->is_get_loop_info)
            {
                //这里后面还要添加else
                if((*it_other)->loop_index <0)
                {
                    assert(false);
                }
                //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束
                int connected_index = pMap_other->getKeyframe((*it_other)->loop_index)->resample_globalIndex;

                Vector3d euler_conncected = Utility::R2ypr(q_other_all[flag_start][connected_index].toRotationMatrix());
                Vector3d relative_t((*it_other)->loop_info_better(0), (*it_other)->loop_info_better(1), (*it_other)->loop_info_better(2));
                double relative_yaw = (*it_other)->loop_info_better(3);
                
                ceres::CostFunction* cost_function = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z(),10.0);
                problem.AddResidualBlock(cost_function, NULL, euler_other_all[flag_start][connected_index],
                                         t_other_all[flag_start][connected_index],
                                         euler_other_all[flag_start][i_other],
                                         t_other_all[flag_start][i_other]);
                
            }
           
            if((*it_other)->has_global_loop)
           {
    //           获取是和哪个其它地图发生了回环
              (*it_other)->readWriteLock_loop.readLock();
              int loop_index_flag_end=(*it_other)->clientId.size();
              (*it_other)->readWriteLock_loop.readUnLock();
    //           遍历该帧的 所有回环帧
              for(int loop_index_flag=0;loop_index_flag<loop_index_flag_end;loop_index_flag++){
                  (*it_other)->readWriteLock_loop.readLock();
                  int matching_clientId=(*it_other)->clientId[loop_index_flag];
                  int matching_kfId=(*it_other)->kfId[loop_index_flag];
                  std::pair<Matrix3d , Vector3d > matching_rt=(*it_other)->relativePose[loop_index_flag];
                  (*it_other)->readWriteLock_loop.readUnLock();
                  
//                  Vector3d euler_conncected = Utility::R2ypr(matching_rt.first);
//                  Vector3d relative_t=matching_rt.second;
//                  double relative_yaw = euler_conncected[0];
                  
                  if(matching_clientId==pMainMap->c->id){
                      if(matching_kfId < earliest_loop_index_main)
                      {
                          //因为这意味着数据保存出错了 发生了融合的帧的id小于最早发生融合的id
                          assert(false);
                          return;
                      }
                      //说明是和此次新增地图 发生匹配
                      //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束
                      int connected_index = pMainMap->getKeyframe(matching_kfId)->resample_globalIndex;
                      
//                      double relative_yaw =euler_conncected[0]-euler_array_main[connected_index][0];
                      
                      Vector3d euler_conncected = Utility::R2ypr(q_array_main[connected_index].toRotationMatrix());
                      Vector3d relative_t((*it_other)->relative_global_loop_info_multiClient[loop_index_flag](0), (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](1), (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](2));
                      double relative_yaw = (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](7);

                      //这里到时候 再写一个求导的
                      ceres::CostFunction* cost_function1 = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z(),10.0);
                      problem.AddResidualBlock(cost_function1, NULL, euler_array_main[connected_index],
                                               t_array_main[connected_index],
                                               euler_other_all[flag_start][i_other],
                                               t_other_all[flag_start][i_other]);
                      
//                      MultiClientFactor_merge *f = new MultiClientFactor_merge(relative_t, euler_conncected.y(), euler_conncected.z());
//                      problem.AddResidualBlock(f, NULL, euler_array_main[connected_index],
//                                               t_array_main[connected_index],t_other_all[flag_start][i_other] ,t_global_main_relative,r_global_main_relative ,t_global_all[flag_start][i_other] ,r_global_all[flag_start][i_other]);
//
//                      Vector3d euler_conncected_j = Utility::R2ypr(q_other_all[flag_start][i_other].toRotationMatrix());
//                      ceres::CostFunction* cost_function = EightDOFWeightError_yaw::Create( relative_yaw, euler_conncected.y(), euler_conncected.z(),euler_conncected_j.y(),euler_conncected_j.z());
//                    problem.AddResidualBlock(cost_function, NULL, euler_array_main[connected_index],euler_other_all[flag_start][i_other],r_global_main_relative ,r_global_all[flag_start][i_other]);
                      
//                      同上暂时注释的
//                      MultiClientFactor_merge *f = new MultiClientFactor_merge(relative_t, euler_conncected.y(), euler_conncected.z());
//                      problem.AddResidualBlock(f, NULL, euler_array_main[connected_index],
//                                               t_array_main[connected_index],t_other_all[flag_start][i_other] ,t_global_main_relative,r_global_main_relative ,t_global_all[flag_start] ,r_global_all[flag_start]);
//
//                      Vector3d euler_conncected_j = Utility::R2ypr(q_other_all[flag_start][i_other].toRotationMatrix());
//                      ceres::CostFunction* cost_function = EightDOFWeightError_yaw::Create( relative_yaw, euler_conncected.y(), euler_conncected.z(),euler_conncected_j.y(),euler_conncected_j.z());
//                    problem.AddResidualBlock(cost_function, NULL, euler_array_main[connected_index],euler_other_all[flag_start][i_other],r_global_main_relative ,r_global_all[flag_start]);
                      
                  }else{
                      int vmap_index=vMapId_all[matching_clientId];
                      if(matching_kfId < earliest_loopIndex_other_all[vmap_index])
                      {
                          //因为这意味着数据保存出错了 发生了融合的帧的id小于最早发生融合的id
                          assert(false);
                          return;
                      }
                      
        //               找到这个对应的其它地图
                      PoseGraph * pMap_fuse=vMap_all[vmap_index];
                      //这里要改 因为融合可能会发生得比较晚 可以考虑在前面找的时候记录一下 这里先暂时不考虑用这些约束 会出现空指针的问题
                      int connected_index = pMap_fuse->getKeyframe(matching_kfId)->resample_globalIndex;//这里可能多个
                        
    //                  double relative_yaw =euler_conncected[0]-euler_other_all[vmap_index][connected_index][0];
                      
                      Vector3d euler_conncected = Utility::R2ypr(q_other_all[vmap_index][connected_index].toRotationMatrix());
                      Vector3d relative_t((*it_other)->relative_global_loop_info_multiClient[loop_index_flag](0), (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](1), (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](2));
                      double relative_yaw = (*it_other)->relative_global_loop_info_multiClient[loop_index_flag](7);

                       //这里到时候 再写一个求导的
                       ceres::CostFunction* cost_function1 = FourDOFWeightError::Create( relative_t.x(), relative_t.y(), relative_t.z(),relative_yaw, euler_conncected.y(), euler_conncected.z(),10.0);
                       problem.AddResidualBlock(cost_function1, NULL, euler_other_all[vmap_index][connected_index],
                                            t_other_all[vmap_index][connected_index],
                                            euler_other_all[flag_start][i_other],
                                            t_other_all[flag_start][i_other]);
                      
//                      MultiClientFactor_merge *f = new MultiClientFactor_merge(relative_t, euler_conncected.y(), euler_conncected.z());
//                      problem.AddResidualBlock(f, NULL, euler_other_all[vmap_index][connected_index],
//                                                 t_other_all[vmap_index][connected_index] ,t_other_all[flag_start][i_other],t_global_all[vmap_index][connected_index],r_global_all[vmap_index][connected_index] ,t_global_all[flag_start][i_other],r_global_all[flag_start][i_other]);
//
//                      Vector3d euler_conncected_j = Utility::R2ypr(q_other_all[flag_start][i_other].toRotationMatrix());
//                      ceres::CostFunction* cost_function = EightDOFWeightError_yaw::Create( relative_yaw, euler_conncected.y(), euler_conncected.z(),euler_conncected_j.y(),euler_conncected_j.z());
//                    problem.AddResidualBlock(cost_function, NULL, euler_other_all[vmap_index][connected_index] ,euler_other_all[flag_start][i_other] , r_global_all[vmap_index][connected_index] ,r_global_all[flag_start][i_other]);
                      
//                      同上暂时注释的
//                      MultiClientFactor_merge *f = new MultiClientFactor_merge(relative_t, euler_conncected.y(), euler_conncected.z());
//                      problem.AddResidualBlock(f, NULL, euler_other_all[vmap_index][connected_index],
//                                                 t_other_all[vmap_index][connected_index] ,t_other_all[flag_start][i_other],t_global_all[vmap_index] ,r_global_all[vmap_index] ,t_global_all[flag_start] ,r_global_all[flag_start] );
//
//                      Vector3d euler_conncected_j = Utility::R2ypr(q_other_all[flag_start][i_other].toRotationMatrix());
//                      ceres::CostFunction* cost_function = EightDOFWeightError_yaw::Create( relative_yaw, euler_conncected.y(), euler_conncected.z(),euler_conncected_j.y(),euler_conncected_j.z());
//                    problem.AddResidualBlock(cost_function, NULL, euler_other_all[vmap_index][connected_index] ,euler_other_all[flag_start][i_other] , r_global_all[vmap_index]  ,r_global_all[flag_start] );
                  }
                  
                  
              }
           }
            if ((*it_other)->global_index == latest_loopIndex_other_all[flag_start])
                break;
            i_other++;
          
        }

    }
    
    ceres::Solve(options, &problem, &summary);
    
    std::cout << "global fuse: "<<summary.BriefReport() << "\n";
    if(summary.termination_type!=ceres::CONVERGENCE){
        
        return;
    }
    
    pMainMap->special_kf_mutex.lock();
    pMainMap->add2_kf_id_hasComPlace_withOtherMap(kf_id_hasComPlace_main);
    pMainMap->special_kf_inOpti.push(special_kf_inOpti_main);
    pMainMap->special_kf_mutex.unlock();
    pMainMap->loop_index_multiClient.push(earliest_loop_index_main);
    pMainMap->curKF_loop_index_multiClient.push(latest_loop_index_main);//这个是要发回客户端 用来更新位姿的 TODO 后面要改改
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
        vector<int> special_kf_inOpti_cur=special_kf_inOpti_cur_all[flag_start];
        vector<int> kf_id_hasCom_cur=kf_id_hasCom_cur_all[flag_start];
        pMap_other->special_kf_mutex.lock();
        pMap_other->add2_kf_id_hasComPlace_withOtherMap(kf_id_hasCom_cur);
        pMap_other->special_kf_inOpti.push(special_kf_inOpti_cur);
        pMap_other->special_kf_mutex.unlock();
        
        int latest_loop_index=latest_loop_index_other_correct[flag_start];
        pMap_other->isFirstFusion_globalMutex.lock();
        pMap_other->loop_index_multiClient.push(0);
        pMap_other->curKF_loop_index_multiClient.push(latest_loop_index);
        pMap_other->isFirstFusion_globalMutex.unlock();
    }
    //------------------------------------------第一个数据优化后更新
    //优化完成，使用优化后的位姿来更新关键帧列表中index大于等于earliest_loop_index的所有关键帧的位姿
    
    Vector3d t_drift_it_other = Vector3d::Zero();
    Matrix3d r_drift_it_other = Matrix3d::Identity();
    
    vector<Matrix3d> r_global_cur;
    vector<Vector3d> t_global_cur;
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
        list<KeyFrame*>::iterator it_other = pMap_other->keyFrameList.begin();
        i_other = 0;
        r_global_cur.clear();
        t_global_cur.clear();
        for (; it_other != pMap_other->keyFrameList.end(); it_other++)
        {
            
            Quaterniond tmp_q;
            //向量转换为矩阵
            tmp_q = Utility::ypr2R(Vector3d(euler_other_all[flag_start][i_other][0], euler_other_all[flag_start][i_other][1], euler_other_all[flag_start][i_other][2]));
            Vector3d tmp_w1_t = Vector3d(t_other_all[flag_start][i_other][0], t_other_all[flag_start][i_other][1], t_other_all[flag_start][i_other][2]);
            Matrix3d tmp_w1_r = tmp_q.toRotationMatrix();
            
         
           
            if(resample_other_all[flag_start][i_other])
            {
                (*it_other)-> updatePose(r_drift_it_other * tmp_w1_t + t_drift_it_other, r_drift_it_other * tmp_w1_r);
            }
            else
            {
                Vector3d origin_t_it;
                Matrix3d origin_r_it;
                (*it_other)->getOriginPose(origin_t_it, origin_r_it);
                
                
                r_drift_it_other = tmp_w1_r * origin_r_it.transpose();
                t_drift_it_other = tmp_w1_t - r_drift_it_other * origin_t_it;
                (*it_other)-> updatePose(tmp_w1_t, tmp_w1_r);
                
    //            pCurMap->add2_r_global_multiClient(tmp_w1_r);
    //            pCurMap->add2_t_global_multiClient(tmp_w1_t);
                r_global_cur.push_back(tmp_w1_r);
                t_global_cur.push_back(tmp_w1_t);
            }
            if ((*it_other)->global_index == latest_loopIndex_other_all[flag_start])
                break;
            i_other++;
            
        }
        //如果将地图建模成可变形的呢
        //根据计算出当前帧的drift，更新全部关键帧位姿
        Vector3d cur_t_other, origin_t_other;
        Matrix3d cur_r_other, origin_r_other;
        //获取优化后当前帧的位姿cur_t,cur_r
        (*it_other)->getPose(cur_t_other, cur_r_other);
        //获取优化前有漂移的当前帧的位姿vio_t,vio_r
        (*it_other)->getOriginPose(origin_t_other, origin_r_other);
        pMap_other->yaw_drift = Utility::R2ypr(cur_r_other).x() - Utility::R2ypr(origin_r_other).x();
        pMap_other->r_drift = Utility::ypr2R(Vector3d(pMap_other->yaw_drift, 0, 0));
        pMap_other->t_drift = cur_t_other - pMap_other->r_drift * origin_t_other;
        
    //    pCurMap->add2_r_global_multiClient(pCurMap->r_drift);
    //    pCurMap->add2_t_global_multiClient(pCurMap->t_drift);
        r_global_cur.push_back(pMap_other->r_drift);
        t_global_cur.push_back(pMap_other->t_drift);
        pMap_other->add2_r_global_multiClient(r_global_cur);
        pMap_other->add2_t_global_multiClient(t_global_cur);
        if((r_global_cur.size()-1)!=pMap_other->special_kf_inOpti.back().size() && (r_global_cur.size()-1)!=(t_global_cur.size()-1)){
            cout<<"当前地图id"<<pMap_other->c->id<<" , "<<latest_loopIndex_other_all[flag_start]<<endl;
            cout<<"resample下标数量不一致："<<r_global_cur.size()<<" , "<<pMap_other->special_kf_inOpti.back().size()<<" , "<<t_global_cur.size()<<endl;
//            while (pMap_other->special_kf_inOpti.size()!=2)
//            {
//                cout << pMap_other->special_kf_inOpti.front().size()<< " "; // Output the 1st element
//                pMap_other->special_kf_inOpti.pop();  // Delete the 1st element
//            }
//            std::cout << std::endl;
//            cout << "倒数第二个："<<pMap_other->special_kf_inOpti.front().size()<< endl;
            assert(false);//20 38
        }

        //下面代码为把当前关键帧it之后的关键帧的位姿通过求解的偏移量转换到world坐标系下
        for (; it_other != pMap_other->keyFrameList.end(); it_other++)
        {
            Vector3d P;
            Matrix3d R;
            (*it_other)->getOriginPose(P, R);
            P = pMap_other->r_drift * P + pMap_other->t_drift;
            R = pMap_other->r_drift * R;
            (*it_other)-> updatePose(P, R);
        }
        pMap_other->lastKF_index.push(pMap_other->keyFrameList.back()->global_index);
    }
    
    
    
    //---------------------------------------第2个数据的更新
    //优化完成，使用优化后的位姿来更新关键帧列表中index大于等于earliest_loop_index的所有关键帧的位姿
    i_main = 0;
    Vector3d t_drift_it_main = Vector3d::Zero();
    Matrix3d r_drift_it_main = Matrix3d::Identity();
    
    vector<Matrix3d> r_global_main;
    vector<Vector3d> t_global_main;
    for (it_main = pMainMap->keyFrameList.begin(); it_main != pMainMap->keyFrameList.end(); it_main++)
    {
        if ((*it_main)->global_index < earliest_loop_index_main)
            continue;

        Quaterniond tmp_q;
        //向量转换为矩阵
        tmp_q = Utility::ypr2R(Vector3d(euler_array_main[i_main][0], euler_array_main[i_main][1], euler_array_main[i_main][2]));
        Vector3d tmp_w1_t = Vector3d(t_array_main[i_main][0], t_array_main[i_main][1], t_array_main[i_main][2]);
        Matrix3d tmp_w1_r = tmp_q.toRotationMatrix();

//                cout<<"测试 优化完成 更新哪里变了："<<euler_array_main[i_main][0]<<" "<<euler_array_main[i_main][1]<<" "<<euler_array_main[i_main][2]<<" "<<t_array_main[i_main][0]<<" "<<t_array_main[i_main][1]<<" "<<t_array_main[i_main][2]<<" "<<i_main<<endl;
        if(need_resample_main[i_main])
        {
            (*it_main)-> updatePose(r_drift_it_main * tmp_w1_t + t_drift_it_main, r_drift_it_main * tmp_w1_r);
        }
        else
        {
            Vector3d origin_t_it;
            Matrix3d origin_r_it;
            (*it_main)->getOriginPose(origin_t_it, origin_r_it);
            r_drift_it_main = tmp_w1_r * origin_r_it.transpose();
            t_drift_it_main = tmp_w1_t - r_drift_it_main * origin_t_it;
            (*it_main)-> updatePose(tmp_w1_t, tmp_w1_r);
            
//            pMainMap->add2_r_global_multiClient(tmp_w1_r);
//            pMainMap->add2_t_global_multiClient(tmp_w1_t);
            r_global_main.push_back(tmp_w1_r);
            t_global_main.push_back(tmp_w1_t);

        }
        if ((*it_main)->global_index == latest_loop_index_main)
            break;
        i_main++;

    }
    //根据计算出当前帧的drift，更新全部关键帧位姿
    Vector3d cur_t_main, origin_t_main;
    Matrix3d cur_r_main, origin_r_main;
    //获取优化后当前帧的位姿cur_t,cur_r
    (*it_main)->getPose(cur_t_main, cur_r_main);
    //获取优化前有漂移的当前帧的位姿vio_t,vio_r
    (*it_main)->getOriginPose(origin_t_main, origin_r_main);
    pMainMap->yaw_drift = Utility::R2ypr(cur_r_main).x() - Utility::R2ypr(origin_r_main).x();
    pMainMap->r_drift = Utility::ypr2R(Vector3d(pMainMap->yaw_drift, 0, 0));
    pMainMap->t_drift = cur_t_main - pMainMap->r_drift * origin_t_main;
    
//    pMainMap->add2_r_global_multiClient(pMainMap->r_drift);
//    pMainMap->add2_t_global_multiClient(pMainMap->t_drift);
    r_global_main.push_back(pMainMap->r_drift);
    t_global_main.push_back(pMainMap->t_drift);
    pMainMap->add2_r_global_multiClient(r_global_main);
    pMainMap->add2_t_global_multiClient(t_global_main);
    
    if((r_global_main.size()-1)!=pMainMap->special_kf_inOpti.back().size()  && (r_global_main.size()-1)!=(t_global_main.size()-1)){
        cout<<"当前地图id"<<pMainMap->c->id<<" , "<<latest_loop_index_main<<endl;
        cout<<"resample_main下标数量不一致："<<r_global_main.size()<<" , "<<pMainMap->special_kf_inOpti.back().size()<<" , "<<t_global_main.size()<<endl;
//        while (pMainMap->special_kf_inOpti.size()!=2)
//        {
//            cout << pMainMap->special_kf_inOpti.front().size()<< " "; // Output the 1st element
//            pMainMap->special_kf_inOpti.pop();  // Delete the 1st element
//        }
//        std::cout << std::endl;
//        cout << "倒数第二个："<<pMainMap->special_kf_inOpti.front().size()<< endl;
        assert(false);//20 38
    }
    

    //下面代码为把当前关键帧it之后的关键帧的位姿通过求解的偏移量转换到world坐标系下
    for (; it_main != pMainMap->keyFrameList.end(); it_main++)
    {
        Vector3d P;
        Matrix3d R;
        (*it_main)->getOriginPose(P, R);
        P = pMainMap->r_drift * P + pMainMap->t_drift;
        R = pMainMap->r_drift * R;
        (*it_main)-> updatePose(P, R);
    }
    
//    pCurMap->isFirstFusion_globalMutex.unlock();
    
    
    
    
    
    pMainMap->lastKF_index.push(pMainMap->keyFrameList.back()->global_index);
//            位姿更新都留到显示那里
    pMainMap->updateVisualization();
    
    readWriteLock.readLock();
    PoseGraph* pMainMap_0=PoseGraphGloabl_map[0];
    readWriteLock.readUnLock();
    
   
    pAddKfMap->refine_path_mutex.lock();
    if(isUpdateFusionDraw){
        pMainMap_0->fusion_relative_isUpdate[pMainMap->c->id]=0;
        pMainMap_0->fusion_poseGraph_mutex.lock();
        pMainMap_0->fusion_otherGraph[pMainMap->c->id]=pMainMap;
        pMainMap_0->fusion_poseGraph_mutex.unlock();
    }
    pAddKfMap->refine_path_mutex.unlock();
    
    
    
    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
        PoseGraph * pMap_other=vMap_all[flag_start];
        pMap_other->updateVisualization();
        pMap_other->isSendGloablData_multiClient=true;
        
        pAddKfMap->refine_path_mutex.lock();
        if(isUpdateFusionDraw){
            pMainMap_0->fusion_relative_isUpdate[pMap_other->c->id]=0;
            pMainMap_0->fusion_poseGraph_mutex.lock();
            pMainMap_0->fusion_otherGraph[pMap_other->c->id]=pMap_other;
            pMainMap_0->fusion_poseGraph_mutex.unlock();
        }
        pAddKfMap->refine_path_mutex.unlock();
        
        
        delete [](t_other_all[flag_start][0]);
        delete [](t_other_all[flag_start][1]);
        delete [](t_other_all[flag_start][2]);
        delete [](t_other_all[flag_start]);
        delete [](euler_other_all[flag_start][0]);
        delete [](euler_other_all[flag_start][1]);
        delete [](euler_other_all[flag_start][2]);
        delete [](euler_other_all[flag_start]);
        
//        for(int i=0;i<3;i++){
//            delete [](t_global_all[flag_start][i]);
//        }
//        delete [](t_global_all[flag_start]);
//        for(int i=0;i<4;i++){
//            delete [](r_global_all[flag_start][i]);
//        }
//        delete [](r_global_all[flag_start]);
              
    }
    //发送数据
    pMainMap->isSendGloablData_multiClient=true;
    
    //    TODO 用来多用户ar 发送ar位姿的
        pAddKfMap->isFirstFusion_globalMutex.lock();
        isFusion[i]=1;
        pAddKfMap->isFirstFusion_globalMutex.unlock();

    cout<<"最终的全局优化结束"<<i<<endl;
//    cout<<"测试 偏移对不对"<<pCurMap->t_drift[0]<<" "<<pCurMap->t_drift[1]<<" "<<pCurMap->t_drift[2]<<endl;
//    cout<<"主地图为："<<pMainMap->c->id<<endl;
//    for(int flag_start=0,flag_end=vMap_all.size();flag_start<flag_end;flag_start++){
//        cout<<"t:"<<t_global_all[flag_start][0]<<" , "<<t_global_all[flag_start][1]<<" , "<<t_global_all[flag_start][2]<<endl;
//        // roll (x-axis rotation)
//            double sinr_cosp = 2 * (r_global_all[flag_start][3] * r_global_all[flag_start][0] + r_global_all[flag_start][1] * r_global_all[flag_start][2]);
//            double cosr_cosp = 1 - 2 * (r_global_all[flag_start][0] * r_global_all[flag_start][0] + r_global_all[flag_start][1] * r_global_all[flag_start][1]);
//            double roll = std::atan2(sinr_cosp, cosr_cosp);
//
//            // pitch (y-axis rotation)
//            double sinp = 2 * (r_global_all[flag_start][3] * r_global_all[flag_start][1] - r_global_all[flag_start][2] * r_global_all[flag_start][0]);
//            double pitch;
//            if (std::abs(sinp) >= 1)
//                pitch = std::copysign(M_PI / 2, sinp); // use 90 degrees if out of range
//            else
//                pitch = std::asin(sinp);
//
//            // yaw (z-axis rotation)
//            double siny_cosp = 2 * (r_global_all[flag_start][3]* r_global_all[flag_start][2] + r_global_all[flag_start][0] * r_global_all[flag_start][1]);
//            double cosy_cosp = 1 - 2 * (r_global_all[flag_start][1] * r_global_all[flag_start][1] + r_global_all[flag_start][2] * r_global_all[flag_start][2]);
//            double yaw = std::atan2(siny_cosp, cosy_cosp);
//
//        cout<<"r:"<< yaw <<" , " <<pitch<<" , " <<roll<<endl;
//    }
    
}
